    .db FF ; DMC sample.
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db B6
    .db 42
    .db 04
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 20
    .db 49
    .db B5
    .db AA
    .db AA
    .db 4A
    .db 24
    .db 01
    .db 51
    .db DA
    .db B6
    .db AA
    .db 6D
    .db F7
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db F6
    .db 76 ; PTR set to here.
    .db DB
    .db AB
    .db 55
    .db A5
    .db 44
    .db 10
    .db 20
    .db 00
    .db 00
    .db 04
    .db 08
    .db 90
    .db 28
    .db 51
    .db AA
    .db 5A
    .db B5
    .db 6D
    .db 7B
    .db F7
    .db EE
    .db DD
    .db B7
    .db 77
    .db 5B
    .db 5B
    .db B5
    .db 52
    .db 49
    .db 12
    .db 12
    .db 09
    .db 12
    .db 22
    .db 49
    .db 48
    .db A5
    .db 2A
    .db 55
    .db 65
    .db B5
    .db B5
    .db AD
    .db B6
    .db 6D
    .db DB
    .db B6
    .db 6D
    .db DB
    .db B6
    .db B5
    .db AD
    .db D6
    .db AA
    .db 2A
    .db 55
    .db 4A
    .db A5
    .db 24
    .db 49
    .db 2A
    .db 09
    .db 95
    .db A2
    .db 54
    .db 49
    .db 53
    .db B5
    .db 44
    .db 6A
    .db D5
    .db 6A
    .db AD
    .db D6
    .db 44
    .db 00
    .db AB
    .db 6A ; DMC sample end.
    .db D5
    .db 44
    .db 44
    .db AD
    .db 44
    .db 44
    .db 44
    .db 54
    .db 44
    .db 95
    .db 44
    .db 52
    .db 00
    .db 00
    .db FF ; Drum sample here, 0xF1 bytes.
    .db B7
    .db 20
    .db 0B
    .db 00
    .db 00
    .db 00
    .db 00
    .db C0
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db C0
    .db 0B
    .db 00
    .db 00
    .db 80
    .db FD
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db 17
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db F0
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db 7E
    .db 51
    .db ED
    .db 44
    .db 81
    .db 10
    .db 01
    .db 82
    .db 18
    .db 2B
    .db 42
    .db 53
    .db 81
    .db 6F
    .db D8
    .db DB
    .db EB
    .db E7
    .db BF
    .db EB
    .db 1F
    .db FB
    .db 95
    .db 24
    .db 48
    .db 00
    .db 02
    .db 00
    .db E0
    .db C5
    .db C0
    .db BF
    .db F8
    .db FF
    .db FF
    .db BA
    .db 0E
    .db 7E
    .db C4
    .db 50
    .db 68
    .db 2A
    .db 56
    .db 02
    .db 6F
    .db 77
    .db 4E
    .db F8
    .db 45
    .db 95
    .db 20
    .db 56
    .db 50
    .db 63
    .db 3F
    .db F4
    .db FF
    .db F0
    .db 9D
    .db F8
    .db 21
    .db B2
    .db 20
    .db 8E
    .db 0D
    .db 18
    .db CF
    .db 82
    .db AF
    .db 8A
    .db E3
    .db 3F
    .db 78
    .db FD
    .db 18
    .db CE
    .db 02
    .db 87
    .db 58
    .db E0
    .db C4
    .db 47
    .db E9
    .db DF
    .db F1
    .db 53
    .db 3B
    .db 8A
    .db 97
    .db 38
    .db 08
    .db A9
    .db 03
    .db DE
    .db E2
    .db F8
    .db 0F
    .db 9E
    .db EC
    .db 89
    .db B2
    .db 07
    .db 38
    .db E2
    .db 63
    .db F1
    .db E3
    .db C3
    .db 7B
    .db 42
    .db AF
    .db 28
    .db 8E
    .db 2A
    .db 8E
    .db 42
    .db 83
    .db 5A
    .db 1D
    .db FA
    .db B1
    .db EB
    .db AB
    .db D6
    .db 62
    .db DA
    .db A1
    .db E2
    .db D0
    .db 34
    .db 9C
    .db 85
    .db 8E
    .db AE
    .db C4
    .db 7A
    .db 72
    .db 1D
    .db A6
    .db 55
    .db 1C
    .db B9
    .db 52
    .db 3D
    .db 8B
    .db 9E
    .db 9D
    .db 4E
    .db 96
    .db 2A
    .db 0B
    .db E2
    .db A8
    .db A4
    .db 95
    .db 2D
    .db BB
    .db 72
    .db AD
    .db F4
    .db 91
    .db 5A
    .db 8B
    .db 52
    .db 25
    .db 4E
    .db 9C
    .db 5A
    .db 79
    .db 6A
    .db D7
    .db A4
    .db 8E
    .db 9C
    .db 74
    .db B0
    .db A2
    .db B4
    .db 89
    .db 67
    .db 35
    .db 6D
    .db 2B
    .db 37
    .db B6
    .db 45
    .db A5
    .db A9
    .db C5
    .db A4
    .db 42 ; Drum sample end.
    .db 34
    .db 26
    .db 54
    .db 44
    .db 44
    .db 04
    .db 44
    .db 00
    .db 4A
    .db 44
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db ED
    .db BA
    .db 98
    .db 76
    .db 78
    .db 97
    .db AB
    .db CD
    .db A7
    .db 47
    .db 76
    .db 48
    .db 45
    .db 66
    .db 77
    .db 89
    .db FC
    .db 97
    .db 64
    .db FC
    .db 97
    .db 65
    .db FC
    .db 86
    .db 01
    .db 23
    .db 45
    .db 67
    .db 89
    .db AB
    .db CD
    .db EF
    .db FE
    .db A9
    .db ED
    .db FD
    .db 79
    .db BD
    .db FE
    .db D9
    .db 45
    .db 78
    .db 99
    .db AA
    .db BB
    .db CC
    .db DD
    .db EF
    .db 7A
    .db DE
    .db FF
    .db EF
    .db FD
    .db DF
    .db FE
    .db EF
    .db EF
    .db FD
    .db EF
    .db FE
    .db DF
    .db FF
    .db EE
    .db EE
    .db FF
    .db EF
    .db FF
    .db FF
    .db FF
    .db EF
    .db EF
    .db FF
    .db FF
    .db EF
    .db FF
    .db FF
    .db FF
    .db EF
    .db EF
    .db FF
    .db BF
    .db FF
    .db EE
    .db EE
    .db ED
    .db ED
    .db DD
    .db BB
    .db BB
    .db AA
    .db AA
    .db 99
    .db 98
    .db 87
    .db 76
    .db 65
    .db 54
    .db 44
    .db 33
    .db 22
    .db 22
    .db 22
    .db 22
    .db 22
    .db 22
    .db 22
    .db 11
    .db 11
    .db 11
    .db 11
    .db 11
    .db 11
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
BANK_0_PTR_A: ; 1E:0200, 0x03C200
    LDA #$0F
    STA R_**:$0100 ; Set ??
    LDA #$03 ; Set config for R3.
    ORA ENGINE_MAPPER_CONFIG_STATUS_NO_BANK ; Set with other bits.
    STA MMC3_BANK_CFG ; Store R3 config.
    LDX #$09 ; Seed bank config, R1?
    LDY #$02 ; Loop delay.
DELAY_LOOP_Y_A: ; 1E:0210, 0x03C210
    DEY ; --
    BNE DELAY_LOOP_Y_A ; != 0, loop.
    BIT R_**:$0000 ; Test ??, for delay only?
    JMP EXIT_0x4_EXTRA ; Goto.
LIB_WRITE_LATCH: ; 1E:0218, 0x03C218
    STA MMC3_IRQ_LATCH ; A to latch.
    LDA #$02 ; Load R2.
    ORA ENGINE_MAPPER_CONFIG_STATUS_NO_BANK ; Set mapper config.
    TAX ; To X, R2.
EXIT_0x4_EXTRA: ; 1E:0220, 0x03C220
    LDY #$04 ; Seed delay.
DELAY_LOOP_Y_B: ; 1E:0222, 0x03C222
    DEY ; Y--
    BNE DELAY_LOOP_Y_B ; != 0, loop delay.
    RTS ; Leave.
LIB_RETURN_HANDLER_UNK: ; 1E:0226, 0x03C226
    LDA #$0F ; Val ??
    STA R_**:$0100 ; Set ??
    RTS ; Leave.
DICTIONARY_ALT_VALS: ; 1E:022C, 0x03C22C
    .db 00 ; 0x00
    .db 01
    .db 02
    .db 03
    .db 08
    .db 09
    .db 96
    .db 97
    .db 98 ; 0x08
    .db 99
    .db 9A
    .db 9B
    .db 9C
    .db 9D
    .db 9E
    .db 9F
    .db A0 ; 0x10
    .db A1
    .db A2
    .db A3
    .db A4
    .db 2A
    .db 2B
    .db 2C
    .db 2D
    .db 2E
    .db AA
    .db AB
    .db AC
    .db AD
    .db AE
    .db 93
    .db 04 ; 0x20
    .db 05
    .db 06
    .db 07
    .db 0E
    .db 0F
    .db D6
    .db D7
    .db D8
    .db D9
    .db DA
    .db DB
    .db DC
    .db DD
    .db DE
    .db DF
    .db E0 ; 0x30
    .db E1
    .db E2
    .db E3
    .db E4
    .db 6A
    .db 6B
    .db 6C
    .db 6D
    .db 6E
    .db EA
    .db EB
    .db EC
    .db ED
    .db EE
    .db D3
PACKETS_IDK: ; 1E:026C, 0x03C26C
    LDA #$D9 ; Set FPTR, ??:11D9
    LDX #$91
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]
    STX FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1
LATCH_NO_FLAG_RTN: ; 1E:0274, 0x03C274
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Do ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA #$19
    LDX #$B2
    LDY #$A2
    JSR ENGINE_SCRIPT_LAUNCH_R7_A_PTR_XY_WITH_RESTORE ; Script launch 19:02B2 TODO
    LDA #$00
    STA NMI_LATCH_FLAG ; Clear ??
    LDA #$FF
    STA SOUND_SAMPLE_FLAG_DONT_RESET_LEVEL ; Set ??
    LDA #$0F
    STA APU_STATUS ; Enable APU channels.
    JSR ENGINE_NMI_0x01_SET/WAIT ; Wait.
    LDX #$00 ; IRQ index.
SLOT_LT_0x1A?: ; 1E:0296, 0x03C296
    LDA #$25 ; Load PTR L.
    STA IRQ_SCRIPT_PTRS[6],X ; Store it.
    INX ; Index++
    LDA #$C2 ; Load PTR H.
    STA IRQ_SCRIPT_PTRS[6],X ; Store it.
    INX ; Index++
    CPX #$1A ; If _ #$1A
    BNE SLOT_LT_0x1A? ; !=, loop.
    LDA #$00
    STA IRQ_SCRIPT_PTRS[6],X ; Clear PTR L. For end signal?
    INX ; Index++
    STA IRQ_SCRIPT_PTRS[6],X ; Clear PTR H.
    LDA #$0F
    STA NMI_LATCH_FLAG ; Set latch.
LATCH_FLAG_RTN: ; 1E:02B3, 0x03C2B3
    JSR LIB_PRG_HELPER_R6_TO_0x00 ; Do.
SWITCH_NONZERO: ; 1E:02B6, 0x03C2B6
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDX #$00
    STX NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Create.
    STY NMI_PPU_CMD_PACKETS_INDEX ; Y to.
    INC GFX_COORD_VERTICAL_OFFSET ; ++
    LDY #$00 ; Stream reset.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load from file.
    PHA ; To stack.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; 2x
    PHA
    INY
    TYA ; Stream to A.
    JSR FORWARD_PACKET_CREATION_FP_BY_A ; Forward ptr.
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$00 ; If _ #$00
    BNE VAL_NONZERO ; != 0, goto.
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Do.
    JSR SCRIPT_UPDATES_AND_MORE_UNK ; Do.
    PLA ; Pull A.
    TAX ; To X.
    PLA ; Pull A.
    CMP IRQ_SCRIPT_PTRS[6],X ; If _ arr
    BCC VAL_LT_ARR ; << goto.
    STA IRQ_SCRIPT_PTRS[6],X ; >=, store.
VAL_LT_ARR: ; 1E:02E9, 0x03C2E9
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$00 ; If _ #$00
    BNE SWITCH_NONZERO ; != 0, goto.
    RTS ; Leave.
VAL_NONZERO: ; 1E:02F0, 0x03C2F0
    INC GFX_COORD_VERTICAL_OFFSET ; ++
    JSR SETUP_CREATION_DEC ; Do.
    JSR SCRIPT_UPDATES_AND_MORE_UNK ; Do.
    PLA ; Pull A.
    TAX ; To index.
    PLA ; Pull A.
    CMP IRQ_SCRIPT_PTRS[6],X ; If _ arr
    BCC VAL_LT ; <, goto.
    STA IRQ_SCRIPT_PTRS[6],X ; >=, store.
VAL_LT: ; 1E:0303, 0x03C303
    JMP LATCH_FLAG_RTN ; Do ??
SCRIPT_UPDATES_AND_MORE_UNK: ; 1E:0306, 0x03C306
    STY NMI_PPU_CMD_PACKETS_INDEX ; Store index.
    JSR LIB_UGH_MORE ; Do ??
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Clear for EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    LDA #$19
    LDX #$1D
    LDY #$A3
    JSR ENGINE_SCRIPT_LAUNCH_R7_A_PTR_XY_WITH_RESTORE ; Script launch 19:031D
    JMP WAIT_NMI/IRQ_CLEAR ; Do, abuse RTS.
LIB_PRG_HELPER_R6_TO_0x00: ; 1E:0322, 0x03C322
    LDA #$00 ; Bank.
    LDX #$06 ; R6.
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set it, abuse RTS.
    .db 20
    .db 01
    .db 17
    .db 21
    .db 4B
    .db 92
    .db 01
    .db 25
    .db 16
    .db 21
    .db 10
    .db 67
    .db 00
    .db 25
    .db 18
    .db FB
    .db 22
    .db FC
    .db 1C
    .db FD
    .db 00
    .db 20
    .db 01
    .db 15
    .db 21
    .db 4B
    .db 92
    .db 01
    .db 25
    .db 14
    .db 21
    .db 10
    .db 67
    .db 01
    .db 25
    .db 16
    .db 21
    .db 2E
    .db 67
    .db 00
    .db 25
    .db 18
    .db FB
    .db 22
    .db FC
    .db 1C
    .db FD
    .db 00
    .db 20
    .db 01
    .db 13
    .db 21
    .db 4B
    .db 92
    .db 01
    .db 25
    .db 12
    .db 21
    .db 10
    .db 67
    .db 01
    .db 25
    .db 14
    .db 21
    .db 2E
    .db 67
    .db 01
    .db 25
    .db 16
    .db 21
    .db 4C
    .db 67
    .db 00
    .db 25
    .db 18
    .db FB
    .db 22
    .db FC
    .db 1C
    .db FD
    .db 00
ROM_DATA_UNK: ; 1E:037A, 0x03C37A
    .db 24 ; 0x0, Data[3]
    .db A0
    .db 23
    .db 38 ; Addr mod L.
    .db 00 ; H.
    .db 00 ; 0x1
    .db 07
    .db 23
    .db 10
    .db 00
    .db 01 ; 0x2
    .db 03
    .db 23
    .db 14
    .db 00
    .db 02 ; 0x3
    .db 04
    .db 23
    .db 16
    .db 00
    .db 02 ; 0x4
    .db 04
    .db 23
    .db 11
    .db 00
    .db 03 ; 0x5
    .db 08
    .db A0
    .db 25
    .db 00
DATA_TABLE_SMOL: ; 1E:0398, 0x03C398
    .db 01
    .db 04
    .db A0
    .db A0
    .db 21
    .db A0
    .db A1
    .db 00
PTR_SEEDED_UNK_K: ; 1E:03A0, 0x03C3A0
    LDA #$6A
    LDX #$92 ; Ptr seed 13:126A
STORE_PACKET_PTR_AND_LATCH_UNK: ; 1E:03A4, 0x03C3A4
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Store PTR.
    STX FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1
    LDA NMI_LATCH_FLAG ; Load.
    BEQ EXIT_FLAG_CLEAR ; == 0, goto.
    JMP LATCH_FLAG_RTN ; Do ??
EXIT_FLAG_CLEAR: ; 1E:03AF, 0x03C3AF
    JMP LATCH_NO_FLAG_RTN ; Goto.
PTR_SEEDED_UNK_A: ; 1E:03B2, 0x03C3B2
    LDA #$9B
    LDX #$92
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_B: ; 1E:03B9, 0x03C3B9
    LDA #$CF
    LDX #$92
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_C: ; 1E:03C0, 0x03C3C0
    LDA #$00
    LDX #$93
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEDED_UNK_D: ; 1E:03C7, 0x03C3C7
    LDA #$17
    LDX #$93
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_E: ; 1E:03CE, 0x03C3CE
    LDA #$5F
    LDX #$93
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_F_WRAM: ; 1E:03D5, 0x03C3D5
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK
PTR_SEEDED_UNK_G_WRAM: ; 1E:03D8, 0x03C3D8
    LDA #$48
    LDX #$92
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_H: ; 1E:03DF, 0x03C3DF
    LDA #$6A ; Seed 13:136A
    LDX #$93
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_I: ; 1E:03E6, 0x03C3E6
    LDA #$8D ; Seed ??
    LDX #$93
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
PTR_SEEDED_UNK_J: ; 1E:03ED, 0x03C3ED
    LDA #$1E ; Seed ??
    LDX #$95
    JMP STORE_PACKET_PTR_AND_LATCH_UNK
LIB_OBJECTS_AND_SETTLE_AND_FLAGS_UNK: ; 1E:03F4, 0x03C3F4
    PHP ; Save status.
    JSR ENGINE_SETTLE_UPDATES_TODO ; Settle.
    JSR ENGINE_0x300_OBJECTS_UNK? ; Do ??
    LDA #$01
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set ??
    LDA #$00
    STA SOUND_SAMPLE_FLAG_DONT_RESET_LEVEL ; Clear ??
    PLP ; Pull status.
    RTS ; Leave.
TODO_ROUTINE_NO_MASK_ENTRY: ; 1E:0406, 0x03C406
    LDA #$FF ; Mask, none.
TODO_ROUTINE_MASK_A: ; 1E:0408, 0x03C408
    STA BCD/MODULO/DIGITS_USE_A ; Store passed.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; WRAM writeable.
    LDA #$00 ; Seed clear ??
LOOP_STACK_POSITIVE: ; 1E:040F, 0x03C40F
    PHA ; Save it.
    TAX ; Val to index.
    LDA STREAM_INDEXES_ARR_UNK[24],X ; Load at index.
    BEQ INDEXED_LOAD_EQ_0x00 ; == 0, goto.
    LDA STREAM_PTRS_ARR_UNK[48],X ; Move from arr to fptr for packeting.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]
    LDA STREAM_PTRS_ARR_UNK+1,X
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1
    LDY #$01 ; Stream index.
    LDA STREAM_INDEXES_ARR_UNK+1,X ; Load from arr.
    AND BCD/MODULO/DIGITS_USE_A ; And with ??
    STA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Store to file stream 0x1
    LDY #$14 ; Restream higher.
STREAM_LT_0x18: ; 1E:042B, 0x03C42B
    LDA STREAM_INDEXES_ARR_UNK+3,X ; Load from.
    STA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Store to file stream 0x14
    INX ; Index++
    INY ; Stream++
    CPY #$18 ; If stream _ #$18
    BCC STREAM_LT_0x18 ; < loop.
INDEXED_LOAD_EQ_0x00: ; 1E:0436, 0x03C436
    PLA ; Pull A.
    CLC ; Prep add.
    ADC #$20 ; += 0x20
    BPL LOOP_STACK_POSITIVE ; Positive, goto.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable WRAM. TODO: Useless? Trap? Mistake?
LIB_PACKET_R6_0x00_TODO: ; 1E:043F, 0x03C43F
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Enable WRAM.
    LDA MAPPER_BANK_VALS+6 ; Load R6.
    PHA ; Save to stack.
    JSR LIB_PRG_HELPER_R6_TO_0x00 ; Do.
    LDA #$48
    LDX #$92 ; Set 00:1248
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Store.
    STX FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Do.
    BNE RET_NONZERO ; != 0, goto.
VAL_NONZERO: ; 1E:0455, 0x03C455
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_DEC? ; Do again.
RET_NONZERO: ; 1E:0458, 0x03C458
    LDA #$02
    JSR FORWARD_PACKET_CREATION_FP_BY_A ; += 0x2
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$00 ; If _ #$00
    BNE VAL_NONZERO ; !=, loop.
    INC GFX_COORD_VERTICAL_OFFSET ; ++
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Do update.
    PLA ; Pull R6 saved.
    LDX #$06 ; R6 set.
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set it again, abuse RTS.
LIB_UGH_MORE: ; 1E:046E, 0x03C46E
    LDA DATA_APPEND_COUNT? ; Load.
    LSR A ; A >> 1
    ADC #$00 ; Carry added to val.
    TAX ; To X index, count.
    LDA GFX_COORD_VERTICAL_OFFSET ; Load.
    AND #$1E ; Keep 0001.1110
    ASL A ; << 3, *8.
    ASL A
    ASL A
    STA PACKET_CONSUMED/INDEX? ; Store to.
    LDA GFX_COORD_HORIZONTAL_OFFSET ; Load.
    ADC #$01 ; Add, no carry here because of AND and shifts.
    LSR A ; >> 1, /2.
    ORA PACKET_CONSUMED/INDEX? ; Or with.
    STA PACKET_CONSUMED/INDEX? ; Store result.
    TAY ; To Y index.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Do ??
    LDA #$FF ; Set clear ??
ARRAY_SET_LARGE: ; 1E:048C, 0x03C48C
    STA WRAM_PAGE_LARGE_UNK[384],Y ; Store to arr.
    INY ; Index++
    DEX ; X--
    BNE ARRAY_SET_LARGE ; != 0, loop.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable.
    LDX NMI_PPU_CMD_PACKETS_BUF+2 ; Load from buf.
    LDY NMI_PPU_CMD_PACKETS_BUF+3
    TYA ; Y to A.
    CLC ; Prep add.
    AND #$03 ; Keep 0000.0011
    ADC #$03 ; += 0x3
    ADC DATA_APPEND_COUNT? ; Add with.
    LSR A ; >> 2, /4.
    LSR A
    STA ENGINE_PTR_PACKET_MANAGER[2] ; Store to. Count todo.
    TYA ; Y to A.
    AND #$80 ; Keep 1000.0000
    STA PACKET_PPU_ADDR_HL+1 ; Store to ADDR L.
    TXA ; X to A.
    LSR A ; >> 1, /2.
    ROR PACKET_PPU_ADDR_HL+1 ; Rotate L.
    LSR A ; 2x
    ROR PACKET_PPU_ADDR_HL+1
    TYA ; Y to A.
    AND #$1C ; Keep 0001.1100
    ORA PACKET_PPU_ADDR_HL+1 ; Combine with.
    LSR A ; >> 2, /4.
    LSR A
    ORA #$C0 ; Set 1100.0000
    STA PACKET_PPU_ADDR_HL+1 ; Store to addr L.
    ORA #$F8 ; Set 1111.1000
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Store to inverted count.
    TXA ; X to A.
    ORA #$03 ; |= 0x03
    STA PACKET_PPU_ADDR_HL[2] ; Store to packet H.
    TYA ; Y to A.
    AND #$42 ; Keep 0100.0010
    LSR A ; >> 2, /4.
    LSR A
    ADC #$00 ; Carry to add'l.
    EOR #$FF ; Invert.
    ADC #$01 ; Compliment.
    CLC ; Prep add.
    ADC PACKET_CONSUMED/INDEX? ; Add with.
    TAY ; To Y index.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDA #$07 ; Move, type?
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    INX ; Index++
    LDA ENGINE_PTR_PACKET_MANAGER[2] ; Move ??, count?
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    INX ; Index++
LOOP_PACKETY: ; 1E:04E5, 0x03C4E5
    LDA PACKET_PPU_ADDR_HL[2] ; Move addr H.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    INX ; Buf++
    LDA PACKET_PPU_ADDR_HL+1 ; Move addr L.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    INX ; Buf++
    LDA WRAM_PAGE_LARGE_UNK[384],Y ; Load from arr.
    AND #$03 ; Keep lower.
    STA PACKET_CONSUMED/INDEX? ; Store.
    INY ; Array++
    LDA WRAM_PAGE_LARGE_UNK[384],Y ; Load arr.
    AND #$0C ; Keep 0000.1100
    ORA PACKET_CONSUMED/INDEX? ; Or with.
    STA PACKET_CONSUMED/INDEX? ; Store result.
    TYA ; Array += 0xF
    CLC ; Prep add.
    ADC #$0F ; Add it.
    TAY ; To Y.
    LDA WRAM_PAGE_LARGE_UNK[384],Y ; Load array.
    AND #$30 ; Keep 0011.0000
    ORA PACKET_CONSUMED/INDEX? ; Combine with.
    STA PACKET_CONSUMED/INDEX? ; Store result.
    INY ; Array++
    LDA WRAM_PAGE_LARGE_UNK[384],Y ; Load array.
    AND #$C0 ; Keep 1100.0000
    ORA PACKET_CONSUMED/INDEX? ; Combine with.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to update buf.
    INX ; Buf++
    TYA ; Y -= 0xF
    SEC ; Prep sub.
    SBC #$0F ; Sub value.
    TAY ; Back to large buf index.
    DEC ENGINE_PTR_PACKET_MANAGER[2] ; Count todo--
    BNE INC_PACKETY ; !=, goto.
    STX NMI_PPU_CMD_PACKETS_INDEX ; Store index.
    RTS ; Leave.
INC_PACKETY: ; 1E:0528, 0x03C528
    INC DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; ++ invert for mod trigger.
    BEQ PPU_PACKET_ADDR_MOD_TO_OTHER_NAMETABLE_X ; == 0, goto.
    INC PACKET_PPU_ADDR_HL+1 ; ++
    JMP LOOP_PACKETY ; Run.
PPU_PACKET_ADDR_MOD_TO_OTHER_NAMETABLE_X: ; 1E:0531, 0x03C531
    LDA #$04
    EOR PACKET_PPU_ADDR_HL[2] ; Mod 0x2000/0x2400 switch.
    STA PACKET_PPU_ADDR_HL[2]
    LDA #$F8
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Set count?
    AND PACKET_PPU_ADDR_HL+1 ; And with addr L.
    STA PACKET_PPU_ADDR_HL+1 ; Store result.
    JMP LOOP_PACKETY ; Reenter.
ENGINE_WRAM_ARR_MOD_LOOPS_UNK: ; 1E:0542, 0x03C542
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM writes.
    LDX #$10 ; Seed ??
    LDY #$00 ; Seed Y index.
    STY COUNT_LOOPS?_UNK ; Set WRAM ??
LOOP_LARGEST: ; 1E:054C, 0x03C54C
    JSR STREAM_PAGE_Y_INDEXED_CC_0x01-0x05 ; Load val.
    BCS DATA_CS ; Not 0x01-0x05, goto.
    INC COUNT_LOOPS?_UNK ; ++
    JSR CREATE_PTR_FOR_SAVE/ROM_PAGE_UNK ; Create ptr.
    TYA ; Y to A.
    PHA ; Save it to the stack.
    LDY #$00 ; Seed index start.
SLOT_INDEX_NE_0x14: ; 1E:055B, 0x03C55B
    JSR DATA_MOVE_AND_MOD_WITH_PTR_UNK ; Move and mod.
    CPY #$14 ; If _ #$14, first half of table done.
    BNE SLOT_INDEX_NE_0x14 ; !=, goto.
    TYA ; Index into table save.
    PHA
    LDY #$01 ; Seed index.
    LDA [BCD/MODULO/DIGITS_USE_A],Y ; Load from index.
    LDY #$0E ; Seed alt table index.
Y_INDEX_POSITIVE: ; 1E:056A, 0x03C56A
    ASL A ; << 1, *2.
    BCC DATA_CARRY_CLEAR_Y_SUB_LOOP ; CC, goto.
    PLA ; Pull table index saved.
    TYA ; Table index from Y seed.
    PHA
    LDY #$00 ; Reset index.
SMALL_TABLE_LOOP: ; 1E:0572, 0x03C572
    LDA DATA_TABLE_SMOL,Y ; Load index.
    STA R_**:$6700,X ; Store to arr.
    INX ; Indexes++
    INY
    CPY #$05 ; If _ #$05
    BNE SMALL_TABLE_LOOP ; !=, goto.
    PLA ; Pull table index.
    TAY ; Back to Y.
    LDA ROM_DATA_UNK,Y ; Move ??
    STA R_**:$6700,X
    INX ; Arr++
    LDA ROM_DATA_UNK_PAIR,Y ; Move pair.
    STA R_**:$6700,X
    INX ; Arr++
    LDY #$1B ; Seed ??
    BNE LOOP_MOVE_TABLE_TO_0x1E_UNK
DATA_CARRY_CLEAR_Y_SUB_LOOP: ; 1E:0592, 0x03C592
    DEY ; Index -= 2
    DEY
    BPL Y_INDEX_POSITIVE ; Positive, goto.
    PLA ; Pull index into table.
    TAY ; To Y.
    JSR DATA_MOVE_AND_MOD_WITH_PTR_UNK ; Do ??
LOOP_MOVE_TABLE_TO_0x1E_UNK: ; 1E:059B, 0x03C59B
    LDA ROM_DATA_UNK,Y ; Move from table.
    STA R_**:$6700,X
    INX ; Indexes++
    INY
    CPY #$1E ; If _ #$1E
    BNE LOOP_MOVE_TABLE_TO_0x1E_UNK ; != 0, goto.
    PLA ; Pull count ??
    TAY ; To Y.
    LDA COUNT_LOOPS?_UNK ; Load ??
    CMP #$03 ; If _ #$03
    BCS VAL_GTE_0x3 ; >=, goto.
DATA_CS: ; 1E:05B0, 0x03C5B0
    INY ; Count++
    CPY #$04 ; If _ #$04
    BCC LOOP_LARGEST ; <, goto.
VAL_GTE_0x3: ; 1E:05B5, 0x03C5B5
    LDA #$00
    STA R_**:$6704 ; Clear ??
    STA R_**:$6705
    STA R_**:$6706
    SEC ; Prep sub.
    LDA #$03 ; Sub val.
    SBC COUNT_LOOPS?_UNK ; 3 - var
    TAX ; To X.
    LDY #$00 ; Reset index.
VAL_LT_0x4: ; 1E:05C9, 0x03C5C9
    JSR STREAM_PAGE_Y_INDEXED_CC_0x01-0x05 ; Do.
    BCS DATA_RET_OTHER
    STA R_**:$6704,X ; Store to arr.
    INX ; Index++
    CPX #$03 ; If _ #$03
    BCS DATA_GTE_0x3 ; >=, goto.
DATA_RET_OTHER: ; 1E:05D6, 0x03C5D6
    INY ; Index++
    CPY #$04 ; If _ #$04
    BCC VAL_LT_0x4 ; <, goto.
DATA_GTE_0x3: ; 1E:05DB, 0x03C5DB
    LDA COUNT_LOOPS?_UNK ; Load ??
    ASL A ; << 1, *2.
    TAX ; To X index.
    LDA #$04
    STA R_**:$6700 ; Set ??
    STA R_**:$670A ; Set ??
    CPX #$04 ; If _ #$04
    BCS X_GTE_0x4 ; >=, goto.
    LDA #$00 ; Seed 0x00
X_GTE_0x4: ; 1E:05EE, 0x03C5EE
    STA R_**:$670D ; Set 0x4/0x0
    LDA ROM_LIB_UNK,X
    STA R_**:$6701
    LDA ROM_LIB_UNK_PAIR,X
    STA R_**:$6702
    LDA R_**:$6713 ; Move ??
    STA R_**:$670B
    LDA R_**:$6714 ; Move ??
    STA R_**:$670C
    LDA #$9D ; Move ??
    STA R_**:$670E
    LDA #$C3 ; Move ??
    STA R_**:$670F
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Exit, no more WRAM writes.
ROM_LIB_UNK: ; 1E:0616, 0x03C616
    .db 3D ; These seems to be all ptrs.
ROM_LIB_UNK_PAIR: ; 1E:0617, 0x03C617
    .db C3
    .db 29
    .db C3
    .db 3E
    .db C3
    .db 59
    .db C3
ROM_DATA_UNK: ; 1E:061E, 0x03C61E
    .db 29
ROM_DATA_UNK_PAIR: ; 1E:061F, 0x03C61F
    .db 86
    .db 22
    .db 86
    .db 1B
    .db 86
    .db 14
    .db 86
    .db 0D
    .db 86
    .db 06
    .db 86
    .db FF
    .db 85
    .db F8
    .db 85
STREAM_PAGE_Y_INDEXED_CC_0x01-0x05: ; 1E:062E, 0x03C62E
    .db 38 ; Seed ret for 0x00.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,Y ; Load data indexed.
    BEQ RTS ; == 0, return CS.
    CMP #$06 ; If < 6, ret CC. CS otherwise.
RTS: ; 1E:0636, 0x03C636
    RTS ; Leave.
DATA_MOVE_AND_MOD_WITH_PTR_UNK: ; 1E:0637, 0x03C637
    LDA ROM_DATA_UNK,Y ; Move from Y to X indexes.
    STA R_**:$6700,X
    INX ; Indexes++
    INY
    LDA ROM_DATA_UNK,Y ; 2x
    STA R_**:$6700,X
    INX ; ++
    INY
    LDA ROM_DATA_UNK,Y ; 3x
    STA R_**:$6700,X
    INX ; ++
    INY
    CLC ; Prep add.
    LDA ROM_DATA_UNK,Y ; Load from arr.
    ADC BCD/MODULO/DIGITS_USE_A ; Add with ptr L.
    STA R_**:$6700,X ; Store to arr.
    INX ; ++
    INY
    LDA ROM_DATA_UNK,Y ; Load from arr.
    ADC BCD/MODULO/DIGITS_USE_B ; Add with ptr H.
    STA R_**:$6700,X ; Store to arr.
    INX ; ++
    INY
    RTS
CREATE_PTR_FOR_SAVE/ROM_PAGE_UNK: ; 1E:0665, 0x03C665
    STA BCD/MODULO/DIGITS_USE_B ; Store arg. AAAA.AABB, PTRH = 0x74 + A, PTRL = B << 6
    LDA #$00 ; Clear for shifts low.
    LSR BCD/MODULO/DIGITS_USE_B ; Shift bit off.
    ROR A ; Into A.
    LSR BCD/MODULO/DIGITS_USE_B ; 2x
    ROR A
    ADC #$00 ; Carry to bit 0, fancy. But always 0x00 here.
    STA BCD/MODULO/DIGITS_USE_A ; Store to, addr L.
    LDA BCD/MODULO/DIGITS_USE_B ; Load passed val 00AA.AAAA
    ADC #$74 ; Add with, PTR offset base. Range of 0x74-B3, slot size 0x40.
    STA BCD/MODULO/DIGITS_USE_B ; Store addr H.
    RTS
UPDATE_BUF_FROM_FILE_HELPER_UNK: ; 1E:067A, 0x03C67A
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Create file.
    BNE RETURN_NONZERO ; != 0, goto. TODO: Taken chance.
VAL_RET_NONZERO: ; 1E:067F, 0x03C67F
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_DEC? ; Do.
RETURN_NONZERO: ; 1E:0682, 0x03C682
    CMP #$00 ; If _ #$00
    BNE VAL_RET_NONZERO ; != 0, goto.
    INC GFX_COORD_VERTICAL_OFFSET ; ++
    JMP ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Run, abuse RTS.
ENGINE_A_TO_UPDATE_PACKET: ; 1E:068B, 0x03C68B
    PHA ; Save A.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR PACKET_CALC_COORDS_TO_VADDR_HELPER ; Calc screen pos.
    LDA #$05
    STA NMI_PPU_CMD_PACKETS_BUF[69] ; Set type, data upload +1 mode.
    LDA #$01 ; 1 byte.
    STA NMI_PPU_CMD_PACKETS_BUF+1
    LDA PACKET_PPU_ADDR_HL[2] ; Addr.
    STA NMI_PPU_CMD_PACKETS_BUF+2
    LDA PACKET_PPU_ADDR_HL+1
    STA NMI_PPU_CMD_PACKETS_BUF+3
    PLA ; Value from stack as tile.
    STA NMI_PPU_CMD_PACKETS_BUF+4 ; Store to buf as tile?
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+5 ; End of file.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    RTS ; Leave.
ENGINE_PACKET_FINALIZATION_HELPER: ; 1E:06B6, 0x03C6B6
    LDA R_**:$0070 ; Load ??
    CLC ; Prep sub with extra.
    SBC DATA_APPEND_COUNT? ; Sub with.
    BCC PACKET_HAS_NO_SIZE ; Underflow, goto. Nice off by one shenanigans.
    TAY ; A to Y, loop count.
POST_APPEND_0xA0_TO_BUF: ; 1E:06BE, 0x03C6BE
    LDA #$A0 ; Seed data.
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append to buf.
    DEY ; Count--
    BPL POST_APPEND_0xA0_TO_BUF ; Positive, loop more.
    LDY NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Load size of packet finally.
    BEQ PACKET_HAS_NO_SIZE ; == 0, goto.
    TXA ; Use the X index for the new index, put it in Y. TODO: Store+RTS Directly. +1 Byte, faster.
    TAY
PACKET_HAS_NO_SIZE: ; 1E:06CF, 0x03C6CF
    STY NMI_PPU_CMD_PACKETS_INDEX ; Store Y index.
    RTS ; Leave.
ENGINE_CREATE_UPDATE_BUF_INIT_INC?: ; 1E:06D2, 0x03C6D2
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDX #$00
    STX NMI_PPU_CMD_PACKETS_INDEX ; Reset update index.
    BEQ ALT_ENTRY ; Always taken here.
ENGINE_CREATE_UPDATE_BUF_INIT_DEC?: ; 1E:06DB, 0x03C6DB
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDX #$00
    STX NMI_PPU_CMD_PACKETS_INDEX ; Reset too.
    JSR SETUP_CREATION_DEC ; TODO: What do.
    JSR ENGINE_PACKET_FINALIZATION_HELPER ; Finalize this one.
ALT_ENTRY: ; 1E:06E8, 0x03C6E8
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Create packet with fptr.
    JSR ENGINE_PACKET_FINALIZATION_HELPER ; Finalize the packet, appending maybe.
    LDA #$00 ; Clear val.
    STA NMI_PPU_CMD_PACKETS_BUF[69],Y ; EOF the packet.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag ??
ADDS_IDFK: ; 1E:06F9, 0x03C6F9
    JSR ENGINE_UNK_CARRY_ADDS_??? ; Add because world?
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$01 ; If _ #$01
    BNE RTS ; !=, goto.
    INC GFX_COORD_VERTICAL_OFFSET ; += 2
    INC GFX_COORD_VERTICAL_OFFSET ; To next screen lines?
RTS: ; 1E:0706, 0x03C706
    RTS ; Leave.
RTN_SETTLE_UPDATE_TODO: ; 1E:0707, 0x03C707
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA #$33
    STA NMI_PPU_CMD_PACKETS_INDEX ; Set index.
    PHA ; Save.
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Create packet.
    JSR ENGINE_PACKET_FINALIZATION_HELPER ; Finalize.
    STY DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Index to.
    PLA ; Pull A.
    TAX ; To X.
    LDA #$05
    STA NMI_PPU_CMD_PACKETS_BUF[69] ; Type.
    LDA #$01
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Count.
ROUTINE_LOOP: ; 1E:0723, 0x03C723
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],Y ; Clear indexed.
    CPX DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; If X _ val
    BCS ADDS_IDFK ; >=, CS, goto. EXIT<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    LDA #$08
    STA NMI_PPU_CMD_PACKETS_BUF[69],Y ; Type, bulk upload.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,X ; Load X.
    STA DATA_APPEND_COUNT? ; Store to.
    STA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Store to.
    LDA #$A0 ; Clear tile.
    STA NMI_PPU_CMD_PACKETS_BUF+4,Y ; Set.
    CLC ; Prep add.
    LDA NMI_PPU_CMD_PACKETS_BUF+3,X ; Load X.
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Store to.
    ADC #$20 ; To next row.
    STA NMI_PPU_CMD_PACKETS_BUF+3,Y ; Store result.
    LDA NMI_PPU_CMD_PACKETS_BUF+2,X ; Load X.
    STA NMI_PPU_CMD_PACKETS_BUF+2 ; Carry add.
    ADC #$00
    STA NMI_PPU_CMD_PACKETS_BUF+2,Y
    TXA ; X to A.
    CLC ; Prep add.
    ADC #$04 ; += 0x4
    TAX ; Back to X.
    TYA ; Y to A.
    CLC ; Prep add.
    ADC #$05 ; += 0x5
    TAY ; To Y.
LOOP_COUNT: ; 1E:075F, 0x03C75F
    LDA NMI_PPU_CMD_PACKETS_BUF[69],X ; Load from X.
    STA NMI_PPU_CMD_PACKETS_BUF+4 ; Store to. TODO: Byte?
    CMP #$A0 ; If _ #$A0
    BEQ PACKET_END ; ==, goto.
    LDA **:$07EF ; Load.
    BMI PACKET_END ; Negative, goto.
    EOR #$01 ; Invert.
    STA **:$07EF ; Store to.
    LSR A ; >> 1, /2.
    BCC PACKET_END ; CC, goto.
    LDA #$0E
    STA SOUND_FX_REQUEST_B? ; Set ??
PACKET_END: ; 1E:077B, 0x03C77B
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+5
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    BIT **:$07EF ; Test.
    BVC BIT_0x40_CLEAR ; 0x40 set.
    TXA ; X to A.
    PHA ; Save X.
    LDA NMI_PPU_CMD_PACKETS_BUF+4 ; Load.
    LDX #$28 ; Delay.
    CMP #$AE ; If _ #$AE
    BEQ DELAY_X_COUNT ; ==, goto.
    CMP #$AC ; If _ #$AC
    BEQ DELAY_X_COUNT ; ==, goto.
    LDX #$03 ; Alt delay.
DELAY_X_COUNT: ; 1E:079F, 0x03C79F
    JSR ENGINE_DELAY_X_FRAMES ; Delay count.
    PLA ; Pull A.
    TAX ; Back to X.
BIT_0x40_CLEAR: ; 1E:07A4, 0x03C7A4
    INC NMI_PPU_CMD_PACKETS_BUF+3 ; ++
    INX ; X++
    DEC DATA_APPEND_COUNT? ; --
    BNE LOOP_COUNT ; != 0, GOTO.
    JMP ROUTINE_LOOP ; Loop.
SUB_MOD_PACKETS_TODO_UNK: ; 1E:07AF, 0x03C7AF
    CMP #$01 ; If _ #$01
    BNE RTS ; !=, leave.
    PHA ; Save it.
    LDX #$A4 ; Seed index.
INDEX_MOVE: ; 1E:07B6, 0x03C7B6
    LDA NMI_PPU_CMD_PACKETS_BUF+50,X ; Load buf.
    STA R_**:$045B,X ; Store to.
    DEX ; Index--
    BNE INDEX_MOVE ; != 0, move more.
    PLA ; Restore.
RTS: ; 1E:07C0, 0x03C7C0
    RTS ; Leave.
SUB_ADDRESSES_UNK_ENTRY_ADD: ; 1E:07C1, 0x03C7C1
    LDA #$33 ; Seed val ??
LOOP_ADD_MORE: ; 1E:07C3, 0x03C7C3
    CLC ; Prep add.
    ADC #$29 ; Add with.
    DEX ; X--
    BNE LOOP_ADD_MORE ; != 0, loop more.
    STX PACKET_PRE_SEED_0xA0_COUNT ; Clear.
    TAX ; Value to X.
    PHA ; Also stack it.
    JSR SUB_PACKETY_LOOP ; Do sub once.
    STA PACKET_PRE_SEED_0xA0_COUNT ; Store val.
    PLA ; Restore to X again.
    TAX
SUB_PACKETY_LOOP: ; 1E:07D4, 0x03C7D4
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    STX NMI_PPU_CMD_PACKETS_INDEX ; X to.
ADD_NO_OVERFLOW: ; 1E:07D9, 0x03C7D9
    LDA NMI_PPU_CMD_PACKETS_BUF[69],X ; Load buf.
    BEQ BUF_EQ_0x00 ; == 0, goto.
    EOR #$05 ; Invert ??
    BNE INVERT_NONZERO ; != 0, goto.
    ORA PACKET_PRE_SEED_0xA0_COUNT ; Set less count by OR.
    BNE SKIP_SUB ; != 0, goto. TODO: Always taken because to zero from negative?
    JSR PACKET_ADDRESS_MOD_HELPER ; Mod if zero.
SKIP_SUB: ; 1E:07E9, 0x03C7E9
    TXA ; X to A.
    CLC ; Prep add.
    ADC #$04 ; Add with.
    ADC NMI_PPU_CMD_PACKETS_BUF+1,X ; Add with addr l/h
    TAX ; Value to X.
    BCC ADD_NO_OVERFLOW ; No overflow, goto.
INVERT_NONZERO: ; 1E:07F3, 0x03C7F3
    JSR PACKET_ADDRESS_MOD_HELPER ; Do mod.
    TXA ; Index to A.
    CLC ; Prep add.
    ADC #$05 ; Add with.
    TAX ; Back to X.
    BCC ADD_NO_OVERFLOW ; No overflow, goto.
BUF_EQ_0x00: ; 1E:07FD, 0x03C7FD
    STA PACKET_PRE_SEED_0xA0_COUNT ; Store val.
    SEC ; Prep sub.
    LDA NMI_PPU_CMD_PACKETS_INDEX ; Load ??
    SBC #$29 ; -= 0x29
    TAX ; To X.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    CPX #$5C ; If _ #$5C
    BCS SUB_PACKETY_LOOP ; >=, goto. Loop.
    RTS ; Leave.
PACKET_ADDRESS_MOD_HELPER: ; 1E:080E, 0x03C80E
    SEC ; Prep sub.
    LDA NMI_PPU_CMD_PACKETS_BUF+3,X ; Load addr H.
    SBC #$20 ; -= 0x20. Line--
    STA NMI_PPU_CMD_PACKETS_BUF+3,X ; Store back.
    LDA NMI_PPU_CMD_PACKETS_BUF+2,X ; Load addr L.
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Store as count.
    SBC #$00 ; Carry sub.
    STA NMI_PPU_CMD_PACKETS_BUF+2,X ; Store to, addr L.
    EOR DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Invert bits.
    AND #$04 ; Keep 0000.01000
    BEQ RTS ; == 0, leave.
    SEC ; Prep sub.
    LDA NMI_PPU_CMD_PACKETS_BUF+3,X ; Load addr H.
    SBC #$40 ; -= 0x40
    STA NMI_PPU_CMD_PACKETS_BUF+3,X ; Store back.
    LDA NMI_PPU_CMD_PACKETS_BUF+2,X ; Load addr L.
    SBC #$04 ; -= 0x4, to other screen.
    AND #$0F ; Keep lower.
    ORA #$20 ; Set addr.
    STA NMI_PPU_CMD_PACKETS_BUF+2,X ; Store addr L.
RTS: ; 1E:083C, 0x03C83C
    RTS ; Leave.
ENGINE_PACKET_CREATE_FROM_FILE: ; 1E:083D, 0x03C83D
    JSR PACKET_CALC_COORDS_TO_VADDR_HELPER
    LDA ENGINE_PACKINATOR_ARG_SEED_0xA0_PRE_COUNT ; Move count?
    STA PACKET_PRE_SEED_0xA0_COUNT ; Copy to us.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load index for packet.
    LDY #$00
    STY DATA_APPEND_COUNT? ; No appends.
    TYA ; Clear A.
    PHA ; Argument 0x00
    JSR PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN ; Header.
PACKET_CREATION_LOO_SMOL: ; 1E:084F, 0x03C84F
    DEC PACKET_PRE_SEED_0xA0_COUNT ; Preseed count.
    BPL SEED_0xA0_TO_PACKET ; Positive, seed instead.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load from stream.
    JSR ENGINE_DATA_DICT_MOD_A_UNK ; Do mod on data.
    BCS DATA_TO_PACKET ; Ret CS, use data as-is. Otherwise, A is a function re-launch.
    LDY #$4F
    STY ENGINE_PTR_PACKET_MANAGER[2] ; Seed 14:084F above as return?
    LDY #$C8
    STY ENGINE_PTR_PACKET_MANAGER+1
    JMP LAUNCH_PACKET_UPDATE_SCRIPTS ; Launch rtn from var pulled.
SEED_0xA0_TO_PACKET: ; 1E:0865, 0x03C865
    LDA #$A0 ; Seed 0xA0 instead.
DATA_TO_PACKET: ; 1E:0867, 0x03C867
    JSR APPEND_DATA_TO_UPDATE_BUF ; Store/do ??
    JMP PACKET_CREATION_LOO_SMOL ; More data.
SETUP_CREATION_DEC: ; 1E:086D, 0x03C86D
    DEC GFX_COORD_VERTICAL_OFFSET ; --
    JSR PACKET_CALC_COORDS_TO_VADDR_HELPER ; Calc pos.
    LDA ENGINE_PACKINATOR_ARG_SEED_0xA0_PRE_COUNT ; Move to local.
    STA PACKET_PRE_SEED_0xA0_COUNT ; Set count to seed.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDY #$00
    STY DATA_APPEND_COUNT? ; Clear count.
    TYA ; Clear A.
    PHA ; Save 0x00 to stack.
    JSR PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN ; Header it.
CREATION_LOOP_DOWN?: ; 1E:0881, 0x03C881
    DEC PACKET_PRE_SEED_0xA0_COUNT ; --
    BPL SEED_PACKET_0xA0 ; Positive, goto.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Otherwise load from file.
    JSR ENGINE_DATA_DICT_MOD_B_UNK ; Do mod.
    BCS DATA_USE ; Ret CS, append to buffer. Not command.
    ORA #$80 ; Set down/sub/dec flag?
    LDY #$81
    STY ENGINE_PTR_PACKET_MANAGER[2] ; Set 1E:0881 as handler.
    LDY #$C8
    STY ENGINE_PTR_PACKET_MANAGER+1
    JMP LAUNCH_PACKET_UPDATE_SCRIPTS ; Launch script with data instead right now.
SEED_PACKET_0xA0: ; 1E:0899, 0x03C899
    LDA #$A0 ; Append 0xA0.
DATA_USE: ; 1E:089B, 0x03C89B
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append A to buf.
    JMP CREATION_LOOP_DOWN? ; Loop.
LAUNCH_PACKET_UPDATE_SCRIPTS: ; 1E:08A1, 0x03C8A1
    STA ENGINE_SCRIPT_SWITCH_VAL? ; Val to.
    ASL A ; << 1, *2. Word index.
    TAY ; To index.
    LDA TABLE_PTR_L,Y ; Addr to stack.
    PHA
    LDA TABLE_PTR_H,Y
    PHA
    RTS ; RTS Into routine.
TABLE_PTR_H: ; 1E:08AE, 0x03C8AE
    LOW(1E:08E1) ; PPU update switch.
TABLE_PTR_L: ; 1E:08AF, 0x03C8AF
    HIGH(1E:08E1)
    LOW(1E:08E1)
    HIGH(1E:08E1)
    LOW(1E:08E1)
    HIGH(1E:08E1)
    LOW(1E:08E1)
    HIGH(1E:08E1)
    LOW(1E:0908)
    HIGH(1E:0908)
    LOW(1E:08D3)
    HIGH(1E:08D3)
    LOW(1E:092E)
    HIGH(1E:092E)
    LOW(1E:094F)
    HIGH(1E:094F)
    LOW(1E:08C1)
    HIGH(1E:08C1)
    LOW(1E:09D1)
    HIGH(1E:09D1)
SCRIPT_RTN_F: ; 1E:08C2, 0x03C8C2
    LDY PACKET_CONSUMED/INDEX? ; Stream reload.
SCRIPT_RTN_F_INDEX_SEEDED: ; 1E:08C4, 0x03C8C4
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Replacement pointer from stream.
    PHA ; Saved to stack for var efficiency.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load ptr H.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Replace ptr, L.
    PLA
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; H.
    LDY #$00 ; Reset index.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Rehandle.
SCRIPT_RTN_C: ; 1E:08D4, 0x03C8D4
    LDY PACKET_CONSUMED/INDEX? ; Load.
    BEQ SCRIPT_RTN_A ; Stream == 0x00, do A.
    LDA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Save FPTR to stack.
    PHA
    LDA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1
    PHA
    TYA ; Index to A.
    PHA ; Save it.
    BNE SCRIPT_RTN_F_INDEX_SEEDED
SCRIPT_RTN_A: ; 1E:08E2, 0x03C8E2
    PLA ; Pull val.
    BEQ STACK_CONFIG_0x00 ; == 0, goto.
    TAY ; Value to Y.
    INY ; Y += 2. TODO why.
    INY
    PLA ; Pull behind stack.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Set packet creator with.
    PLA
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Goto handler.
STACK_CONFIG_0x00: ; 1E:08F1, 0x03C8F1
    LDY NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Load past index.
    BEQ PAST_INDEX_0x00 ; == 0, goto.
    TXA ; X to Y index.
    TAY
PAST_INDEX_0x00: ; 1E:08FA, 0x03C8FA
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load switch.
    BPL VAL_POSITIVE ; Positive, goto.
    INC GFX_COORD_VERTICAL_OFFSET ; ++
    RTS ; Leave.
VAL_POSITIVE: ; 1E:0901, 0x03C901
    LDA PACKET_CONSUMED/INDEX? ; Load ??
    JSR FORWARD_PACKET_CREATION_FP_BY_A ; Do ??
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load switch rtn.
    RTS ; Leave.
SCRIPT_RTN_B: ; 1E:0909, 0x03C909
    LDY PACKET_CONSUMED/INDEX? ; Load stream.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load.
    STA GFX_COORD_HORIZONTAL_OFFSET ; Store to.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load.
    STA GFX_COORD_VERTICAL_OFFSET ; Store to.
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Stream save.
    BCC CC_SKIP_DEC ; TODO: Always taken?
    DEC GFX_COORD_VERTICAL_OFFSET ; -- on CS. TODO: CS condition.
CC_SKIP_DEC: ; 1E:091B, 0x03C91B
    LDY NMI_PPU_CMD_PACKETS_INDEX ; Index from.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Load past.
    BNE PAST_NONZERO ; != 0, goto.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load. TODO: Why.
PAST_NONZERO: ; 1E:0924, 0x03C924
    JSR PACKET_CALC_COORDS_TO_VADDR_HELPER ; Calc pos.
    JSR PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN ; Header it.
    LDY PACKET_CONSUMED/INDEX? ; Reload.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Go back to handler.
SCRIPT_RTN_D: ; 1E:092F, 0x03C92F
    LDY PACKET_CONSUMED/INDEX? ; Load index.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load from file.
    BCC SCRIPT_CC ; CC, goto.
    LDA #$A0 ; Seed. To append.
SCRIPT_CC: ; 1E:0937, 0x03C937
    STA ENGINE_SCRIPT_SWITCH_VAL? ; Store, to append with.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load.
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Save stream.
    TAY ; Val to Y index.
LOOP_DO: ; 1E:0940, 0x03C940
    DEY ; Y--
    BMI RELAUNCH_HANDLER ; Negative, done.
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load from.
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append to packet.
    JMP LOOP_DO ; Loop on Y.
RELAUNCH_HANDLER: ; 1E:094B, 0x03C94B
    LDY PACKET_CONSUMED/INDEX? ; Reload.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; And relaunch.
SCRIPT_RTN_E: ; 1E:0950, 0x03C950
    LDY PACKET_CONSUMED/INDEX? ; Stream index.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Stream move ptr to alt file.
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store val.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; 2x.
    STA SAVE_GAME_MOD_PAGE_PTR+1
    INY
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; 3x. Move index?
    STA ALT_STUFF_INDEX?
    INY
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; 4x. Flags?
    STA ALT_COUNT_UNK
    INY
    TYA ; Stream to A.
    PHA ; Save.
    LDY ALT_STUFF_INDEX? ; Load ??
    BEQ ALT_0x00 ; == 0, goto.
    LDA #$00
    STA BCD/MODULO/DIGITS_USE_A ; Clear ??
    STA BCD/MODULO/DIGITS_USE_B
    STA BCD/MODULO/DIGITS_USE_C
    DEY ; Y--
VAL_POSITIVE: ; 1E:0975, 0x03C975
    LDA [SAVE_GAME_MOD_PAGE_PTR[2]],Y ; Load from file.
    STA BCD/MODULO/DIGITS_USE_A,Y ; Store to 0x0060.
    DEY ; Y--
    BPL VAL_POSITIVE ; Positive, goto.
    TXA ; X to A.
    PHA ; Save X.
    JSR ENGINE_24BIT_TO_TEXT_DIGITS ; Do.
    PLA ; Pull.
    TAX ; Val to X.
    LDA ALT_COUNT_UNK ; Load ??
    BNE SUB_AND_ADD ; != 0, goto.
    SEC ; Prep sub.
    LDA #$08 ; Adding with sub.
    SBC BCD/MODULO/DIGITS_USE_D ; Sub with.
    STA ALT_COUNT_UNK ; Store to.
    LDA BCD/MODULO/DIGITS_USE_D ; Load ??
    BPL JUST_ADD ; Positive, goto.
SUB_AND_ADD: ; 1E:0993, 0x03C993
    SEC ; Prep sub.
    LDA #$08 ; Sub diff.
    SBC ALT_COUNT_UNK ; Sub with.
JUST_ADD: ; 1E:0998, 0x03C998
    CLC ; Prep add.
    ADC #$68 ; Add file size alloted?
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store PTR L.
    LDA #$00 ; Seed 0x00
    ADC #$00 ; Carry add. 0x00/0x01.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store to.
ALT_0x00: ; 1E:09A3, 0x03C9A3
    LDY #$00 ; Stream index.
ALT_FILE_CONSUMPTION: ; 1E:09A5, 0x03C9A5
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load ??
    BMI NEGATIVE ; Negative, goto.
    LDA [SAVE_GAME_MOD_PAGE_PTR[2]],Y ; Load from file.
    JSR ENGINE_DATA_DICT_MOD_A_UNK ; Mod value.
    BCS DATA_APPEND ; CS, append.
    BCC FLAG_DEC_RELAUNCH ; Always taken, other.
NEGATIVE: ; 1E:09B2, 0x03C9B2
    LDA [SAVE_GAME_MOD_PAGE_PTR[2]],Y ; Load from stream.
    JSR ENGINE_DATA_DICT_MOD_B_UNK ; Do mod.
    BCS DATA_APPEND ; CS, append.
    BCC FLAG_DEC_RELAUNCH ; Not modded, goto Always taken.
APPEND_0xA0: ; 1E:09BB, 0x03C9BB
    LDA #$A0 ; Val ??
    JSR APPEND_DATA_TO_UPDATE_BUF ; Do.
FLAG_DEC_RELAUNCH: ; 1E:09C0, 0x03C9C0
    DEC ALT_COUNT_UNK ; --
    BPL APPEND_0xA0 ; Positive, goto.
    BMI EXIT_RELAUNCH_STACK_TO_Y ; Always taken.
DATA_APPEND: ; 1E:09C6, 0x03C9C6
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append to buffer.
    DEC ALT_COUNT_UNK ; --
    BNE ALT_FILE_CONSUMPTION ; Nonzero, goto.
EXIT_RELAUNCH_STACK_TO_Y: ; 1E:09CD, 0x03C9CD
    PLA ; Pull from stack.
    TAY ; As Y index.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Relaunch.
SCRIPT_RTN_G_RELAUNCH: ; 1E:09D2, 0x03C9D2
    LDY PACKET_CONSUMED/INDEX? ; Just relaunch. This could have been made the end of the other rtn.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Relaunch.
PACKET_CALC_COORDS_TO_VADDR_HELPER: ; 1E:09D7, 0x03C9D7
    LDA ENGINE_PPU_CTRL_COPY ; Load.
    LSR A ; >> 2, /4.
    LSR A ; Get vert bit to carry.
    LDA ENGINE_SCROLL_Y ; Load ??
    ROR A ; Vert bit to 0x80.
    CLC ; Prep add.
    ADC #$08 ; Add 0x08, to next tile?
    STA PACKET_PPU_ADDR_HL+1 ; Store addr L.
    LDA GFX_COORD_VERTICAL_OFFSET ; Load ??
    ADC #$01 ; +1
    ASL A ; << 2, *4.
    ASL A
    CLC ; Prep add.
    ADC PACKET_PPU_ADDR_HL+1 ; Add with, addr L.
    BVS SIGNED_OVERFLOW ; Signed overflow, goto.
    SEC ; Prep sub.
    SBC #$08 ; Sub ??
SIGNED_OVERFLOW: ; 1E:09F1, 0x03C9F1
    ASL A ; << 1, *2. Carry important.
    AND #$F8 ; Keep 1111.1000, mod 8. TODO: Why.
    STA PACKET_PPU_ADDR_HL+1 ; Store to, addr L.
    LDA #$02 ; Load 0000.0010
    ROL A ; 0000.010C
    ASL A ; 0000.10C0
    ASL PACKET_PPU_ADDR_HL+1 ; Rotate out of lower.
    ROL A ; 0001.0C0L
    ASL PACKET_PPU_ADDR_HL+1 ; << 2,
    ROL A ; 0010.C0LL
    STA PACKET_PPU_ADDR_HL[2] ; Store addr H created.
    LDA ENGINE_PPU_CTRL_COPY ; Load.
    LSR A ; Get horiz screen bit.
    LDA ENGINE_SCROLL_X ; Load.
    ROR A ; Rotate H bit into.
    LSR A ; >> 2, /4. /8 total.
    LSR A
    CLC ; Prep add.
    ADC GFX_COORD_HORIZONTAL_OFFSET ; Add with.
    TAY ; Save to Y.
    AND #$20 ; Keep 0010.0000, nametable base.
    LSR A ; >> 3, /7. 0x04/0x00 value.
    LSR A
    LSR A
    ADC PACKET_PPU_ADDR_HL[2] ; Add with namteable H.
    STA PACKET_PPU_ADDR_HL[2] ; Store addr H.
    TYA ; Val back to A.
    AND #$1F ; Keep 0001.1111, tile.
    ADC PACKET_PPU_ADDR_HL+1 ; Add with lower.
    STA PACKET_PPU_ADDR_HL+1 ; Store to lower.
    RTS ; Leave.
APPEND_DATA_TO_UPDATE_BUF: ; 1E:0A1F, 0x03CA1F
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to arr.
    INX ; Index++
    TXA ; Index save.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Index beginning.
    INC NMI_PPU_CMD_PACKETS_BUF+1,X ; Inc size of this packet.
    TAX ; Index into buf back to X.
    INC DATA_APPEND_COUNT? ; ++ ??
    INC DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Inc to test zero, zero means to next screen.
    BEQ PACKET_SPILL_SCREEN ; == 0, goto. Screen spilled, to other at 0x00 index for line.
    RTS ; Leave, done.
PACKET_SPILL_SCREEN: ; 1E:0A31, 0x03CA31
    LDA PACKET_PPU_ADDR_HL+1 ; Load addr L.
    AND #$E0 ; Isolate row only.
    STA PACKET_PPU_ADDR_HL+1 ; Store back to keep row, index 0x00.
    LDA PACKET_PPU_ADDR_HL[2] ; Load.
    EOR #$04 ; Invert 0000.01000, different screen address.
    STA PACKET_PPU_ADDR_HL[2] ; Store back.
PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN: ; 1E:0A3D, 0x03CA3D
    STX NMI_PPU_CMD_PACKETS_INDEX ; Save index up to now.
    LDA #$05 ; Type, unique +1.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to buf.
    INX ; Index++
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Clear count.
    INX ; Index++
    LDA PACKET_PPU_ADDR_HL[2] ; Move address for the screen to the packet.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    INX
    LDA PACKET_PPU_ADDR_HL+1 ; Load addr L.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    INX ; Index++
    ORA #$E0 ; Set index offset bits in addr L for inc check zero.
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Store val to inc.
    RTS ; Leave.
ENGINE_DATA_DICT_MOD_A_UNK: ; 1E:0A5C, 0x03CA5C
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Save.
    CMP #$40 ; If _ #$40
    BCS EXIT_CS ; >=, goto.
    TAY ; Stream to Y.
    LDA DICTIONARY_ALT_VALS,Y ; Load data.
    LDY PACKET_CONSUMED/INDEX? ; Restore stream.
    CMP #$80 ; If alt _ #$80
    BCS EXIT_CS ; >=, leave.
    CMP #$20 ; If alt _ #$20
    BCS EXIT_CS_SET_1000 ; >=, goto.
    CMP #$0A ; If alt _ #$0A
    BCS EXIT_CS_SET_1101 ; >=, goto.
    RTS ; Raw alt, ret CC.
EXIT_CS_SET_1101: ; 1E:0A76, 0x03CA76
    ORA #$D0 ; ??
    RTS
EXIT_CS_SET_1000: ; 1E:0A79, 0x03CA79
    ORA #$80 ; Direct to stream?
EXIT_CS: ; 1E:0A7B, 0x03CA7B
    RTS
ENGINE_DATA_DICT_MOD_B_UNK: ; 1E:0A7C, 0x03CA7C
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Save stream as Y might be used. Why not do this later. :(
    CMP #$40 ; If _ #$40
    BCS EXIT_A:0xA0_CS ; >=, goto.
    TAY ; Val to Y index.
    LDA DICTIONARY_ALT_VALS,Y ; Load alt.
    LDY PACKET_CONSUMED/INDEX? ; Restore stream index.
    CMP #$80 ; If _ #$80
    BCS EXIT_A:0xFE_CS ; >=, goto.
    CMP #$20 ; If _ #$20
    BCS EXIT_A:0xFF_CS ; >=, goto.
    CMP #$0A ; If _ #$0A
    BCS EXIT_A|0xD0_CS ; >=, goto.
    RTS ; Ret CC, as-is. Val < 0xA.
EXIT_A|0xD0_CS: ; 1E:0A96, 0x03CA96
    ORA #$D0 ; Set 1101.0000.
    RTS ; Leave, CS.
EXIT_A:0xFF_CS: ; 1E:0A99, 0x03CA99
    LDA #$FF ; Ret val.
    RTS ; CS.
EXIT_A:0xFE_CS: ; 1E:0A9C, 0x03CA9C
    LDA #$FE ; Ret val.
    RTS ; CS.
EXIT_A:0xA0_CS: ; 1E:0A9F, 0x03CA9F
    LDA #$A0
    RTS
LIB_READING_PPU_ROM_$0110_HELPER: ; 1E:0AA2, 0x03CAA2
    LDA ARG/PTR_L ; Load ??
    BPL VAL_POSITIVE ; Positive, goto.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Set ?? if negative.
    RTS ; Leave.
VAL_POSITIVE: ; 1E:0AA9, 0x03CAA9
    CMP #$7F ; If _ #$7F
    BCS SETTLE_PORTION ; >=, goto.
    TAX ; Val save in X. Delta.
    LDA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Load.
    ASL FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; << 1.
    ROL ARG/PTR_L ; Into var.
    ADC FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Delta added to.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Store result.
    TXA ; Delta to A.
    ADC ARG/PTR_L ; Add with.
    ADC #$80 ; Add with.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Store to.
    LDA #$7F
    STA ARG/PTR_L ; Set ??
    LDA MAPPER_BANK_VALS+6 ; Load R6.
    PHA ; Save it.
    LDA #$18 ; New R6.
    LDX #$06 ; Seed R6.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6.
    LDY #$00 ; Stream reset.
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load from stream.
    STA WORLD_POS?_CARRY_ADDS_UNK[3] ; Store to ??
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load from stream.
    STA WORLD_POS?_CARRY_ADDS_UNK+1 ; Store to ??
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2]],Y ; Load from stream.
    STA WORLD_POS?_CARRY_ADDS_UNK+2 ; Store to ??
    PLA ; Pull R6 saved.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6 again.
SETTLE_PORTION: ; 1E:0AE1, 0x03CAE1
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA #$0A ; Packet type, PPU read.
    STA NMI_PPU_CMD_PACKETS_BUF[69]
    LDA WORLD_POS?_CARRY_ADDS_UNK+2 ; Load ??
    LSR A ; >> 1, /2.
    LDA WORLD_POS?_CARRY_ADDS_UNK+1 ; Load ??
    ROR A ; Rotate into.
    SEC ; Prep CS.
    ROR A ; Into A.
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Store to, bank R4.
    LDA WORLD_POS?_CARRY_ADDS_UNK+1 ; Load ??
    AND #$03 ; Keep lower.
    ORA #$08 ; Set 0x8 ??
    STA NMI_PPU_CMD_PACKETS_BUF+2 ; Store to, addr H.
    LDA WORLD_POS?_CARRY_ADDS_UNK[3] ; Load ??
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Store to, addr L.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+4 ; EOF.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index to trigger.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    LDA #$10
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Set fptr 0x0110 for data read in.
    LDA #$01
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1
    JMP ENGINE_SETTLE_ALL_UPDATES? ; Settle, abuse RTS.
ENGINE_UNK_CARRY_ADDS_???: ; 1E:0B1A, 0x03CB1A
    LDA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Load PTR H.
    BPL PTR_POSITIVE ; Positive, goto.
    STA ARG/PTR_L ; Store if negative, ROM differ reason?
    RTS ; Leave.
PTR_POSITIVE: ; 1E:0B21, 0x03CB21
    SEC ; Prep sub.
    LDA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Load PTR L.
    SBC #$10 ; -= 0x10
    CLC ; Prep add.
    ADC WORLD_POS?_CARRY_ADDS_UNK[3] ; Add with.
    STA WORLD_POS?_CARRY_ADDS_UNK[3] ; Store to.
    LDA #$00 ; Carry seed.
    ADC WORLD_POS?_CARRY_ADDS_UNK+1 ; Carry add.
    STA WORLD_POS?_CARRY_ADDS_UNK+1 ; Store val.
    LDA #$00 ; Carry seed again.
    ADC WORLD_POS?_CARRY_ADDS_UNK+2 ; Carry add.
    STA WORLD_POS?_CARRY_ADDS_UNK+2 ; Store val.
    RTS ; Leave.
FORWARD_PACKET_CREATION_FP_BY_A: ; 1E:0B38, 0x03CB38
    CLC ; Prep add.
    ADC FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Add with.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK[2] ; Store to.
    LDA #$00
    ADC FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Carry adding.
    STA FPTR_PACKET_CREATION/PTR_H_FILE_IDK+1 ; Store to.
    RTS ; Leave.
SYSTEM_SETUP_COMPLETED: ; 1E:0B44, 0x03CB44
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; No writes.
    LDA #$C0
    STA **:$07EF ; Set ??
    JSR ENGINE_HELPER_R6_0x14 ; Set R6.
    JSR EARTHBOUND_GAME_INTRO_AND_FILE_SELECTION ; Game select/startup menus. RETURNS WHEN COMPLETED.
    LDA #$00
    STA **:$07EF ; Clear sound ??
MAIN_LOOP_FIRST_LAUNCHER_LOOP: ; 1E:0B57, 0x03CB57
    JSR ENGINE_HELPER_R7_0x13
    JSR ROUTINE_LAUNCHER_0xE ; Launch ??
MAIN_LOOP_REENTRY_LARGEST: ; 1E:0B5D, 0x03CB5D
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Do lots.
    JSR HOLY_HELL_ALOT ; Also lots.
    LDA #$00
    STA CLEAR_AFTER_HELL_ALOT_LOL ; Clear ??
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load.
    AND #$0F ; Keep bottom.
    EOR #$84 ; Invet to set.
    STA SCRIPT_ACTION_IDFK ; Store to.
MAIN_LOOP_REENTRY_SECOND_LARGEST: ; 1E:0B70, 0x03CB70
    JSR SETTLE_SPRITES_OFFSCREEN/CLEAR_OBJ_RAM ; Settle, no sprites.
    JSR ENGINE_SETTLE_UPDATES_TODO ; Settle, scroll, ??
MAIN_LOOP_REENTRY_THIRD_LARGEST: ; 1E:0B76, 0x03CB76
    JSR ENGINE_MAP_DISPLAY_OR_SCRIPT_RUN? ; Do.
    JSR SCRIPT_SCROLL_INVERT_RTN? ; Do.
    LDA ENGINE_FLAG_25_SKIP_UNK
    BNE VAL_NONZERO ; != 0, skip.
    LDA CTRL_BUTTONS_PREVIOUS[2] ; Load prev.
    AND #$70 ; Test B, select, start.
    BEQ NONE_PRESSED ; None pressed, cleared.
    JSR CTRL_BUTTONS_TO_ACTION_VAL_START
    AND #$08 ; Test loaded.
    BEQ NONE_PRESSED ; == 0, goto.
    LDA #$01 ; Set ??
NONE_PRESSED: ; 1E:0B8F, 0x03CB8F
    STA ACTION_BUTTONS_RESULT ; Set action result.
VAL_NONZERO: ; 1E:0B91, 0x03CB91
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA FIRST_LAUNCHER_HOLD_FLAG?
    BNE MAIN_LOOP_FIRST_LAUNCHER_LOOP ; != 0, goto.
    JSR MANY_STREAMS_UNK ; Do ??
    JSR STREAMS_UNK_SPRITE_READ?
    JSR BUTTONS_UPDATE_AND_MORE_OH_MY ; TODO: CLEAN ME
    LDA MAIN_FLAG_UNK ; Load ??
    BEQ MAIN_FLAG_21_CLEAR ; == 0, goto.
    JSR ENGINE_HELPER_R7_0x13 ; Set 13 with if nonzero.
    JSR STREAMY_LIBY_UNK ; Banks and launches a bit and a few more small things.
    BCC STATES_COMBINED_ANY_SET_HANDLER ; Ret CC, goto.
MAIN_FLAG_21_CLEAR: ; 1E:0BAD, 0x03CBAD
    JSR ENGINE_HELPER_R7_0x13 ; Do.
    LDA #$00 ; Clear val.
    LDY CONTROL_ACCUMULATED?[2] ; Load buttons.
    STA CONTROL_ACCUMULATED?[2] ; Clear accumulated.
    LDA SCRIPT_FLAG_0x22_AUTO_MOVE ; Load ??
    ORA FLAG_UNK_23 ; Set with others.
    ORA MAIN_FLAG_UNK
    ORA FIRST_LAUNCHER_HOLD_FLAG?
    BNE STATES_COMBINED_ANY_SET_HANDLER ; != 0, goto.
    TYA ; Buttons to A.
    AND #$F0 ; Test A/B/SEL/START
    BMI A_PRESSED_HANDLER ; A pressed, goto special.
    BNE NO_A_YES_B/SEL/START ; Others set, goto.
    JSR SCRIPT_PHONE_RELATED?_TODO ; TODO <<<<<<<<<<<<<<<<<<<<<<<<<
    JMP NOT_PRESSED_RTN ; Goto.
NO_A_YES_B/SEL/START: ; 1E:0BCD, 0x03CBCD
    JSR CTRL_BUTTONS_TO_ACTION_VAL_START ; Do.
    AND #$A0 ; Keep 1010.0000
    BEQ NOT_PRESSED_RTN ; Not set, goto.
    BMI VAL_NEGATIVE ; _ALT
    JSR ENGINE_MAIN_RTN_MANY_FADES ; Do ??
    JMP NOT_PRESSED_RTN ; Goto.
VAL_NEGATIVE: ; 1E:0BDC, 0x03CBDC
    JSR LOOPY_IDFK ; Do ??
    JMP NOT_PRESSED_RTN ; Goto.
A_PRESSED_HANDLER: ; 1E:0BE2, 0x03CBE2
    JSR ENGINE_UNK_OBJECTS_REELATED? ; Do ??
NOT_PRESSED_RTN: ; 1E:0BE5, 0x03CBE5
    JSR ENGINE_HELPER_R6_0x14 ; Set R6.
    JSR ROUTINE_CHECK_MANY_COMBINED_SONG_THINGY? ; Do ??
STATES_COMBINED_ANY_SET_HANDLER: ; 1E:0BEB, 0x03CBEB
    LDA SCRIPT_ENCOUNTER_ID?(SAID_SONG_ID???) ; Load ??
    BEQ HELPER_GOTO_MAIN_TERTIARY ; == 0, goto.
    CMP #$A2 ; If _ #$A2, ends game somehow.
    BEQ MAIN_ALT_CHECKS_END_OF_GAME ; ==, goto.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA SOUND_VAL_SONG_CURRENT_ID ; Load ??
    PHA ; Save it.
    JSR LIB_BATTLE_ENDED? ; Do ??
    PLA ; Pull A.
    BCS HELPER_GOTO_MAIN_PRIMARY ; CS, goto.
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Update it.
    LDA MAIN_FLAG_UNK ; Load ??
    BEQ HELPER_GOTO_MAIN_SECONDARY ; == 0, goto.
    JSR ENGINE_HELPER_R7_0x13 ; Set R7.
    JSR LIB_STREAM_COMMANDS_PROCESS_UNK ; Do, very scripty.
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Seed val.
    BNE HELPER_GOTO_MAIN_PRIMARY ; Nonzero, goto.
HELPER_GOTO_MAIN_SECONDARY: ; 1E:0C11, 0x03CC11
    JMP MAIN_LOOP_REENTRY_SECOND_LARGEST ; Do ??
HELPER_GOTO_MAIN_PRIMARY: ; 1E:0C14, 0x03CC14
    JMP MAIN_LOOP_REENTRY_LARGEST ; Do ??
HELPER_GOTO_MAIN_TERTIARY: ; 1E:0C17, 0x03CC17
    JMP MAIN_LOOP_REENTRY_THIRD_LARGEST ; Do ??
MAIN_ALT_CHECKS_END_OF_GAME: ; 1E:0C1A, 0x03CC1A
    JSR ENGINE_HELPER_R6_0x14 ; Set R6.
    JSR SCRIPTY_TODO ; Do ??
    JSR LIB_BATTLE_ENDED? ; Return if game ended.
    BCS HELPER_GOTO_MAIN_PRIMARY ; Ret CS.
    JSR ENGINE_HELPER_R6_0x14 ; R6 Bank.
    JMP GAME_ENDING_SEQUENCE ; Do game end, this is it.
BUTTONS_UPDATE_AND_MORE_OH_MY: ; 1E:0C2B, 0x03CC2B
    LDA ACTION_BUTTONS_RESULT ; Load.
    CMP #$07 ; If _ #$07, ??
    BCS ACTION_RESULT_GTE_0x7 ; >=, goto.
    LDA #$10
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag ??
    JSR SCRIPT_PTR_MOD_AND_??_THEN_CHAIN_?? ; Do ??
    JSR UNK_GFX_AND_?? ; Do ??
WAIT_E5_FLAG: ; 1E:0C3B, 0x03CC3B
    LDA NMI_FLAG_EXECUTE_UPDATE_BUF
    BNE WAIT_E5_FLAG ; != 0, loop on.
LOOP_GTE_0x9: ; 1E:0C3F, 0x03CC3F
    LDA NMI_FLAG_EXECUTE_HOLD_MULTIPART/BOTTOM? ; Load.
    CMP #$09 ; If _ #$09
    BCS LOOP_GTE_0x9 ; >=, goto.
    SEC ; Prep carry 1.
    ROR NMI_FLAG_OBJECT_PROCESSING? ; Rotate in, set 0x80.
    JSR OBJECTS_MOVE? ; Do ??
    ASL NMI_FLAG_OBJECT_PROCESSING? ; Shift flag.
    JSR FLAG_HOLD_WAIT_AND_UPDATES_UNK ; Do.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    BNE ALT_RTN ; Always taken.
ACTION_RESULT_GTE_0x7: ; 1E:0C5D, 0x03CC5D
    JSR SCRIPT_PTR_MOD_AND_??_THEN_CHAIN_?? ; Do ??
    JSR UNK_GFX_AND_?? ; Do ??
    JSR FLAG_HOLD_WAIT_AND_UPDATES_UNK ; Do ??
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$10
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag ??
    LDA ACTION_BUTTONS_RESULT ; Load.
    CMP #$0F ; If _ #$0F
    BCS ALT_RTN ; >=, goto.
VAL_NONZERO: ; 1E:0C77, 0x03CC77
    LDA NMI_FLAG_EXECUTE_UPDATE_BUF ; Load.
    BNE VAL_NONZERO ; != 0, wait.
    SEC ; Seed lock.
    ROR NMI_FLAG_OBJECT_PROCESSING? ; Set lock bit.
    JSR OBJECTS_MOVE? ; Goto.
    ASL NMI_FLAG_OBJECT_PROCESSING? ; Unlock.
ALT_RTN: ; 1E:0C83, 0x03CC83
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    LSR A ; >> 1, /2.
    BCC SHIFT_CC ; CC, goto.
    JSR WAIT_UPDATE ; Do ??
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
SHIFT_CC: ; 1E:0C96, 0x03CC96
    BIT SCRIPT_UNK_DATA_SELECT_?? ; Test ??
    BMI RTS ; If negative, leave.
    INC ENGINE/SCRIPT_R1_BANK_USE_TODO ; Inc ??
RTS: ; 1E:0C9C, 0x03CC9C
    RTS
CTRL_BUTTONS_TO_ACTION_VAL_START: ; 1E:0C9D, 0x03CC9D
    LSR A ; Nibble down.
    LSR A
    LSR A
    LSR A
    TAX ; To X index.
    LDY CTRL_BUTTONS_ACTION_INDEX,X ; Load from table, index into save slot data.
    LDA BUTTON_ACTION_INDEX_ARRAY[3],Y ; Val from save area.
    RTS ; Leave.
CTRL_BUTTONS_ACTION_INDEX: ; 1E:0CA9, 0x03CCA9
    .db 00 ; None pressed.
    .db 01 ; Start pressed.
    .db 02 ; Select pressed.
    .db 01 ; Start+select, do start.
    .db 00 ; Nothing.
    .db 00
    .db 00
    .db 00
VAL_NEGATIVE: ; 1E:0CB1, 0x03CCB1
    LDA #$FF
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; No main song.
    JSR SCRIPT_ROUTINE?_DOER? ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    LDA #$02
    STA SND_CODE_HELPER_ARR ; Store to sound ??
    LDA #$01
    ORA ENGINE_PPU_MASK_COPY ; Set greyscale.
    STA ENGINE_PPU_MASK_COPY ; Store greyscale.
    LDX #$08 ; Times to shake.
SHAKE_CONTINUE: ; 1E:0CC6, 0x03CCC6
    JSR SCRIPT_INVERT_X_SCROLL_SETTLE ; Shake it up baby.
    DEX ; X--
    BNE SHAKE_CONTINUE ; != 0, do more.
    LDA #$1E
    AND ENGINE_PPU_MASK_COPY ; Re-set normal mask.
    STA ENGINE_PPU_MASK_COPY ; Store back.
    JSR WAIT_ANY_BUTTONS_PRESSED_RET_PRESSED ; Wait.
    JMP EXIT_SCRIPT_CLEAR_UNK ; Goto.
    LDA SOUND_VAL_SONG_CURRENT_ID ; Save value.
    PHA
    LDA #$FF
    STA R_**:$000F ; Set ??
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Store, no main song.
    JSR LIB_OBJECTS_AND_SETTLE_AND_FLAGS_UNK ; Do lib.
    LDA #$01
    STA R_**:$07F4 ; Set ??
    JSR SUB_WRITE_SAVE_PAGE_UNK ; Do sub.
    LDX #$05 ; Val ??
VAL_LT_0x2D: ; 1E:0CF0, 0x03CCF0
    JSR ACTION_AND_UNK_EXIT ; Do.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load.
    BMI VAL_NEGATIVE ; Negative, goto.
    LDA CTRL_BUTTONS_PREVIOUS[2] ; Load buttons.
    AND #$0F ; Keep UDLR
    TAX ; To X index.
    LDA ACTION_ARRAY_UDLR?,X ; Load action.
    BMI ACTION_NEGATIVE ; Invalid, goto.
    ORA #$40 ; Set ??
    TAX ; To X index.
    EOR SCRIPT_FLAG_0x22_AUTO_MOVE ; Invert with.
    CMP #$04 ; If _ #$04
    BEQ ACTION_NEGATIVE ; ==, goto.
    STX SCRIPT_FLAG_0x22_AUTO_MOVE ; Store to script val?
ACTION_NEGATIVE: ; 1E:0D0C, 0x03CD0C
    LDX ENGINE_FLAG_25_SKIP_UNK ; Load ?
    INX ; ++
    CPX #$2D ; If _ #$2D
    BCC VAL_LT_0x2D ; <, goto.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Do.
    LDA #$20 ; Load ??
X_INDEX_SEEDED: ; 1E:0D18, 0x03CD18
    TAX ; A to X.
    ASL OBJ?_BYTE_0x4_UNK,X ; Shift.
    ASL OBJ?_BYTE_0x5_BYTE,X ; Shift.
    SEC ; Prep sub.
    SBC #$08 ; -= 0x8
    BNE X_INDEX_SEEDED ; != 0, goto.
    LDA #$0A ; Seed ??
LOOP_NONZERO: ; 1E:0D26, 0x03CD26
    PHA ; Save passed.
    JSR BUTTONS_UPDATE_AND_MORE_OH_MY ; Do ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    PLA ; Pull passed.
    SEC ; Prep sub.
    SBC #$01 ; Sub with.
    BNE LOOP_NONZERO ; != 0, goto.
    LDA #$01
    STA R_**:$07F3 ; Set ??
    LDA #$22
    JSR ENGINE_ALL_COLOR_TO_A ; All color.
    JSR ENGINE_HELPER_R7_0x13 ; Do helper.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Do WRAM.
    JSR R6_AND_FILE_MANIP_UNK ; Do bank.
    JSR SLOTS_AND_FPTRS_IDFK ; Do slotty.
    PLA ; Pull todo why.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Load over it because fuck off.
    TAX ; Value to X.
    AND #$3F ; Keep lower.
    PHA ; Save it.
    TXA ; X to A.
    AND #$C0 ; Keep upper.
    STA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Store to.
    JSR LIB_SPECIAL_CHECKS_WITH_CMPS_UNK ; Do checks.
    LDX #$14
    JSR ENGINE_DELAY_X_FRAMES ; Delay.
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Do.
    JSR HOLY_HELL_ALOT ; Holy hell.
    JSR SETTLE_SPRITES_OFFSCREEN/CLEAR_OBJ_RAM ; Do no sprites.
    JSR ENGINE_SETTLE_UPDATES_TODO ; Settle.
    JSR SUB_WRITE_SAVE_PAGE_UNK ; Do save.
    LDX #$2C ; Seed loops?
X_INDEX_POSITIVE: ; 1E:0D70, 0x03CD70
    JSR ACTION_AND_UNK_EXIT ; Do ??
    LDX ENGINE_FLAG_25_SKIP_UNK ; Load ??
    DEX ; X -= 2
    DEX
    BPL X_INDEX_POSITIVE ; Positive, goto.
EXIT_SCRIPT_CLEAR_UNK: ; 1E:0D79, 0x03CD79
    LDX #$00
    STX SCRIPT_FLAG_0x22_AUTO_MOVE ; Clear.
    STX CONTROL_ACCUMULATED?[2] ; Clear ctrl.
    STX R_**:$000F ; Clear ??
    JSR ACTION_INDEX_STORE_AND_RETURN_VALUE_UNK ; Action.
    PLA ; Pull value.
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Store.
    JMP MAIN_LOOP_REENTRY_THIRD_LARGEST ; Reenter main.
ACTION_AND_UNK_EXIT: ; 1E:0D8B, 0x03CD8B
    JSR ACTION_INDEX_STORE_AND_RETURN_VALUE_UNK ; Action and.
    JSR ENGINE_MAP_DISPLAY_OR_SCRIPT_RUN? ; Do ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR MANY_STREAMS_UNK ; Do ??
    JSR STREAMS_UNK_SPRITE_READ? ; Do ??
    JMP BUTTONS_UPDATE_AND_MORE_OH_MY ; Goto.
SUB_WRITE_SAVE_PAGE_UNK: ; 1E:0D9D, 0x03CD9D
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Set writeable.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load page.
    AND #$0F ; Keep lower.
    STA R_**:$6799 ; Store to.
    ORA #$40 ; Set ??
    STA SCRIPT_FLAG_0x22_AUTO_MOVE ; Store to ??
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable and exit.
ACTION_INDEX_STORE_AND_RETURN_VALUE_UNK: ; 1E:0DAF, 0x03CDAF
    STX ENGINE_FLAG_25_SKIP_UNK ; Store X to.
    LDA DATA_TABLE_ACTION_RESULTS?,X ; Load table.
    STA ACTION_BUTTONS_RESULT ; Store to.
    RTS ; Leave.
DATA_TABLE_ACTION_RESULTS?: ; 1E:0DB7, 0x03CDB7
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 01
    .db 01
    .db 01
    .db 01
    .db 01
    .db 02
    .db 02
    .db 02
    .db 02
    .db 03
    .db 03
    .db 03
    .db 03
    .db 03
    .db 03
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 0F
    .db 0F
    .db 0F
    .db 0F
    .db 0F
ENGINE_MAIN_SONG_REPLACE_AND_THEN_RESTORE_MAIN_SONG?: ; 1E:0DE4, 0x03CDE4
    PHA ; Save passed.
    LDA SOUND_VAL_SONG_CURRENT_ID ; Load.
    TAX ; To index.
    PLA ; Pull passed.
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Do other passed.
    LDA #$00
    STA CONTROL_ACCUMULATED?[2] ; Clear accumulated.
VAL_NONZERO: ; 1E:0DF1, 0x03CDF1
    BIT CONTROL_ACCUMULATED?[2] ; Test buttons.
    BVS BUTTON_B_PRESSED ; If set, goto.
    LDA SOUND_VAL_SONG_CURRENT_ID ; Load.
    BNE VAL_NONZERO ; If nonzero, loop wait.
BUTTON_B_PRESSED: ; 1E:0DFA, 0x03CDFA
    LDA #$00
    STA CONTROL_ACCUMULATED?[2] ; Clear buttons.
    TXA ; Val CMP original to A.
    JMP SOUND_ASSIGN_NEW_MAIN_SONG ; Goto.
FILE_FROM_PPU_READ_2KB_TO_WRAM_6C00-7EFF: ; 1E:0E02, 0x03CE02
    LDY #$5E ; Seed GFX Bank for data.
    LDA #$00
    LDX #$6C ; Seed 0x6C00?
    STA BCD/MODULO/DIGITS_USE_A ; Set fptr 0x6C00
    STX BCD/MODULO/DIGITS_USE_B
    JSR ENGINE_SETTLE_ALL_UPDATES?
    TYA ; Val to A.
    LDX #$01 ; R1
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX Bank.
    LDA #$09 ; Packet PPU read.
    LDX #$40 ; Count.
    STA NMI_PPU_CMD_PACKETS_BUF[69] ; Packet making.
    STX NMI_PPU_CMD_PACKETS_BUF+1
    LDA #$00 ; Set addr 0x1800
    LDX #$18
    STX NMI_PPU_CMD_PACKETS_BUF+2 ; Addr H, 0x18
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Addr L, 0x00.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+68 ; End of file clear?
    LDX #$20 ; Loops, 0x40 size per loop, 0x800 total.
LOOP_0x800: ; 1E:0E30, 0x03CE30
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM with writing.
    LDY #$00 ; Index.
LOOP_TO_TARGET: ; 1E:0E40, 0x03CE40
    LDA NMI_PPU_CMD_PACKETS_BUF+4,Y ; Load from buf.
    STA [BCD/MODULO/DIGITS_USE_A],Y ; Store to fp. 0x6C00 - 0x73FF.
    INY ; Index++
    CPY #$40 ; If _ #$40
    BCC LOOP_TO_TARGET ; <, goto.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; No WRAM writes now.
    CLC ; Prep add.
    TYA ; A = 0x40
    ADC BCD/MODULO/DIGITS_USE_A ; Add consumed to ptr.
    STA BCD/MODULO/DIGITS_USE_A
    LDA #$00
    ADC BCD/MODULO/DIGITS_USE_B ; Carry add.
    STA BCD/MODULO/DIGITS_USE_B
    CLC ; Prep add.
    TYA ; Consumed to A.
    ADC NMI_PPU_CMD_PACKETS_BUF+3 ; Add 0x40 to screen addr, moving 2 lines.
    STA NMI_PPU_CMD_PACKETS_BUF+3
    LDA #$00
    ADC NMI_PPU_CMD_PACKETS_BUF+2 ; Carry add.
    STA NMI_PPU_CMD_PACKETS_BUF+2
    DEX ; Index--
    BNE LOOP_0x800 ; != 0, loop.
    RTS ; Leave.
PPU_READ_INTO_$0110_HELPER_LOOP_UNK: ; 1E:0E6D, 0x03CE6D
    LDA #$00
    LDX #$00
    STA BCD/MODULO/DIGITS_USE_A
    STX BCD/MODULO/DIGITS_USE_B ; Set $0000
    LDA #$00
    LDX #$20
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    STX SAVE_GAME_MOD_PAGE_PTR+1 ; Set to $2000.
    LDA #$10
    STA LOCAL_VARS_ARR?[8] ; Set loop count, 0x10.
LOOPS_NONZERO: ; 1E:0E81, 0x03CE81
    LDA BCD/MODULO/DIGITS_USE_A ; Seed PPU Addr H.
    LDX BCD/MODULO/DIGITS_USE_B ; Seed L.
    LDY #$09 ; Seed type, read to RAM.
    JSR ENGINE_LARGE_UNIQUE_PPU_PACKET_HELPER ; Do.
    LDA SAVE_GAME_MOD_PAGE_PTR[2] ; Seed PPU Addr H.
    LDX SAVE_GAME_MOD_PAGE_PTR+1 ; Seed L.
    LDY #$05 ; Seed type, unique upload.
    JSR ENGINE_LARGE_UNIQUE_PPU_PACKET_HELPER ; Do.
    CLC ; Prep add.
    LDA #$40 ; Adding val.
    ADC BCD/MODULO/DIGITS_USE_A ; Add with.
    STA BCD/MODULO/DIGITS_USE_A ; Store result.
    LDA #$00
    ADC BCD/MODULO/DIGITS_USE_B ; Carry add.
    STA BCD/MODULO/DIGITS_USE_B ; Store result.
    CLC ; Prep add.
    LDA #$40 ; Adding val.
    ADC SAVE_GAME_MOD_PAGE_PTR[2] ; Add with.
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store result.
    LDA #$00 ; Carry seed.
    ADC SAVE_GAME_MOD_PAGE_PTR+1 ; Add with.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store result.
    DEC LOCAL_VARS_ARR?[8] ; Loops--
    BNE LOOPS_NONZERO ; != 0, goto.
    RTS ; Leave.
ENGINE_LARGE_UNIQUE_PPU_PACKET_HELPER: ; 1E:0EB2, 0x03CEB2
    PHA ; Save passed.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    PLA ; Restore.
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Val to, Addr L.
    STX NMI_PPU_CMD_PACKETS_BUF+2 ; X to, Addr H.
    STY NMI_PPU_CMD_PACKETS_BUF[69] ; Y to, type.
    LDA #$40
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Set GFX bank pair.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+68 ; Clear the end of the packet.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_INDEX ; Clear index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    RTS ; Leave.
ENGINE_HELPER_R7_0x13: ; 1E:0ED3, 0x03CED3
    LDA #$13
    LDX #$07
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_HELPER_R7_0x17: ; 1E:0EDA, 0x03CEDA
    LDA #$17
    LDX #$07
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_HELPER_R6_0x14: ; 1E:0EE1, 0x03CEE1
    LDA #$14 ; R6 = 0x14
    LDX #$06
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A ; Do, return.
ENGINE_SET_GFX_BANKS_FPTR_AX: ; 1E:0EE8, 0x03CEE8
    STA BCD/MODULO/DIGITS_USE_A ; Set PTR.
    STX BCD/MODULO/DIGITS_USE_B
    LDX #$05 ; Seed bank GFX bank.
    LDY #$05 ; Seed stream index start.
STREAM_INDEX_POSITIVE: ; 1E:0EF0, 0x03CEF0
    LDA [BCD/MODULO/DIGITS_USE_A],Y ; Load from index.
    BEQ STREAM_0x00 ; == 0, goto.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set bank 0x05 -> 0x00
STREAM_0x00: ; 1E:0EF7, 0x03CEF7
    DEX ; R# bank.
    DEY ; Stream index val used.
    BPL STREAM_INDEX_POSITIVE ; Positive, loop more.
    RTS ; Leave.
HOLY_HELL_ALOT: ; 1E:0EFC, 0x03CEFC
    JSR HUGE_ASS_STREAMS_THINGY_IDFK ; Do ??
    LDA #$14
    LDX #$06 ; R6 = 0x14
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set.
    LDA #$00
    STA SCRIPT_B800_PTR_UNK+1 ; Clear addr H.
    LDA R_**:$0014 ; Load ??
    ASL A ; << 3, *8.
    ASL A
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; Rotate bit into.
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; 2x
    ADC #$00 ; Carry add.
    STA SCRIPT_B800_PTR_UNK[2] ; Store to, addr L.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load.
    ADC #$90 ; += 0x90
    STA SCRIPT_B800_PTR_UNK+1 ; Store, addr H.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDY #$0F ; Stream index.
INDEX_POSITIVE: ; 1E:0F23, 0x03CF23
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    BPL STREAM_POSITIVE ; Positive, goto.
    JSR ENGINE_HELPER_LOAD_7400_INDEX_A&3F ; Load it if negative.
STREAM_POSITIVE: ; 1E:0F2A, 0x03CF2A
    STA SCRIPT_PALETTE_UPLOADED?[32],Y ; Store val to palette.
    DEY ; Index--
    BPL INDEX_POSITIVE ; Positive, loop.
    LDY #$0F ; Reset index.
INDEX_POSITIVE: ; 1E:0F32, 0x03CF32
    LDA PALETTE_SPRITE_UNK,Y ; Load from arr.
    STA SCRIPT_PALETTE_UPLOADED?+16,Y ; Store to sprite palette.
    DEY ; Index--
    BPL INDEX_POSITIVE ; Positive, goto.
    LDX SCRIPT_PALETTE_UPLOADED?+12 ; Load ??
    LDY SCRIPT_PALETTE_UPLOADED?+14
    STX R_**:$0017 ; Save to.
    STY R_**:$0016
    LDX #$0F ; Seed ??
    LDY #$30
    STX SCRIPT_PALETTE_UPLOADED?+12
    STY SCRIPT_PALETTE_UPLOADED?+14
    JSR SCRIPT_SET_GFX ; Do ??
    LDA SCRIPT_PAIR_PTR?[2] ; Load.
    AND #$C0 ; Keep upper.
    STA SCRIPT_USE_UNK_B_PTR_L ; Store it.
    LDA SCRIPT_PAIR_PTR?+1 ; Move other.
    STA SCRIPT_USE_UNK_C_PTR_H
    LDA #$40 ; Set ??
    STA R_**:$00AE
    LDA #$00 ; Clear ??
    STA R_**:$00AF
    LDA #$10 ; Set ??
    STA R_**:$009B
LOOP_JMP: ; 1E:0F68, 0x03CF68
    SEC ; Prep sub.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load ??
    AND #$C0 ; Keep 1100.0000
    SBC #$40 ; -= 0x40
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store to.
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Load ??
    SBC #$00 ; Carry sub.
    STA SCRIPT_USE_UNK_A ; Store to.
    LDA #$13
    STA SCRIPT_COUNT_UNK ; Set ??
    JSR DEEP_STREAMER_IDFK ; Do ??
    DEC R_**:$009B ; --
    BEQ COUNT_EQ_ZERO ; == 0, goto.
    CLC ; Prep add.
    LDA SCRIPT_USE_UNK_B_PTR_L ; Load.
    ADC #$40 ; += 0x40
    STA SCRIPT_USE_UNK_B_PTR_L ; Store result.
    LDA SCRIPT_USE_UNK_C_PTR_H ; Load.
    ADC #$00 ; Carry add.
    STA SCRIPT_USE_UNK_C_PTR_H ; Store result.
    JMP LOOP_JMP ; Loop.
COUNT_EQ_ZERO: ; 1E:0F92, 0x03CF92
    JSR CREATE_VAL/INDEX_UNK ; Do.
    LDY #$00 ; Clear ??
    STY R_**:$001D
    JMP LOOP_HELPER_A_LOT ; Exit.
PALETTE_SPRITE_UNK: ; 1E:0F9C, 0x03CF9C
    .db 0F
    .db 0F
    .db 00
    .db 30
    .db 0F
    .db 0F
    .db 16
    .db 37
    .db 0F
    .db 0F
    .db 24
    .db 37
    .db 0F
    .db 0F
    .db 12
    .db 37
ENGINE_SETTLE_UPDATES_TODO: ; 1E:0FAC, 0x03CFAC
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    CLC ; No reason?
    LDA R_**:$001C ; Load.
    ORA #$08 ; Set ??
    TAX ; To X index.
    LDY R_**:$001D ; Y from.
    LDA ENGINE_PPU_CTRL_COPY ; Load copy.
    AND #$FC ; Nametable clear.
    ORA R_**:$001E ; Set nametable with.
    STA ENGINE_PPU_CTRL_COPY ; Store back.
    STX ENGINE_SCROLL_X ; X and Y as.
    STY ENGINE_SCROLL_Y
    STY R_**:$0099 ; Y to, also.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ADC #$80 ; += 0x80
    STA SCRIPT_USE_UNK_B_PTR_L ; Store.
    LDA SCRIPT_PAIR_PTR?+1 ; Load ??
    ADC #$03 ; += 0x3
    STA SCRIPT_USE_UNK_C_PTR_H ; Store ptr H.
    LDA #$0F
    STA R_**:$009B ; Set ??
LOOP_RTN: ; 1E:0FD8, 0x03CFD8
    CLC ; Prep add.
    LDA R_**:$0099 ; Load.
    ADC #$F0 ; += 0xF0
    BCS ADD_OVERFLOW ; Overflow, goto.
    ADC #$F0 ; Add to sub?
ADD_OVERFLOW: ; 1E:0FE1, 0x03CFE1
    STA R_**:$0099 ; Store to.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load.
    AND #$C0 ; Keep upper.
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store to.
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Move ??
    STA SCRIPT_USE_UNK_A
    LDX R_**:$009B ; Load index.
    LDA ROM_DATA_UNK,X ; Load ??
    EOR R_**:$0099 ; Invert with.
    AND #$10 ; Keep ??
    BNE VABIT_SET ; If set, use as-is.
    LDA ROM_DATA_UNK,X ; Load otherwise.
VABIT_SET: ; 1E:0FFB, 0x03CFFB
    STA DEEP_STREAM_MOD_UNK ; Store ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR PACKET_CREATOR_HELPER_ALOT ; Do.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; End of packet.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    DEC R_**:$009B ; --
    BEQ TIMER_EQ_0x00 ; == 0, goto.
    LDA R_**:$009B ; Load left.
    ASL A ; << 1, *2.
    TAX ; To X index.
    JSR WAIT_NMI/IRQ_CLEAR ; Wait.
    LDA #$25
    STA SCRIPT_PALETTE_TARGET/ALT?+30,X ; Set ??
    SEC ; Prep sub.
    LDA SCRIPT_USE_UNK_B_PTR_L ; Load ??
    SBC #$40 ; -= 0x40
    STA SCRIPT_USE_UNK_B_PTR_L ; Store result.
    LDA SCRIPT_USE_UNK_C_PTR_H ; Carry subtract.
    SBC #$00
    STA SCRIPT_USE_UNK_C_PTR_H
    JMP LOOP_RTN ; Goto.
TIMER_EQ_0x00: ; 1E:102E, 0x03D02E
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR SCRIPT_SET_GFX ; Set GFX.
    LDA #$04
    STA NMI_PPU_CMD_PACKETS_BUF[69] ; Set type, palette.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Index reset.
    LDA #$80
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    LDA #$88
    STA SCRIPT_UNK_DATA_SELECT_?? ; Set ??
    LDA #$00
    STA NMI_LATCH_FLAG ; Latch ??
    STA CONTROL_ACCUMULATED?[2] ; Clear controller buttons.
ROM_DATA_UNK: ; 1E:104E, 0x03D04E
    RTS ; Leave. TODO: Table off by one buf or not?
    .db F0
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 20
SCRIPT_PTR_MOD_AND_??_THEN_CHAIN_??: ; 1E:105E, 0x03D05E
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI RTS ; Negative, goto.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    TAX ; To X index.
    CLC ; Prep add.
    LDA LUT_MOD_ARRAY_MOVEMENT?[4],X ; Load data.
    ADC SCRIPT_PAIR_PTR_B_SEED?[2] ; Add with.
    STA SCRIPT_PAIR_PTR_B_SEED?[2] ; Store to.
    LDA LUT_MOD_ARRAY_MOVEMENT?+1,X ; Load other.
    ADC SCRIPT_PAIR_PTR_B_SEED?+1 ; Add with.
    STA SCRIPT_PAIR_PTR_B_SEED?+1 ; Store to.
    CLC ; Do this pair, too.
    LDA LUT_MOD_ARRAY_MOVEMENT?+2,X
    ADC SCRIPT_PAIR_PTR?[2]
    STA SCRIPT_PAIR_PTR?[2]
    LDA LUT_MOD_ARRAY_MOVEMENT?+3,X
    ADC SCRIPT_PAIR_PTR?+1
    STA SCRIPT_PAIR_PTR?+1
    CLC ; Prep add.
    LDA LUT_MOD_ARRAY_MOVEMENT?+2,X ; Add data.
    BEQ CREATE_VAL/INDEX_UNK ; == 0, goto.
    BMI VAL_NEGATIVE ; Negative, goto.
    LDA R_**:$001D ; Load ??
    ADC #$20 ; += 0x20
    BCC STORE_UPPER ; No overflow, goto.
    BCS STORE_ASIS ; Overflow, goto.
VAL_NEGATIVE: ; 1E:1094, 0x03D094
    LDA R_**:$001D ; Load.
    ADC #$F0 ; Add sub ??
    BCS STORE_ASIS ; >=, goto.
STORE_UPPER: ; 1E:109A, 0x03D09A
    ADC #$F0 ; Keep upper only.
STORE_ASIS: ; 1E:109C, 0x03D09C
    STA R_**:$001D ; Store ??
CREATE_VAL/INDEX_UNK: ; 1E:109E, 0x03D09E
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Load ??
    AND #$07 ; Keep lower.
    STA R_**:$001E ; Store to.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load ??
    AND #$C0 ; Keep upper bits.
    LSR R_**:$001E ; Shift bits off.
    ROR A ; Into A.
    LSR R_**:$001E ; 2x
    ROR A
    STA R_**:$001C ; Store A crafter.
RTS: ; 1E:10B0, 0x03D0B0
    RTS ; Leave.
UNK_GFX_AND_??: ; 1E:10B1, 0x03D0B1
    JSR SCRIPT_SET_GFX ; Do.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI RTS ; Negative, leave.
    JSR HELPER_DEEP_STREAMER_UNK ; Do ??
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    LSR A ; >> 1, /2.
    BCS RERUN_DEEP_STREAMER_ALT_UNK ; CS, rerun with carry.
RTS: ; 1E:10C0, 0x03D0C0
    RTS ; Leave.
RERUN_DEEP_STREAMER_ALT_UNK: ; 1E:10C1, 0x03D0C1
    ADC #$00 ; Carry added to it.
    ASL A ; << 1, *2.
HELPER_DEEP_STREAMER_UNK: ; 1E:10C4, 0x03D0C4
    AND #$06 ; Keep 0000.0110
    ASL A ; << 2, *4.
    ASL A
    TAX ; To X index.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load.
    AND #$C0 ; Keep upper.
    ADC MOD_TABLE_UNK[2],X ; Add with.
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store ??
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Load alt.
    ADC MOD_TABLE_UNK+1,X ; Mod with.
    STA SCRIPT_USE_UNK_A ; Store to.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ADC ROM_DATA_ARR_UNK,X ; Add with.
    STA SCRIPT_USE_UNK_B_PTR_L ; Store ??
    LDA SCRIPT_PAIR_PTR?+1 ; Load.
    ADC SLOT_EXTRAS[4],X ; Mod.
    STA SCRIPT_USE_UNK_C_PTR_H ; Store ??
    LDA SLOT_EXTRAS+1,X ; Move ?? ptr/?? ??
    STA R_**:$00AE
    LDA SLOT_EXTRAS+2,X
    STA R_**:$00AF
    LDA SLOT_EXTRAS+3,X ; Move ?? single?
    STA SCRIPT_COUNT_UNK
    JMP DEEP_STREAMER_IDFK ; Goto.
MOD_TABLE_UNK: ; [2], 1E:10FD, 0x03D0FD
    .db C0
    .db FF
ROM_DATA_ARR_UNK: ; 1E:10FF, 0x03D0FF
    .db 00 ; 5 byte slots. UNK.
SLOT_EXTRAS: ; [4], 1E:1100, 0x03D100
    .db 00 ; UNK.
    .db 40
    .db 00
    .db 13
    .db 00 ; Slot.
    .db 40
    .db 04
    .db 00
    .db 00
    .db 00 ; Slot.
    .db 40
    .db 10
    .db 00
    .db C0
    .db FF ; Slot.
    .db C0
    .db 03
    .db 40
    .db 00
    .db 13 ; Slot.
    .db 00
    .db C0
    .db FF
    .db 00
    .db 00 ; Slot.
    .db 00
    .db 40
    .db 10
    .db 00
DEEP_STREAMER_IDFK: ; 1E:111D, 0x03D11D
    JSR SETUP_DEEP_STREAM_UNK ; Do ??
LOOP_BEGINNING: ; 1E:1120, 0x03D120
    JSR CREATE_B800_PTR_HELPER ; Create PTR.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    CMP R_**:$0014 ; If _ #$14
    BEQ VALS_EQ ; ==, goto.
    LDA R_**:$0016 ; Load ??
    JMP VAL_SEEDED ; Goto.
VALS_EQ: ; 1E:1132, 0x03D132
    LDA R_**:$0094 ; Load.
    LDX #$06 ; R6.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6 bank.
    CLC ; Prep add.
    LDA SCRIPT_USE_UNK_A ; Load ??
    STA SCRIPT_B800_PTR_UNK[2] ; Store, addr L.
    LDA SCRIPT_USE_UNK_C_PTR_H ; Load ??
    AND #$1F ; Keep lower.
    ADC #$80 ; += 0x8000
    STA SCRIPT_B800_PTR_UNK+1 ; Store, addr H.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    BPL VAL_SEEDED ; Positive, goto.
    JSR ENGINE_HELPER_LOAD_7400_INDEX_A&3F ; Do.
VAL_SEEDED: ; 1E:114F, 0x03D14F
    TAX ; To X index.
    AND #$40 ; Keep bit.
    ASL A ; << 1, *2.
    STA SCRIPT_INVERT_UNK ; Store to.
    LSR A ; >> 2, /4.
    LSR A
    STA B800_PTR_ADDL ; Store to.
    BEQ VAL_EQ_0x00 ; == 0, goto. NOTE: BIT TRICK.
    .db A5 ; LDA $13, Alt A.
    .db 13
    .db 2C ; BIT TRICK past LDA $11, Alt B.
VAL_EQ_0x00: ; 1E:115E, 0x03D15E
    LDA R_**:$0011 ; Load alt.
    STA SCRIPT_B800_PTR_UNK+1 ; Store A decided.
    TXA ; X to A.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; Rotate bits into.
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; 2x
    STA SCRIPT_B800_PTR_UNK[2] ; Store leftover.
    STA STREAM_DEEP_HELPER_UNK[2] ; Also to.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load.
    ADC #$80 ; += 0x80
    ADC B800_PTR_ADDL ; += ??
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    ADC #$10 ; += 0x10
    STA STREAM_DEEP_HELPER_UNK+1 ; Store to.
    LDA SCRIPT_R6_UNK ; Load ??
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom.
    LDX #$06
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set bank.
    LDA SCRIPT_R7_UNK ; Load ??
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom bit.
    LDX #$07 ; Set R7.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R7.
REENTRY_NO_OVERFLOW: ; 1E:118F, 0x03D18F
    LDA SCRIPT_LOADED_SHIFTED_UNK[2] ; Load ??
    LSR A ; >> 2, /4.
    LSR A
    ORA SCRIPT_USE_UNK_B_PTR_L ; Set bits.
    LSR A ; >> 4. nibble down.
    LSR A
    LSR A
    LSR A
    TAX ; To X.
    TAY ; And Y.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM writes.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from WRAM.
    EOR SCRIPT_INVERT_UNK ; Invert bits.
    LDY STREAM_DEEP_INDEX ; Stream index.
    STA [STREAM_UNK_DEEP_A[2]],Y ; Store to stream.
    TXA ; X to Y.
    TAY
    LDA [STREAM_DEEP_HELPER_UNK[2]],Y ; Load from stream.
    AND #$C0 ; Keep upper.
    STA OR_AND_STORE_UNK ; Store to.
    LSR A ; >> 2, /4.
    LSR A
    ORA OR_AND_STORE_UNK ; Set bits.
    LSR A ; >> 2, /4.
    LSR A
    ORA OR_AND_STORE_UNK ; Set bits.
    LSR A ; >> 2, /4.
    LSR A
    ORA OR_AND_STORE_UNK ; Set bits.
    LDY STREAM_DEEP_INDEX ; Load index.
    STA [STREAM_DEEP_B],Y ; Store to stream.
    LDA #$00 ; Clear val.
    STA [STREAM_DEEP_C],Y ; Store val.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable WRAM.
    DEC SCRIPT_COUNT_UNK ; --
    BEQ EXIT_RTS ; ==, goto.
    LDA R_**:$00AE ; Load val mod.
    BEQ MOD_0x00 ; ==, goto.
    INC STREAM_DEEP_INDEX ; ++
    CLC ; Prep add.
    ADC SCRIPT_LOADED_SHIFTED_UNK[2] ; Mod.
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store result.
    BCC JMP_REENTRY_NO_OVERFLOW ; No overflow, goto.
    LDA #$00 ; TODO: Badcode? Does nothing?
    ADC SCRIPT_USE_UNK_A
    STA SCRIPT_USE_UNK_A
    AND #$03 ; Keep lower.
    BNE EXIT_LOOP_BEGINNING ; != 0, goto.
    LDA STREAM_DEEP_INDEX ; Load ??
    SEC ; Prep sub.
    SBC #$10 ; -= 0x10
    STA STREAM_DEEP_INDEX ; Store val.
    LDA STREAM_UNK_DEEP_A+1 ; Load.
    EOR #$01 ; Invert.
    STA STREAM_UNK_DEEP_A+1 ; Store to.
    CLC ; Prep add.
    ADC #$02 ; += 0x2
    STA R_**:$00A5 ; Store to.
    ADC #$02 ; += 0x2
    STA STREAM_DEEP_D? ; Store to.
    JMP LOOP_BEGINNING ; Loop.
MOD_0x00: ; 1E:11F9, 0x03D1F9
    LDX R_**:$00AF ; X from.
    BEQ EXIT_RTS ; == 0, leave.
    CLC ; Prep add.
    LDA STREAM_DEEP_INDEX ; Load.
    ADC #$10 ; += 0x10
    STA STREAM_DEEP_INDEX ; Store result.
    CLC ; Prep add.
    TXA ; X to A.
    ADC SCRIPT_USE_UNK_B_PTR_L ; Mod by X.
    STA SCRIPT_USE_UNK_B_PTR_L ; Store result.
    BCC JMP_REENTRY_NO_OVERFLOW ; No overflow, goto.
    LDA #$00 ; Carry add.
    ADC SCRIPT_USE_UNK_C_PTR_H ; Add.
    STA SCRIPT_USE_UNK_C_PTR_H ; Store result.
    JMP LOOP_BEGINNING ; Loop.
JMP_REENTRY_NO_OVERFLOW: ; 1E:1215, 0x03D215
    JMP REENTRY_NO_OVERFLOW ; Loop.
EXIT_LOOP_BEGINNING: ; 1E:1218, 0x03D218
    JMP LOOP_BEGINNING ; Could have used the other one above for smaller code, hmm. Mistakeish.
EXIT_RTS: ; 1E:121B, 0x03D21B
    RTS ; Leave.
WAIT_UPDATE: ; 1E:121C, 0x03D21C
    LDA NMI_FLAG_EXECUTE_UPDATE_BUF ; Wait on.
    BNE WAIT_UPDATE ; != 0, loop.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI VAL_NEGATIVE ; Val negative, goto.
    AND #$07 ; Keep lower.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    TAX ; To X index.
    LDA DATA_TABLE_UNK,X ; Load ??
    BPL DATA_POSITIVE ; Positive, goto.
VAL_NEGATIVE: ; 1E:122F, 0x03D22F
    LDX #$00 ; Seed ??
    RTS ; Leave.
FLAG_HOLD_WAIT_AND_UPDATES_UNK: ; 1E:1232, 0x03D232
    LDA NMI_FLAG_EXECUTE_UPDATE_BUF
    BNE FLAG_HOLD_WAIT_AND_UPDATES_UNK ; != 0, goto.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI VAL_NEGATIVE ; != 0, goto.
    AND #$07 ; Keep lower.
    ASL A ; << 3, *8.
    ASL A
    ASL A
DATA_POSITIVE: ; 1E:123F, 0x03D23F
    TAX ; To X index.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load ??
    AND #$C0 ; Keep ??
    ADC PTR_MOD_ARR[2],X ; Add with indexed.
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store ??
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Load.
    ADC PTR_MOD_ARR+1,X ; Add with.
    STA SCRIPT_USE_UNK_A ; Store to.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ADC ROM_DATA_UNK[4],X ; Add ??
    STA SCRIPT_USE_UNK_B_PTR_L ; Store to.
    LDA SCRIPT_PAIR_PTR?+1 ; Load.
    ADC ROM_DATA_UNK+1,X ; Carry add.
    STA SCRIPT_USE_UNK_C_PTR_H ; Store to.
    CLC ; Prep add.
    LDA ROM_DATA_UNK+2,X ; Load 0x10
    ADC R_**:$001D ; Mod val.
    BCS SKIP_SUB ; No overflow.
    ADC #$F0 ; -= 0x11
SKIP_SUB: ; 1E:126C, 0x03D26C
    STA R_**:$0099 ; Store ??
    LDA ROM_DATA_UNK,X ; Load ??
    BMI EXIT_ALT_CREATOR ; Negative, goto.
    EOR R_**:$0099 ; Invert with.
    AND #$10 ; Keep bit.
    BNE NO_LOAD_UNK ; != 0,  goto.
    LDA ROM_DATA_UNK+3,X ; Load ??
NO_LOAD_UNK: ; 1E:127C, 0x03D27C
    STA DEEP_STREAM_MOD_UNK ; Store to.
    JMP PACKET_CREATOR_HELPER_ALOT ; Do.
EXIT_ALT_CREATOR: ; 1E:1281, 0x03D281
    JMP PACKET_CREATOR_HELPER_TODO_B ; TODO.
PTR_MOD_ARR: ; [2], 1E:1284, 0x03D284
    .db 00
    .db 00
ROM_DATA_UNK: ; [4], 1E:1286, 0x03D286
    .db 00
    .db 00
    .db 10
    .db F0
ROM_DATA_UNK: ; 1E:128A, 0x03D28A
    .db 10
DATA_TABLE_UNK: ; 1E:128B, 0x03D28B
    .db 88 ; 0x8 byte slots.
    .db 00
    .db 00
    .db 00
    .db 00
    .db 10
    .db F0
    .db 10
    .db 10
    .db 00
    .db 04
    .db 00
    .db 00
    .db 10
    .db 00
    .db FF
    .db 88
    .db 00
    .db 00
    .db 80
    .db 03
    .db F0
    .db 20
    .db 00
    .db 10
    .db 00
    .db 00
    .db 80
    .db 03
    .db F0
    .db 20
    .db 00
    .db 88
    .db 00
    .db 00
    .db 80
    .db 03
    .db F0
    .db 20
    .db 00
    .db 30
    .db 00
    .db 00
    .db 00
    .db 00
    .db 10
    .db 00
    .db FF
    .db 88
    .db 00
    .db 00
    .db 00
    .db 00
    .db 10
    .db F0
    .db 10
    .db 30
PACKET_CREATOR_HELPER_ALOT: ; 1E:12C4, 0x03D2C4
    JSR SCRIPT_R6/R7_PAIRED_AND_STREAMS_UNK ; Do.
    LDA #$11 ; 0x8 * 1 + 0x1
    STA PACKET_UPDATES_COUNT/SCRATCH ; Set result.
    LDX #$00 ; Index.
COUNT_MODDED_LOOP: ; 1E:12CD, 0x03D2CD
    LDA #$05
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Type, 0x5. Unique update.
    STA NMI_PPU_CMD_PACKETS_BUF+42,X ; 2nd packet.
    INX ; Index++
    LDA PACKET_UPDATES_COUNT/SCRATCH ; Load.
    ASL A ; << 1, *2. 2 groups, 2 tiles.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    STA NMI_PPU_CMD_PACKETS_BUF+42,X
    INX ; Index++
    LDA PPU_GROUPED_ADDR_LH+1 ; Move addr H.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    STA NMI_PPU_CMD_PACKETS_BUF+42,X
    INX ; Index++
    LDA PPU_GROUPED_ADDR_LH[2] ; Move addr L.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X
    ORA #$20 ; Always on other.
    STA NMI_PPU_CMD_PACKETS_BUF+42,X
    INX ; Index++
BITS_SET: ; 1E:12F4, 0x03D2F4
    JSR SCRIPT_CREATE_PTR_CHARACTER_WITH_STREAM_INFO? ; Do.
    LDY #$00 ; Stream reset.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from file.
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to update buf.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF+1,X ; Store to update buf.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF+42,X ; Store to update buf higher.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load ??
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF+43,X ; Store to update buf higher.
    INX ; Update buf += 0x2
    INX
    DEC PACKET_UPDATES_COUNT/SCRATCH ; --
    BEQ LOOP_CREATE_METATILES_OVER? ; == 0, goto.
    INC STREAM_DEEP_INDEX ; ++
    LDA STREAM_DEEP_INDEX ; Load.
    BIT BITS_ARBITRARY_TEST_HELPER_BYTE ; Test with.
    BNE BITS_SET ; Bits set, goto.
    SEC ; Prep sub.
    SBC #$10 ; -= 0x10
    STA STREAM_DEEP_INDEX ; Store to.
    LDA STREAM_UNK_DEEP_A+1 ; Load.
    EOR #$01 ; Invert ??
    STA STREAM_UNK_DEEP_A+1 ; Store back.
    LDA PPU_GROUPED_ADDR_LH[2] ; Load ??
    AND #$E0 ; Keep 1110.0000
    STA PPU_GROUPED_ADDR_LH[2] ; Store to, addr L.
    LDA PPU_GROUPED_ADDR_LH+1 ; Load.
    EOR #$04 ; Invert bit.
    STA PPU_GROUPED_ADDR_LH+1 ; Store back.
    SEC ; Prep sub.
    LDA #$11 ; Mod amount, 0x8+0x1
    SBC PACKET_UPDATES_COUNT/SCRATCH ; Sub.
    ASL A ; << 1, *2.
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Store to, addr 
    STA NMI_PPU_CMD_PACKETS_BUF+43
    JMP COUNT_MODDED_LOOP
LOOP_CREATE_METATILES_OVER?: ; 1E:1355, 0x03D355
    LDA #$09
    STA PACKET_UPDATES_COUNT/SCRATCH ; Tile.
    LDX #$54 ; Index.
    LDA #$07 ; Type, many one byte updates across addrs.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to packet.
    INX ; Update buf++
    LDA PACKET_UPDATES_COUNT/SCRATCH ; Load.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Number of one-byte updates to packet.
    INX ; Index++
LOOP_CREATE_ONE_BYTES: ; 1E:1367, 0x03D367
    JSR CREATE_ONE_BYTE_UPDATES_UNK ; Do ??
    DEC PACKET_UPDATES_COUNT/SCRATCH ; --
    BEQ EXIT_RTS ; == 0, leave.
    INC R_**:$008E ; ++
    CLC ; Prep add.
    LDA DEEP_BASE_UNK ; Load, addr L.
    ADC #$02 ; += 0x2
    STA DEEP_BASE_UNK ; Store back.
    BIT BITS_ARBITRARY_TEST_HELPER_BYTE ; Test bits.
    BNE LOOP_CREATE_ONE_BYTES ; != 0, loop.
    SEC ; Prep sub.
    SBC #$10 ; Sub with.
    STA DEEP_BASE_UNK ; Store back.
    LDA R_**:$00A5 ; Load ??
    EOR #$01 ; Invert bit.
    STA R_**:$00A5 ; Store back.
    SEC ; Prep sub.
    LDA R_**:$008E ; Load ??
    SBC #$08 ; -= 0x8
    STA R_**:$008E ; Store back.
    LDA R_**:$008F ; Load ??
    EOR #$04 ; Invert ??
    STA R_**:$008F ; Store result.
    JMP LOOP_CREATE_ONE_BYTES ; Loop.
EXIT_RTS: ; 1E:1397, 0x03D397
    RTS ; Leave.
PACKET_CREATOR_HELPER_TODO_B: ; 1E:1398, 0x03D398
    JSR SCRIPT_R6/R7_PAIRED_AND_STREAMS_UNK ; Banks setup.
    SEC ; Prep sub.
    LDA #$F0 ; Diff of 0x10.
    SBC R_**:$0099 ; Sub with.
    CLC ; Prep add.
    ADC STREAM_DEEP_INDEX ; Add with.
    STA STREAM_DEEP_INDEX ; Store result.
    LDA #$0F
    STA PACKET_UPDATES_COUNT/SCRATCH ; Set packet attr, count.
    LDX #$00 ; Index init.
    LDA #$06 ; Type. VRAM+32 mode.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; 2x packets.
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX ; Index++
    LDA PACKET_UPDATES_COUNT/SCRATCH ; Load count.
    ASL A ; << 1, *2.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX ; Index++
    LDA PPU_GROUPED_ADDR_LH+1 ; Load.
    AND #$FC ; Keep 111.1100
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to, addr.
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX
    LDA PPU_GROUPED_ADDR_LH[2] ; Load.
    AND #$1E ; Keep 0001.1110
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to, addr.
    ORA #$01 ; Set 0x1.
    STA NMI_PPU_CMD_PACKETS_BUF+34,X ; Store to, addr pair for column.
    INX ; Index++
    LDA R_**:$0099 ; Move ??
    STA PPU_GROUPED_ADDR_LH[2]
LOOP_CREATION : ; 1E:13DA, 0x03D3DA
    LDA PPU_GROUPED_ADDR_LH[2] ; Load.
    SEC ; -= 0x10
    SBC #$10
    STA PPU_GROUPED_ADDR_LH[2] ; Store back.
    BCS SUB_NO_UNDERFLOW ; No underflow, goto.
    LDA STREAM_DEEP_INDEX ; -= 0x10 carry.
    ADC #$10
    STA STREAM_DEEP_INDEX
SUB_NO_UNDERFLOW: ; 1E:13E9, 0x03D3E9
    JSR SCRIPT_CREATE_PTR_CHARACTER_WITH_STREAM_INFO? ; Figure.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from file.
    AND #$3F ; Keep 0011.1111
    EOR SCRIPT_INVERT_UNK ; Invert with.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to. Address.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep 0011.1111
    EOR SCRIPT_INVERT_UNK ; Invert with.
    STA NMI_PPU_CMD_PACKETS_BUF+34,X ; Store to alt buf.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep 0011.1111
    EOR SCRIPT_INVERT_UNK ; Invert with.
    STA NMI_PPU_CMD_PACKETS_BUF+1,X ; Store to buf.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep 0011.1111
    EOR SCRIPT_INVERT_UNK ; Invert with.
    STA NMI_PPU_CMD_PACKETS_BUF+35,X ; Store to alt buf.
    INX ; Index += 2
    INX
    DEC PACKET_UPDATES_COUNT/SCRATCH ; --
    BEQ COUNT_EQ_0x00 ; == 0, goto.
    CLC ; Prep add.
    LDA STREAM_DEEP_INDEX ; Load.
    ADC #$10 ; += 0x10
    STA STREAM_DEEP_INDEX ; Store back.
    JMP LOOP_CREATION  ; Loop up.
COUNT_EQ_0x00: ; 1E:1425, 0x03D425
    LDA #$08
    STA PACKET_UPDATES_COUNT/SCRATCH ; Set count.
    LDX #$44 ; Index.
    LDA #$07 ; Type, bulk update byte with addr.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store type.
    INX ; Index++
    LDA PACKET_UPDATES_COUNT/SCRATCH ; Load.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store.
    INX ; Index++
    LDA R_**:$0099 ; Load val.
    AND #$10 ; Keep bit.
    BEQ MOD_ALONE_UNK ; Clear, goto.
    SEC ; Prep sub.
    LDA DEEP_BASE_UNK ; Load val.
    PHA ; Save it.
    SBC #$10 ; -= 0x10
    STA DEEP_BASE_UNK ; Store result.
    LDA #$20
    STA DEEP_STREAM_MOD_UNK ; Set ??
    JSR CREATE_ONE_BYTE_UPDATES_UNK ; Create.
    PLA ; Pull value.
    STA DEEP_BASE_UNK ; Replace.
    LDA #$10
    STA DEEP_STREAM_MOD_UNK ; Set ??
    BNE EXTRA_SUB_USED ; Always taken.
MOD_ALONE_UNK: ; 1E:1455, 0x03D455
    LDA #$10
    STA DEEP_STREAM_MOD_UNK ; Set ??
ONE_BYTE_UPDATES_SUB_RUN: ; 1E:1459, 0x03D459
    JSR CREATE_ONE_BYTE_UPDATES_UNK ; Do updates.
EXTRA_SUB_USED: ; 1E:145C, 0x03D45C
    DEC PACKET_UPDATES_COUNT/SCRATCH ; --
    BEQ RTS ; == 0, goto.
    CLC ; Prep add.
    LDA DEEP_BASE_UNK ; Load ??
    ADC #$20 ; Add with.
    STA DEEP_BASE_UNK ; Store to.
    CLC ; Prep add.
    LDA R_**:$008E ; Load ??
    ADC #$08 ; += 0x8
    STA R_**:$008E ; Store result.
    BCC ONE_BYTE_UPDATES_SUB_RUN ; No overflow, loop.
    SBC #$40 ; -= 0x40
    STA R_**:$008E ; Store result.
    SEC ; Prep sub.
    LDA DEEP_BASE_UNK ; Load ??
    SBC #$10 ; -= 0x10
    STA DEEP_BASE_UNK ; Store result.
    JMP ONE_BYTE_UPDATES_SUB_RUN ; Loop one bytes.
RTS: ; 1E:147E, 0x03D47E
    RTS ; Leave.
BITS_ARBITRARY_TEST_HELPER_BYTE: ; 1E:147F, 0x03D47F
    .db 0F
CREATE_ONE_BYTE_UPDATES_UNK: ; 1E:1480, 0x03D480
    LDA R_**:$008F ; Load ??
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store, addr H.
    INX ; Index++
    LDA R_**:$008E ; Load ??
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store as addr L.
    INX ; Index++
    LDY DEEP_BASE_UNK ; Load stream index.
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$03 ; Keep lower.
    STA OR_AND_STORE_UNK ; Store to.
    INY ; Stream++
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$0C ; Keep lower.
    ORA OR_AND_STORE_UNK ; Set with other.
    STA OR_AND_STORE_UNK ; Store to.
    CLC ; Prep add.
    LDA DEEP_BASE_UNK ; Load ??
    ADC DEEP_STREAM_MOD_UNK ; Add with ??
    TAY ; To Y index.
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$30 ; Keep 0011.0000
    ORA OR_AND_STORE_UNK ; Or with.
    STA OR_AND_STORE_UNK ; Store to.
    INY ; Stream++
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$C0 ; Keep upper.
    ORA OR_AND_STORE_UNK ; Set with others.
    STA NMI_PPU_CMD_PACKETS_BUF[69],X ; Store to buf, update data/tile.
    INX ; Index++
    RTS ; Leave.
SCRIPT_R6/R7_PAIRED_AND_STREAMS_UNK: ; 1E:14B7, 0x03D4B7
    LDA SCRIPT_R6_UNK ; Load.
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom.
    LDX #$06 ; Set as R6.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Bank.
    LDA SCRIPT_R7_UNK ; Load.
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom.
    LDX #$07 ; Set as R7.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Bank it.
    JSR SETUP_DEEP_STREAM_UNK ; Do ??
    LDA SCRIPT_USE_UNK_A ; Load.
    AND #$07 ; Keep bottom.
    STA R_**:$009A ; Store to.
    LDA SCRIPT_LOADED_SHIFTED_UNK[2] ; Load.
    LSR R_**:$009A ; Shift ??
    ROR A ; Into A.
    LSR R_**:$009A ; 2x
    ROR A
    STA R_**:$0098 ; Store built to.
    LDA R_**:$0099 ; Load ??
    EOR STREAM_DEEP_INDEX ; Invert.
    AND #$10 ; Keep.
    BNE BIT_0x10_SET ; != 0, set, goto.
    LDA STREAM_DEEP_INDEX ; Load ??
    AND #$EE ; Keep 1110.1110
    JMP 0xEE_ANDED_SEEDED ; Goto.
BIT_0x10_SET: ; 1E:14ED, 0x03D4ED
    SEC ; Prep sub.
    LDA STREAM_DEEP_INDEX ; Load ??
    SBC #$10 ; Sub upper.
    ORA #$10 ; Set it.
    AND #$FE ; Keep 1111.1110
0xEE_ANDED_SEEDED: ; 1E:14F6, 0x03D4F6
    BIT DEEP_STREAM_MOD_UNK ; Test ??
    BPL TEST_POSITIVE ; Positive, goto.
    LDX #$20
    STX DEEP_STREAM_MOD_UNK ; Set 0x20
    SEC ; Prep sub.
    SBC #$10 ; Sub ??
TEST_POSITIVE: ; 1E:1501, 0x03D501
    STA DEEP_BASE_UNK ; Store ??
    LDA R_**:$0099 ; Load.
    AND #$F0 ; Keep upper.
    STA PPU_GROUPED_ADDR_LH[2] ; Store to.
    LDA R_**:$009A ; Load.
    ASL PPU_GROUPED_ADDR_LH[2] ; Shift ??
    ROL A ; Into A.
    ASL PPU_GROUPED_ADDR_LH[2] ; 2x
    ROL A
    ORA #$20 ; Set ??
    STA PPU_GROUPED_ADDR_LH+1 ; Store to.
    ORA #$03 ; Set ??
    STA R_**:$008F ; Store to.
    LDA R_**:$0098 ; Load ??
    AND #$F0 ; Keep upper.
    LSR A ; >> 3, /8.
    LSR A
    LSR A
    ORA PPU_GROUPED_ADDR_LH[2] ; Set ??
    STA PPU_GROUPED_ADDR_LH[2] ; Store back to.
    LSR A ; >> 2, /4.
    LSR A
    AND #$07 ; Keep lower.
    STA R_**:$008E ; Store to.
    LDA R_**:$0099 ; Load ??
    LSR A ; >> 2, /4.
    LSR A
    AND #$38 ; Keep 0011.1000
    ORA #$C0 ; Set ??
    ORA R_**:$008E ; Set ??
    STA R_**:$008E ; Store result.
    RTS ; Leave.
SCRIPT_CREATE_PTR_CHARACTER_WITH_STREAM_INFO?: ; 1E:1537, 0x03D537
    LDY STREAM_DEEP_INDEX ; Load from stream. FMT $1E:1537
    LDA [STREAM_UNK_DEEP_A[2]],Y ; Load DB.
    AND #$80 ; Keep upper.
    LSR A ; >> 1, /2.
    STA SCRIPT_INVERT_UNK ; Store to.
    LSR A ; >> 1, /2.
    STA B800_PTR_ADDL ; Store 0x40/0x00.
    BEQ BIT_WAS_CLEAR ; == 0, goto.
    LDA R_**:$0013 ; Val alt for A set.
    .db 2C ; NOTE: Bit trick around alt load.
BIT_WAS_CLEAR: ; 1E:1548, 0x03D548
    LDA R_**:$0011 ; Load A clear val.
    STA SCRIPT_B800_PTR_UNK+1 ; Store to, addr H.
    LDA [STREAM_UNK_DEEP_A[2]],Y ; Load DB.
    ASL A ; << 2, *4. 0x40 -> Carry. Adds 0x01 to ADDR H.
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; Rotate into ADDR H.
    STA SCRIPT_B800_PTR_UNK[2] ; Store val to, addr L.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load ADDR H.
    ADC #$90 ; += 0x90, base addr.
    ADC B800_PTR_ADDL ; Add offset.
    STA SCRIPT_B800_PTR_UNK+1 ; Store to, PTR L.
    RTS ; Leave.
SETUP_DEEP_STREAM_UNK: ; 1E:155D, 0x03D55D
    LDA SCRIPT_USE_UNK_A ; Load.
    AND #$07 ; Keep 0000.0111
    STA STREAM_UNK_DEEP_A+1 ; Store to.
    LDA SCRIPT_LOADED_SHIFTED_UNK[2] ; Load.
    LSR STREAM_UNK_DEEP_A+1 ; >> 1
    ROR A ; Rotate into A.
    LSR STREAM_UNK_DEEP_A+1 ; >> 1
    ROR A ; Rotate into A.
    LSR A ; >> 2, /4.
    LSR A
    ORA SCRIPT_USE_UNK_B_PTR_L ; Set other bits.
    STA STREAM_DEEP_INDEX ; Store result.
    LDA SCRIPT_USE_UNK_C_PTR_H ; Load val.
    LSR A ; Shift off bit.
    ROR STREAM_DEEP_INDEX ; Rotate into.
    LSR A ; 2x
    ROR STREAM_DEEP_INDEX
    LDA #$00
    STA STREAM_UNK_DEEP_A[2] ; Clear ADDR L.
    STA STREAM_DEEP_B
    STA STREAM_DEEP_C
    LDA STREAM_UNK_DEEP_A+1 ; Load addr H.
    CLC ; Prep add.
    ADC #$60 ; += 0x60, $6X00 ptr.
    STA STREAM_UNK_DEEP_A+1 ; Store back.
    ADC #$02 ; += 0x2.
    STA R_**:$00A5 ; Store to.
    ADC #$02 ; += 0x2.
    STA STREAM_DEEP_D? ; Store to.
    RTS ; Leave.
R7/B800_SET/INIT_UNK: ; 1E:1591, 0x03D591
    JSR CREATE_B800_PTR_HELPER ; Do ??
    LDY #$00
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from ptr.
    AND #$3F
    STA R_**:$0014 ; Set ??
    RTS ; Leave.
CREATE_B800_PTR_HELPER: ; 1E:159D, 0x03D59D
    LDA SCRIPT_USE_UNK_C_PTR_H ; Load.
    LSR A ; Shift nibble down.
    LSR A
    LSR A
    LSR A
    AND #$0E ; Keep 0000.1110
    STA R_**:$0094 ; Store to.
    ORA #$01 ; Set bit.
    LDX #$07 ; Set R7.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Bank R7 in.
    LDA SCRIPT_USE_UNK_C_PTR_H ; Load.
    LSR A ; >> 2, /4.
    LSR A
    AND #$07 ; Keep lower.
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    LDA SCRIPT_USE_UNK_A ; Load.
    AND #$FC ; Keep 1111.1100
    CLC ; Prep add.
    STA SCRIPT_B800_PTR_UNK[2] ; Store to, ptr L.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load.
    ADC #$B8 ; Add 0xB8
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    RTS ; Leave.
SCRIPT_SET_GFX: ; 1E:15C4, 0x03D5C4
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Load.
    ADC #$02 ; += 0x2
    STA SCRIPT_USE_UNK_A ; Store to.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load.
    ADC #$C0 ; Add with.
    STA SCRIPT_USE_UNK_B_PTR_L ; Store to.
    LDA SCRIPT_PAIR_PTR?+1 ; Load.
    ADC #$01 ; Add with.
    STA SCRIPT_USE_UNK_C_PTR_H ; Store to.
    JSR CREATE_B800_PTR_HELPER ; Make PTR.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from PTR.
    AND #$3F ; Keep lower.
    CMP R_**:$0014 ; If _ #$14
    BEQ SET_MULTIPLE? ; ==, goto.
    LDA R_**:$0017 ; Load.
    LDX #$03 ; Gfx bank R3.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX.
    STA SCRIPT_R7_UNK ; Store val to.
    AND #$03 ; Keep lower.
    STA R_**:$0013 ; Store to.
    RTS ; Leave.
SET_MULTIPLE?: ; 1E:15F3, 0x03D5F3
    LDA FLAG_UNK_23 ; Load.
    BEQ VAL_ZERO ; == 0, goto.
    BPL VAL_POSITIVE ; Positive, goto.
    AND #$7F ; Keep lower.
    STA FLAG_UNK_23 ; Store val to.
    BPL GFX_BANK_R2_SET ; Positive, goto. Always taken.
VAL_ZERO: ; 1E:15FF, 0x03D5FF
    LDY #$01 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load ??
    AND #$3F ; Keep lower.
    STA SCRIPT_R6_ROUTINE_SELECT ; Store to.
    TAX ; To X index.
    LDA LUT_GFX_BANKS_R1,X ; Load index.
    BEQ GFX_BANK_R2_SET ; == 0, skip R1 set.
VAL_POSITIVE: ; 1E:160D, 0x03D60D
    LDX #$01 ; R1 seed.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX bank.
GFX_BANK_R2_SET: ; 1E:1612, 0x03D612
    LDY #$02 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    LDX #$02 ; R2 seed.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX.
    STA SCRIPT_R6_UNK ; Store val to.
    AND #$03 ; Keep lower.
    STA R_**:$0011 ; Store to.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    LDX #$03 ; R3 mod here.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX.
    STA SCRIPT_R7_UNK ; Store to.
    AND #$03 ; Keep lower.
    STA R_**:$0013 ; Store to.
    RTS ; Leave.
LUT_GFX_BANKS_R1: ; 1E:1634, 0x03D634
    .db 00 ; 0x00 = No mod ??
    .db 68
    .db 62
    .db 62
    .db 62
    .db 62
    .db 64
    .db 62
    .db 74
    .db 64
    .db 6A
    .db 62
    .db 66
    .db 6C
    .db 62
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 66
    .db 00
    .db 6A
    .db 66
    .db 62
    .db 68
    .db 64
    .db 68
    .db 6E
    .db 66
    .db 66
    .db 66
    .db 62
    .db 62
    .db 62
    .db 66
    .db 64
    .db 6E
    .db 62
    .db 64
    .db 66
    .db 74
    .db 6C
    .db 66
    .db 00
    .db 00
    .db 68
    .db 6C
    .db 72
    .db 00
    .db 66
    .db 00
    .db 00
    .db 00
    .db 6A
    .db 00
    .db 6C
    .db 6E
    .db 6C
    .db 6E
    .db 6C
    .db 6E
    .db 6E
    .db 00
HUGE_ASS_STREAMS_THINGY_IDFK: ; 1E:1674, 0x03D674
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Load flag.
    BPL SETUP_POSITIVE ; Positive, goto.
    AND #$0F ; Keep lower.
    STA ROUTINE_SWITCH_UNK ; Store to.
    LDA R_**:$6784 ; Load ??
    AND #$C0 ; Keep 1100.0000
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store to.
    LDA R_**:$6785 ; Move ??
    STA SCRIPT_USE_UNK_A
    LDA WRAM_SPECIAL_A? ; Load.
    AND #$C0 ; Keep 1100.0000
    STA SCRIPT_USE_UNK_B_PTR_L ; Store 1100.0000
    LDA WRAM_SPECIAL_B? ; Move ??
    STA SCRIPT_USE_UNK_C_PTR_H
    JMP SETUP_NEG_COMPLETED
SETUP_POSITIVE: ; 1E:1697, 0x03D697
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load.
    AND #$3F ; Keep lower.
    STA ROUTINE_SWITCH_UNK ; Store to.
    CLC ; Prep add ?
    LDA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Load.
    AND #$C0 ; Keep 1100.0000
    STA SCRIPT_PAIR_PTR_B_SEED?[2] ; Store to.
    ADC #$00 ; Carry add. (+0?)
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store to.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+5 ; Move val.
    STA SCRIPT_PAIR_PTR_B_SEED?+1
    ADC #$02 ; += 0x2
    STA SCRIPT_USE_UNK_A ; Store to.
    CLC ; Prep add.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load.
    AND #$C0 ; Keep bits 1100.0000
    STA SCRIPT_PAIR_PTR?[2] ; Store to.
    ADC #$C0 ; += 0xC0
    STA SCRIPT_USE_UNK_B_PTR_L ; Store to.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+7 ; Move ??
    STA SCRIPT_PAIR_PTR?+1
    ADC #$01 ; += 0x1 + C
    STA SCRIPT_USE_UNK_C_PTR_H ; Store to.
    JSR R7/B800_SET/INIT_UNK ; Do ??
SETUP_NEG_COMPLETED: ; 1E:16CB, 0x03D6CB
    JSR SETUP_DEEP_STREAM_UNK ; Do ??
    JSR SETUP_PTR_6780_UNK ; Setup ??
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable with writes.
    LDA FLAG_UNK_23 ; Load ??
    BNE NONZERO_ALT ; != 0, do alt.
    LDX #$00 ; Load index.
X_LOOP_TO_TARGET: ; 1E:16DA, 0x03D6DA
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load indexes.
    BEQ SKIP_UNK ; == 0, goto.
    JSR MOVE_TO_STREAM_UNK_WITH_MOD ; Move a bit.
    LDY #$19 ; Seed stream index.
    LDA #$88 ; Val ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to ptr.
    LDA #$0C ; Seed ??
    CPX #$00 ; If _ #$00
    BNE SKIP_UNK ; X != 0, goto.
    LDY #$1C ; Stream index set.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
SKIP_UNK: ; 1E:16F2, 0x03D6F2
    LDY #$00 ; Reset stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Load flag.
    AND #$C0 ; Keep 1100.0000
    BEQ TOP_0x00_ALT ; == 0, goto.
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do mod.
    INX ; X++
    CPX #$04 ; If _ #$04
    BCC X_LOOP_TO_TARGET ; <, goto.
ALT_REENTRY: ; 1E:1704, 0x03D704
    LDA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Load.
    AND #$3F ; Keep lower.
    BEQ VAL_EQ_0x00_CLOSE ; == 0, goto.
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Do with val.
VAL_EQ_0x00_CLOSE: ; 1E:170E, 0x03D70E
    LDA #$00
    STA FIRST_LAUNCHER_HOLD_FLAG? ; Clear flag.
    LDA SCRIPT_FLAG_0x22_AUTO_MOVE ; Load.
    AND #$CF ; Keep 1100.1111
    STA SCRIPT_FLAG_0x22_AUTO_MOVE ; Store back.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Goto, disable WRAM and leave.
NONZERO_ALT: ; 1E:171B, 0x03D71B
    JSR MOVE_TO_STREAM_UNK ; Do ??
    LDY #$00 ; Stream reset.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    CMP #$0D ; If _ #$0D
    BNE VAL_NONZERO ; != 0, goto.
    JSR MOD_STREAM_LUT_UNK ; Do ??
    LDY #$19 ; Stream index.
    LDA ROUTINE_SWITCH_UNK ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    EOR #$04 ; Invert bit.
    STA ROUTINE_SWITCH_UNK ; Store val.
    JSR MOVE_TO_STREAM_UNK ; Do.
VAL_NONZERO: ; 1E:1738, 0x03D738
    JMP ALT_REENTRY ; Goto, abuse RTS.
TOP_0x00_ALT: ; 1E:173B, 0x03D73B
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; Load.
    BEQ ALT_ZERO_B ; == 0, goto.
    JSR STREAMS_MOD_UNK ; Do ??
    BCC RET_CC_UNK ; Ret CC, goto. Always taken.
ALT_ZERO_B: ; 1E:1745, 0x03D745
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM writes.
    LDY #$00 ; Stream index.
    LDA #$00 ; Value.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Clear it.
RET_CC_UNK: ; 1E:1751, 0x03D751
    INX ; X++
    CPX #$03 ; If _ #$03
    BCC TOP_0x00_ALT ; <, goto.
    JMP ALT_REENTRY ; Reenter.
SUB_INDEX_HELPER_UNK: ; 1E:1759, 0x03D759
    PHA ; Save A.
    LDX #$00 ; Index.
VAL_LT_0x3: ; 1E:175C, 0x03D75C
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; Load in save.
    BEQ VAL_EQ_0x00 ; == 0, goto.
    INX ; Index++
    CPX #$03 ; If _ #$03
    BCC VAL_LT_0x3 ; <, goto.
    PLA ; Pull A.
    RTS ; Leave.
STREAMS_MOD_UNK: ; 1E:1768, 0x03D768
    PHA ; Save A.
VAL_EQ_0x00: ; 1E:1769, 0x03D769
    TXA ; Save X.
    PHA
    JSR ENGINE_CRAFT_MAP_OBJ_RESERVATION_PTR ; Create.
    JSR MOD_STREAM_LUT_UNK ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM.
    PLA ; Pull A/X passed.
    TAX
    PLA
    STA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; A to X index.
    JSR MOVE_TO_STREAM_UNK_WITH_MOD ; Do with init.
    LDY #$19 ; Stream index.
    LDA ROUTINE_SWITCH_UNK ; Load ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    LDY #$00 ; Stream index.
    LDA #$0C ; Val ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    CLC ; Set to known state for branch after this routine call?
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Leave.
COMAPRE_IDFK: ; 1E:178D, 0x03D78D
    LDX #$00 ; Reset index.
INDEX_LT_0x4: ; 1E:178F, 0x03D78F
    CMP CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Compared passed to.
    BEQ PASSED_MATCH ; ==, goto.
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC INDEX_LT_0x4 ; <, goto.
    RTS ; Leave, CS.
PASSED_MATCH: ; 1E:179A, 0x03D79A
    JSR ENGINE_WRAM_STATE_WRITEABLE ; WRAM writeable.
LOOPY: ; 1E:179D, 0x03D79D
    CPX #$03 ; If _ #$03
    BCS CLEAR_SLOT_IDFK ; >=, goto.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; Load ??
    BEQ STORE_SLOT ; == 0, goto.
    STA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Move slot down.
    INX ; X++
    BCC LOOPY ; Always taken.
CLEAR_SLOT_IDFK: ; 1E:17AC, 0x03D7AC
    LDA #$00 ; Clear.
STORE_SLOT: ; 1E:17AE, 0x03D7AE
    STA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Store.
    TXA ; Slot to A.
    JSR ENGINE_CRAFT_MAP_OBJ_RESERVATION_PTR ; Make ptr.
    JSR LIB_STREAM_SETUP_UNK ; Do ??
    JSR SETUP_PTR_6780_UNK
    LDX #$00 ; Index reset.
INDEX_LT_0x4_B: ; 1E:17BD, 0x03D7BD
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load.
    BEQ VAL_EQ_0x00 ; == 0, goto.
    JSR STREAM_TO_STREAM_MOD/MOVE_UNK ; Do ??
    LDA #$0C ; Val ??
    CPX #$00 ; If _ #$00
    BNE VAL_EQ_0x00 ; !=, goto.
    LDY #$1C ; First slot, stream 0x1C ??
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load data.
VAL_EQ_0x00: ; 1E:17CF, 0x03D7CF
    LDY #$00 ; Reset stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do ??
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC INDEX_LT_0x4_B ; <, goto.
    CLC ; Ret CC.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable and leave.
MOVE_TO_STREAM_UNK_WITH_MOD: ; 1E:17DF, 0x03D7DF
    JSR STREAM_TO_STREAM_MOD/MOVE_UNK ; Do ??
MOVE_TO_STREAM_UNK: ; 1E:17E2, 0x03D7E2
    LDY #$04 ; Stream index.
    LDA SCRIPT_LOADED_SHIFTED_UNK[2] ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA SCRIPT_USE_UNK_A ; Load ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$06 ; Stream reset.
    LDA SCRIPT_USE_UNK_B_PTR_L ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA SCRIPT_USE_UNK_C_PTR_H ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$11 ; Stream reset.
    LDA STREAM_DEEP_INDEX ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA STREAM_DEEP_C ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA STREAM_DEEP_D? ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDA ROUTINE_SWITCH_UNK ; Load ??
    LDY #$15 ; Stream set.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    LDY #$1D ; Stream set.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    RTS ; Leave.
STREAM_TO_STREAM_MOD/MOVE_UNK: ; 1E:1813, 0x03D813
    LDY #$02 ; Seed stream index.
    AND #$07 ; Keep lower bits.
    STA R6_BANKED_ADDR_MOVED+1 ; Store to.
    LDA #$00 ; Clear val.
    LSR R6_BANKED_ADDR_MOVED+1 ; Rotate bit off.
    ROR A ; Rotate into A.
    LSR R6_BANKED_ADDR_MOVED+1 ; Rotate bit off.
    ROR A ; Into A.
    STA R6_BANKED_ADDR_MOVED[2] ; Store val to, addr L.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream indexed.
    INY ; Stream++
    LDA R6_BANKED_ADDR_MOVED+1 ; Load addr H.
    ADC #$74 ; += 0x74, $7400 base.
    STA R6_BANKED_ADDR_MOVED+1 ; Store to R6 ptr.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to stream.
    LDY #$1D ; Seed stream val.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream made.
    LDY #$14 ; Seed stream val.
    PHA ; Save loaded.
    AND #$F0 ; Keep upper.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to other stream ptr.
    LDY #$08 ; Seed stream index.
    PLA ; Pull original loaded.
    AND #$0F ; Keep lower.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to other stream ptr.
LIB_FPTR_SPECIFIC_MOVE_UNK: ; 1E:1840, 0x03D840
    LDY #$1E ; Reseed stream.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from.
    LDY #$16 ; Reseed stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to.
    LDY #$1F ; Reseed stream.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from.
    LDY #$17 ; Reseed.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to.
    CLC ; Prep ret CC and add later.
    LDY #$01 ; Reseed stream.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from.
    BPL RET_CC ; Positive, goto.
    AND #$80 ; Keep only the negative flag.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store 0x80.
    LDY #$16 ; Reseed stream.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from.
    ADC #$A0 ; += 0xA0
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store back.
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    ADC #$00 ; Carry add.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store back.
    SEC ; Ret CS.
RET_CC: ; 1E:186B, 0x03D86B
    RTS ; Leave.
ENGINE_CRAFT_MAP_OBJ_RESERVATION_PTR: ; 1E:186C, 0x03D86C
    STA ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; A to.
    LDA #$00 ; Clear bits for shift.
    LSR ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; Rotate bits from into A.
    ROR A
    LSR ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; 2x
    ROR A
    LSR ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; 3x
    ROR A
    ADC #$80 ; += 0x80, stride 0x40
    STA ENGINE_MAP_OBJ_RESERVATIONS/??[2] ; Store to addr L, stride 0x20.
    LDA ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; Load what is left.
    ADC #$67 ; += 0x67, ptr H mod.
    STA ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; Store addr H. Stride 1 range 0x20.
    RTS ; Leave.
MOD_STREAM_LUT_UNK: ; 1E:1884, 0x03D884
    LDY #$15 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    STA ROUTINE_SWITCH_UNK ; Store to.
    EOR #$04 ; Invert bit.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    TAX ; To X index.
    LDY #$04 ; Val ??
    CLC ; Prep add.
    LDA LUT_MOD_ARRAY_MOVEMENT?[4],X ; Load mod.
    ADC [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Mod val at stream.
    STA SCRIPT_LOADED_SHIFTED_UNK[2] ; Store to.
    INY ; Stream++
    LDA LUT_MOD_ARRAY_MOVEMENT?+1,X ; Load mod.
    ADC [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Mod with carry.
    STA SCRIPT_USE_UNK_A ; Store to.
    LDY #$06 ; Stream mod.
    CLC ; Prep add.
    LDA LUT_MOD_ARRAY_MOVEMENT?+2,X ; Load mod.
    ADC [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Mod val at stream.
    STA SCRIPT_USE_UNK_B_PTR_L ; Store to.
    INY ; Stream++
    LDA LUT_MOD_ARRAY_MOVEMENT?+3,X ; Load ??
    ADC [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Mod with carry.
    STA SCRIPT_USE_UNK_C_PTR_H ; Store to.
    JSR SETUP_DEEP_STREAM_UNK ; Setup ??
    JMP ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do mod, leave.
LIB_FPTR_AND_MOVE_HELPER: ; 1E:18BA, 0x03D8BA
    JSR ENGINE_CRAFT_MAP_OBJ_RESERVATION_PTR ; Do PTR for space.
    LDY #$02 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Move ptr.
    STA R6_BANKED_ADDR_MOVED[2]
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Addr H.
    STA R6_BANKED_ADDR_MOVED+1
    RTS ; Leave.
LIB_SPECIAL_CHECKS_WITH_CMPS_UNK: ; 1E:18C9, 0x03D8C9
    LDA #$07 ; If_ #$07
    JSR COMAPRE_IDFK ; Compare.
    LDA #$06 ; If _ #$06
    JMP COMAPRE_IDFK ; Compare.
LIB_SPECIAL_CHECKS_UNK: ; 1E:18D3, 0x03D8D3
    LDA CURRENT_SAVE_MANIPULATION_PAGE+385 ; Load ??
    BPL POSITIVE_VAL ; Positive, goto.
    LDA #$06 ; Val ??
    JSR COMAPRE_IDFK ; Do a bit, slotty.
POSITIVE_VAL: ; 1E:18DD, 0x03D8DD
    LDA CURRENT_SAVE_MANIPULATION_PAGE+449 ; Load ??
    BPL VAL_POSITIVE ; Positive, goto.
    LDA #$07 ; Val ??
    JSR COMAPRE_IDFK ; Do.
VAL_POSITIVE: ; 1E:18E7, 0x03D8E7
    LDX #$00
    STX SLOT/DATA_OFFSET_USE? ; Set slot.
VAL_LT_0x4: ; 1E:18EB, 0x03D8EB
    JSR TEST_SAVE_INDEX_X_CC_0x1-0x5 ; Do ??
    BCS RET_CS ; CS, goto.
    TXA ; X to A.
    JSR LIB_FPTR_AND_MOVE_HELPER ; Do ??
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM.
    JSR LIB_FPTR_SPECIFIC_MOVE_UNK ; Do ??
    BCS RET_CS ; CS, goto.
    INC SLOT/DATA_OFFSET_USE? ; ++
RET_CS: ; 1E:18FE, 0x03D8FE
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; No more WRAM.
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC VAL_LT_0x4 ; <, goto.
RET_CS: ; 1E:1906, 0x03D906
    STX SAVE_ID_FOCUS ; X to.
    LDA SLOT/DATA_OFFSET_USE? ; Load ??
    BEQ LOADED_ZERO ; == 0, goto.
    CLC ; Ret CC.
    RTS
LOADED_ZERO: ; 1E:190E, 0x03D90E
    JSR LIB_SPECIAL_CHECKS_WITH_CMPS_UNK ; Do ??
    JSR ENGINE_WRAM_STATE_WRITEABLE ; WRAM again.
    LDA #$00
    STA CURRENT_SAVE_MANIPULATION_PAGE+65 ; Clear specific.
    STA CURRENT_SAVE_MANIPULATION_PAGE+86
    STA CURRENT_SAVE_MANIPULATION_PAGE+87
    LDA CURRENT_SAVE_MANIPULATION_PAGE+67 ; Move ??
    STA CURRENT_SAVE_MANIPULATION_PAGE+84
    LDA CURRENT_SAVE_MANIPULATION_PAGE+68 ; Move ??
    STA CURRENT_SAVE_MANIPULATION_PAGE+85
    LDA CURRENT_SAVE_MANIPULATION_PAGE+16 ; Load ??
    LSR CURRENT_SAVE_MANIPULATION_PAGE+17 ; Carry from.
    ROR A ; Rotate A.
    ADC #$00 ; Add 0x00/0x01
    STA CURRENT_SAVE_MANIPULATION_PAGE+16 ; Store to.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+17 ; Load ??
    ADC #$00 ; Carry add.
    STA CURRENT_SAVE_MANIPULATION_PAGE+17 ; Store result.
    LDA #$01
    STA SLOT/DATA_OFFSET_USE? ; Set ??
    LDA #$00
    STA MAIN_FLAG_UNK ; Clear flag.
    STA FLAG_UNK_23 ; Clear ??
    LDX STREAM_REPLACE_COUNT? ; Index ??
    LDY Y_INDEXES_UNK,X ; Load index from X.
    LDX #$03 ; Count 4
COUNT_POSITIVE: ; 1E:1950, 0x03D950
    LDA DATA_WRITING_UNK,Y ; Load from index.
    STA CURRENT_SAVE_MANIPULATION_PAGE+4,X ; Set ??
    DEY ; Y--
    DEX ; Count--
    BPL COUNT_POSITIVE ; Positive, goto.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load ??
    AND #$0F ; Keep lower.
    ORA #$20 ; Set bits.
    STA FIRST_LAUNCHER_HOLD_FLAG? ; Set ??
    EOR #$60 ; Invert 0110.0000
    STA SCRIPT_FLAG_0x22_AUTO_MOVE ; Set ??
    SEC ; Ret CS.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable and leave.
Y_INDEXES_UNK: ; 1E:196B, 0x03D96B
    .db 03 ; Indexes.
    .db 03
    .db 03
    .db 07
DATA_WRITING_UNK: ; 1E:196F, 0x03D96F
    .db 5C ; Data write.
    .db DF
    .db 00
    .db 24
    .db 8B
    .db DF
    .db 40
    .db DB
L_1E:1977: ; 1E:1977, 0x03D977
    DEC SAVE_ID_FOCUS ; -- ??
    BMI RTS ; Negative, goto.
    BEQ RTS ; == 0, leave.
LOOP_CHECK: ; 1E:197D, 0x03D97D
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8 ; Load.
    CMP #$01 ; If _ #$01
    BEQ VAL_EQ_0x1 ; ==, goto.
    JSR LIB_SUB_UNK ; Do sub.
    BCS LOOP_CHECK ; CS, loop.
STREAM_NEGATIVE: ; 1E:1989, 0x03D989
    JSR LIB_SUB_UNK ; Do ??
VAL_EQ_0x1: ; 1E:198C, 0x03D98C
    LDA #$00 ; Val ??
    JSR LIB_FPTR_AND_MOVE_HELPER ; Do.
    LDY #$01 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from moved.
    BMI STREAM_NEGATIVE ; Negative, goto.
RTS: ; 1E:1997, 0x03D997
    RTS ; Leave.
LIB_SUB_UNK: ; 1E:1998, 0x03D998
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Do WRAM writable.
    LDX #$00 ; Clear index.
    STX SLOT/DATA_OFFSET_USE? ; Clear.
LIB_SWAP_UNK: ; 1E:199F, 0x03D99F
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load ??
    PHA ; Save it.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; Swap bytes.
    STA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    PLA ; Pull it.
    STA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; Put to.
    LDA #$02 ; Offset for swap.
    JSR OFFSET_ADD_AND_SWAP_UNK ; Do ??
    LDA #$03 ; Offset for swap.
    JSR OFFSET_ADD_AND_SWAP_UNK ; Do ??
    LDA #$08 ; Val?
VAL_LT_0x11: ; 1E:19B9, 0x03D9B9
    PHA ; Save.
    JSR OFFSET_ADD_AND_SWAP_UNK ; Swap ??
    PLA ; Pull val.
    CLC ; Prep add.
    ADC #$01 ; Add with.
    CMP #$11 ; If _ #$11
    BCC VAL_LT_0x11 ; <, goto.
    LDA #$16 ; Add for swap.
    JSR OFFSET_ADD_AND_SWAP_UNK
    LDA #$17 ; Add for swap.
    JSR OFFSET_ADD_AND_SWAP_UNK
    CLC ; Prep add.
    LDA SLOT/DATA_OFFSET_USE? ; Load ??
    ADC #$20 ; += 0x20
    STA SLOT/DATA_OFFSET_USE? ; Store result.
    INX ; Index++
    CPX SAVE_ID_FOCUS ; If _ var
    BCC LIB_SWAP_UNK ; <, goto.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
OFFSET_ADD_AND_SWAP_UNK: ; 1E:19DE, 0x03D9DE
    CLC ; Prep add.
    ADC SLOT/DATA_OFFSET_USE? ; Add ??
    TAY ; To Y index.
    LDA R_**:$6780,Y ; Load ??
    PHA ; Save val.
    LDA R_**:$67A0,Y ; Swap vals.
    STA R_**:$6780,Y
    PLA ; Pull val.
    STA R_**:$67A0,Y ; Store val.
    RTS
TEST_SAVE_INDEX_X_CC_0x1-0x5: ; 1E:19F1, 0x03D9F1
    SEC ; Prep sub.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load ??
    BEQ RTS ; == 0, goto. Ret CC.
    CMP #$06 ; If _ #$06. <, return CC. >=, ret CS.
RTS: ; 1E:19F9, 0x03D9F9
    RTS ; 0x01-0x05, CC. CS otherwise.
SLOTS_AND_FPTRS_IDFK: ; 1E:19FA, 0x03D9FA
    LDX #$00 ; Index reset.
INDEX_LT_0x4: ; 1E:19FC, 0x03D9FC
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load from indexed.
    BEQ VAL_EQ_0x00 ; ==, goto.
    JSR CREATE_PTR_FOR_SAVE/ROM_PAGE_UNK ; Make ptr ??
    LDY #$2C ; Index.
VAL_LT_0x30: ; 1E:1A06, 0x03DA06
    LDA WRAM_ARR_UNK[48],Y ; Load WRAM ??
    STA [BCD/MODULO/DIGITS_USE_A],Y ; Store to stream.
    INY ; Stream++
    CPY #$30 ; If _ #$30
    BCC VAL_LT_0x30 ; <, goto.
VAL_EQ_0x00: ; 1E:1A10, 0x03DA10
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC INDEX_LT_0x4 ; <, loop.
    RTS ; Leave.
SCRIPT_ROUTINE?_DOER?: ; 1E:1A16, 0x03DA16
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR ENGINE_0x300_OBJECTS_UNK? ; Do ??
    LDX #$00 ; Index ??
INDEX_LT_0x4: ; 1E:1A1E, 0x03DA1E
    JSR TEST_SAVE_INDEX_X_CC_0x1-0x5 ; Do 
    BCS RET_CS ; Ret CS, goto.
    TXA ; Index to A.
    JSR LIB_FPTR_AND_MOVE_HELPER ; Do lib.
    LDY #$01 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    BMI RET_CS ; Stream negative.
    LDY #$10 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from ptr.
    TAY ; To Y index.
    LDA #$80
    STA OBJ?_PTR?[2],Y ; Set ??
    LDA #$81
    STA OBJ?_PTR?+1,Y ; Set pair.
RET_CS: ; 1E:1A3C, 0x03DA3C
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC INDEX_LT_0x4 ; <, goto.
    LDA #$01
    STA NMI_FLAG_EXECUTE_UPDATE_BUF ; Set flag.
    JMP ENGINE_SETTLE_ALL_UPDATES? ; Settle and leave.
LIB_UNK: ; 1E:1A48, 0x03DA48
    LDA SLOT/DATA_OFFSET_USE? ; Move ??. If 0x00, loops forever to crash game.
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    LDA R_**:$0049 ; Move to misc use. ??
    STA BCD/MODULO/DIGITS_USE_A
    LDA R_**:$004A
    STA BCD/MODULO/DIGITS_USE_B
    LDA R_**:$004B
    STA BCD/MODULO/DIGITS_USE_C
    JSR ENGINE_BINARY_MODULO_HELPER ; Do ??
    LDA LOCAL_VARS_ARR?[8] ; Load ??
    BEQ VAL_EQ_0x00 ; == 0, goto.
    LDA #$01 ; 0x1 otherwise.
VAL_EQ_0x00: ; 1E:1A61, 0x03DA61
    CLC ; Prep add.
    ADC BCD/MODULO/DIGITS_USE_A ; Add val to.
    STA R_**:$0049 ; Store result.
    LDA #$00 ; Carry seed.
    ADC BCD/MODULO/DIGITS_USE_B ; Add carry.
    STA R_**:$004A ; Store result.
    LDA #$00 ; Seed carry.
    ADC BCD/MODULO/DIGITS_USE_C ; Add carry.
    STA R_**:$004B ; Store result.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; WRAM writable.
    LDX #$00 ; Index set.
VAL_LT_0x4: ; 1E:1A77, 0x03DA77
    JSR TEST_SAVE_INDEX_X_CC_0x1-0x5 ; Do ??
    BCS RTN_RET_CS ; Ret CS, goto.
    STA R_**:$0028 ; Set ??
    TXA ; X to A.
    LSR A ; >> 1, /2.
    ROR A ; Rotate into now.
    ROR A
    ROR A
    STA SCRIPT_INDEX_53_UNK ; Store shifted.
    TXA ; X to A again.
    PHA ; Save it.
    JSR LIB_FPTR_AND_MOVE_HELPER ; Do lib.
    LDY #$01 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load ??
    BMI VAL_NEGATIVE ; Negative, goto.
    LDA STREAM_REPLACE_COUNT? ; Load ??
    BNE SUBS_UNDERFLOWED ; != 0, goto.
    LDY #$11 ; Stream index.
    CLC ; Prep add.
    LDA R_**:$0049 ; Delta.
    ADC [R6_BANKED_ADDR_MOVED[2]],Y ; Add with stream.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store result.
    INY ; Stream++
    LDA R_**:$004A ; Delta.
    ADC [R6_BANKED_ADDR_MOVED[2]],Y ; Add with stream.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store result.
    INY ; Stream++
    LDA R_**:$004B ; Delta.
    ADC [R6_BANKED_ADDR_MOVED[2]],Y ; Add with stream.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store result.
    BCC NO_CARRY_FINAL ; No carry, goto.
    LDY #$11 ; Stream index.
    LDA #$FF ; Seed val to write. Failure condition or catch here.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Set 0xFF.
    INY ; Stream++
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; 0xFF
    INY ; Stream++
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; 0xFF
NO_CARRY_FINAL: ; 1E:1AB9, 0x03DAB9
    LDY #$10 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from file.
    JSR LIB_IDFK_DECIMALY_AND_IDK ; Do ??
    LDY #$11 ; Stream index.
    SEC ; Prep sub.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    SBC SAVE_GAME_MOD_PAGE_PTR[2] ; -= ??
    INY ; Stream++
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load ??
    SBC SAVE_GAME_MOD_PAGE_PTR+1 ; -= ??, carried.
    INY ; Stream++
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load ??
    SBC ALT_STUFF_INDEX? ; -= ??, carried.
    BCC SUBS_UNDERFLOWED ; Underflowed, goto.
    JSR SUB_CHECK_STREAM_INDEX_LT_0x63 ; Do, in range.
    BCC NO_CARRY_FINAL ; Ret CC, goto.
SUBS_UNDERFLOWED: ; 1E:1AD8, 0x03DAD8
    JSR LIB_STREAMY_UNK ; Do ??
VAL_NEGATIVE: ; 1E:1ADB, 0x03DADB
    PLA ; Pull A.
    TAX ; To X index.
RTN_RET_CS: ; 1E:1ADD, 0x03DADD
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC VAL_LT_0x4 ; <, goto.
    JSR LIB_PACKET_R6_0x00_TODO ; Do ??
    LDA STREAM_REPLACE_COUNT? ; Load ??
    BNE EXIT_DISABLE_WRAM ; != 0, goto.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Do writeable.
    LDX #$12 ; Index.
    JSR LIB_ADD_TO_GROUP_24-BIT ; Add.
    LDX #$15 ; Index.
    JSR LIB_ADD_TO_GROUP_24-BIT ; Add.
    LDA SCRIPT_ENCOUNTER_ID?(SAID_SONG_ID???) ; Load ??
    BEQ EXIT_DISABLE_WRAM ; == 0, goto.
    STA PTR_CREATE_SEED_UNK ; Store nonzero.
    JSR ENGINE_HELPER_R7_0x13 ; Bank in.
    JSR PTR_AND_BANK_R6_UNK ; Do ??
    LDA #$FF
    STA R_**:$002A ; Set ??
    LDA R_**:$002B ; Load ??
    ORA #$1F ; Set ??
CC_LOOP: ; 1E:1B0A, 0x03DB0A
    ASL R_**:$002A ; << var.
    ASL A ; << 1.
    BCC CC_LOOP ; CC, do more.
    JSR RANDOMIZE_GROUP_0x26 ; Do adds.
    AND R_**:$002A ; Remove ??
    BNE EXIT_DISABLE_WRAM ; Any set, goto.
    JSR PTR_MOVE_TO_UNK_ARR_WRAM ; Do ??
    LDX #$00 ; Index ??
INDEX_LT_0x4: ; 1E:1B1B, 0x03DB1B
    JSR TEST_SAVE_INDEX_X_CC_0x1-0x5 ; Do ??
    BCS RET_CS ; CS, goto.
    STA R_**:$0028 ; Store loaded from arr.
    TXA ; Save X.
    PHA
    JSR BANKED_DERP ; Do ??
    PLA ; Restore X.
    TAX
    BCC CALL_INTO_0x17_IDFK ; CC, goto, passed.
RET_CS: ; 1E:1B2B, 0x03DB2B
    INX ; Index++
    CPX #$04 ; If _ #$04
    BCC INDEX_LT_0x4 ; <, loop.
EXIT_DISABLE_WRAM: ; 1E:1B30, 0x03DB30
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Exit disabling wram.
CALL_INTO_0x17_IDFK: ; 1E:1B33, 0x03DB33
    JSR ENGINE_HELPER_R7_0x17 ; To bank.
    LDA #$06
    STA SOUND_FX_REQUEST_B? ; Set ??
    LDA #$8C ; Val ??
    JMP LIB_EXIT_IDFK ; Goto ??
LIB_IDFK_DECIMALY_AND_IDK: ; 1E:1B40, 0x03DB40
    TAX ; A to X.
    INX ; ++
    STX SAVE_GAME_MOD_PAGE_PTR[2] ; Store ??
    INX ; ++
    STX BCD/MODULO/DIGITS_USE_A ; Store ??
    LDA #$00
    STA BCD/MODULO/DIGITS_USE_B ; Clear ??
    STA BCD/MODULO/DIGITS_USE_C
    JSR LIB_DECIMAL?_UNK ; Do.
    JSR LIB_DECIMAL?_UNK ; Again. Mistake?
    JSR LIB_SETUP_PTR_AND_R6_UNK ; Do ??
    LDY #$00 ; Stream index.
    LDA [LOCAL_VARS_ARR?[8]],Y ; Move ??
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    JSR LIB_DECIMAL?_UNK ; Do RTN.
    LDA BCD/MODULO/DIGITS_USE_B ; Move ??
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    LDA BCD/MODULO/DIGITS_USE_C ; 2x
    STA SAVE_GAME_MOD_PAGE_PTR+1
    LDA BCD/MODULO/DIGITS_USE_D ; Move ??
    STA ALT_STUFF_INDEX?
    RTS ; Leve.
SUB_CHECK_STREAM_INDEX_LT_0x63: ; 1E:1B6C, 0x03DB6C
    LDY #$10 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from R6 banked.
    CMP #$63 ; If _ #$63
    BCC VAL_LT_0x63 ; <, goto.
    RTS ; Leave.
VAL_LT_0x63: ; 1E:1B75, 0x03DB75
    ADC #$01 ; += 0x1
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store back.
    JSR LIB_PACKET_R6_0x00_TODO ; Do lib.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Do writeable.
    LDA #$FF
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Set.
    LDA #$1F
    JSR SOUND_ASSIGN_NEW_MAIN_SONG ; Set song, battle won.
    LDA #$82 ; Seed ??
    JSR $A3F8
    JSR LIB_SETUP_PTR_AND_R6_UNK ; Set up.
    LDY #$03
VAL_LT_0x8: ; 1E:1B93, 0x03DB93
    JSR RANDOMIZE_GROUP_0x26 ; Do adds.
    LSR A ; >> 6, /64
    LSR A
    LSR A
    LSR A
    LSR A
    LSR A
    CLC ; Prep add.
    ADC [LOCAL_VARS_ARR?[8]],Y ; Add with ptr.
    LSR A ; >> 1, /2.
    STA 57_INDEX_UNK,Y ; Store to alt index.
    INY ; Index++
    CPY #$08 ; If _ #$08
    BCC VAL_LT_0x8 ; <, goto.
    LDY #$0B ; Index.
VAL_LT_0x10: ; 1E:1BAA, 0x03DBAA
    CLC ; Prep add.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load  stream.
    ADC R_**:$004D,Y ; Add with.
    BCC NO_CARRY ; No carry, goto.
    SBC R_**:$004D,Y ; Sub with, right val.
    EOR #$FF ; Invert.
    STA R_**:$004D,Y ; Store back.
    LDA #$FF ; Seed ??
NO_CARRY: ; 1E:1BBC, 0x03DBBC
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store to arr.
    LDA R_**:$004D,Y ; Load from arr.
    BEQ VAL_EQ_0x00 ; == 0, goto.
    TYA ; Save Y.
    PHA
    CLC ; Prep add.
    ADC #$7B ; Add with.
    JSR $A3F8 ; Run banked, todo find which.
    PLA ; Restore Y.
    TAY
VAL_EQ_0x00: ; 1E:1BCD, 0x03DBCD
    INY ; Y++
    CPY #$10 ; If _ #$10
    BCC VAL_LT_0x10 ; <, goto.
    LDY #$07 ; Index ??
    LDA R_**:$0058 ; Load ??
    JSR CARRY_ADD_FILE_UNK ; Carry add into file.
    LDY #$09 ; Index ??
    LDA R_**:$0059 ; Load ??
    JSR CARRY_ADD_FILE_UNK ; Do.
    LDY #$0E ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from file.
    STA BCD/MODULO/DIGITS_USE_A ; Store to.
    CLC ; Prep add.
    ADC #$14 ; += 0x14
    BCC NO_OVERFLOW ; No overflow, goto.
    LDA #$FF ; Seed highest?
NO_OVERFLOW: ; 1E:1BED, 0x03DBED
    LDY #$03 ; Stream index.
    JSR STATS_THINGY_LARGE ; Do.
    LDA #$84 ; Val ??
    JSR INDEX_AND_BANKED_UNK ; Do rtn ??
    LDA R_**:$0028 ; Load val.
    CMP #$03 ; If _ #$03
    BCS EXIT_CC ; >=, goto.
    LDY #$0F ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from file.
    STA BCD/MODULO/DIGITS_USE_A ; Store to misc.
    LSR A ; >> 1, /2.
    CLC ; Prep carry.
    LDY #$05 ; Stream index ??
    JSR STATS_THINGY_LARGE ; Do stats.
    LDA #$85 ; Val ??
    JSR INDEX_AND_BANKED_UNK ; Do ??
EXIT_CC: ; 1E:1C0F, 0x03DC0F
    CLC ; Return CS.
    RTS
LIB_ADD_TO_GROUP_24-BIT: ; 1E:1C11, 0x03DC11
    CLC ; Prep add.
    LDA R_**:$004C ; Load adding.
    ADC CURRENT_SAVE_MANIPULATION_PAGE[768],X ; Add with X indexed.
    STA CURRENT_SAVE_MANIPULATION_PAGE[768],X ; Store result.
    LDA R_**:$004D ; Load adding.
    ADC CURRENT_SAVE_MANIPULATION_PAGE+1,X ; Add with pair.
    STA CURRENT_SAVE_MANIPULATION_PAGE+1,X ; Store result.
    LDA #$00 ; Carry add prep.
    ADC SAVE_SLOT_DATA_CHECKSUM_ADJUST_A,X ; Carry add to, also.
    STA SAVE_SLOT_DATA_CHECKSUM_ADJUST_A,X ; Store result.
    BCC VALUE_VALID_PROBABLY ; No carry, should be good.
    LDA #$FF ; Failure/OOB set.
    STA CURRENT_SAVE_MANIPULATION_PAGE[768],X ; Set.
    STA CURRENT_SAVE_MANIPULATION_PAGE+1,X
    STA SAVE_SLOT_DATA_CHECKSUM_ADJUST_A,X
VALUE_VALID_PROBABLY: ; 1E:1C37, 0x03DC37
    RTS ; Leave.
INDEX_AND_BANKED_UNK: ; 1E:1C38, 0x03DC38
    LDX FPTR_5C_UNK+1 ; X from ??
    BEQ RTS ; == 0, goto.
    JMP $A3F8 ; Goto banked.
STATS_THINGY_LARGE: ; 1E:1C3F, 0x03DC3F
    CLC ; Prep add.
    ADC BCD/MODULO/DIGITS_USE_A ; Add to.
    STA BCD/MODULO/DIGITS_USE_A ; Store result.
    LDA #$00 ; Carry seed.
    ROL A ; Put into, 0x00/0x01 based on carry. Smart.
    STA BCD/MODULO/DIGITS_USE_B ; Store to.
    SEC ; Prep sub.
    LDA BCD/MODULO/DIGITS_USE_A ; Load val.
    SBC [R6_BANKED_ADDR_MOVED[2]],Y ; Sub from ptr.
    TAX ; To X index.
    INY ; Stream++
    LDA BCD/MODULO/DIGITS_USE_B ; Load from stream.
    SBC [R6_BANKED_ADDR_MOVED[2]],Y ; Sub from ptr.
    BEQ VAL_EQ_0x00 ; ==, goto.
    LDX #$08 ; Val ??
    BCS VAL_EQ_0x00 ; >=, goto.
    LDX #$01 ; Index ??
VAL_EQ_0x00: ; 1E:1C5C, 0x03DC5C
    DEY ; Y--
    TXA ; X to A.
    ASL A ; << 1, *2.
    JSR ADDS_SHIFTS_AND_STATS_THINGY? ; Do sub.
    STA FPTR_5C_UNK+1 ; Store result.
CARRY_ADD_FILE_UNK: ; 1E:1C64, 0x03DC64
    CLC ; Prep add.
    ADC [R6_BANKED_ADDR_MOVED[2]],Y ; Add with.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store to.
    INY ; Index++
    LDA #$00 ; Seed ??
    ADC [R6_BANKED_ADDR_MOVED[2]],Y ; Carry add.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store back.
RTS: ; 1E:1C70, 0x03DC70
    RTS ; Leave.
ADDS_SHIFTS_AND_STATS_THINGY?: ; 1E:1C71, 0x03DC71
    CMP #$10 ; If _ #$10
    BCC VAL_LT_0x10 ; <, goto.
    LDA #$10 ; Load ??
VAL_LT_0x10: ; 1E:1C77, 0x03DC77
    TAX ; A to index.
    JSR RANDOMIZE_GROUP_0x26
    LSR A ; Nibble down.
    LSR A
    LSR A
    LSR A
    JSR ENGINE_HEX_MULTIPLY_BYTES_TO_WORD_IN_XA
    LSR A ; Nibble down.
    LSR A
    LSR A
    LSR A
    RTS ; Leave.
LIB_STREAMY_UNK: ; 1E:1C87, 0x03DC87
    LDA MAIN_FLAG_UNK ; Load ??
    BNE RTS ; != 0, goto.
    JSR LIB_SETUP_PTR_AND_R6_UNK ; Do ??
    LDY #$02 ; Stream idnex.
    LDA [LOCAL_VARS_ARR?[8]],Y ; Load from stream.
    BEQ RTS ; == 0, goto.
    PHA ; Save val, stream index.
    LDX #$C0 ; Seed ??
X_STORE_LOOP?: ; 1E:1C97, 0x03DC97
    STX PTR_CREATE_SEED_UNK ; Store X ??
    JSR LIB_SETUP_PTR_UNK_SEED_LOAD_ALT ; Do ptr and stuff seeded.
    PLA ; Pull val for stream index.
    PHA ; Re-save it, too.
    TAY ; To stream index.
    LDA [LOCAL_VARS_ARR?[8]],Y ; Load streamed.
    LDY #$10 ; Reseed with.
    CMP [R6_BANKED_ADDR_MOVED[2]],Y ; If _ stream
    BCS VAL_GTE_STREAM ; >=, goto.
    JSR SUB_PTR_SEED_TO_STREAM_INDEX_AND_BIT_TO_TEST ; Get testing.
    AND [R6_BANKED_ADDR_MOVED[2]],Y ; Test from stream.
    BNE VAL_GTE_STREAM ; Test set, goto.
    JSR RANDOMIZE_GROUP_0x26 ; Not set, do ??
    AND #$C0 ; Keep upper bits.
    BNE VAL_GTE_STREAM ; Either set, goto.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    ORA LUT_INDEX_TO_BITS_0x80-0x01,X ; Set val.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store it back.
    LDA #$09
    STA SOUND_FX_REQUEST_B? ; Set ??
    LDA #$83 ; Val ??
    JSR LIB_EXIT_IDFK ; Goto. TODO: Might not be 0x17 bank.
VAL_GTE_STREAM: ; 1E:1CC6, 0x03DCC6
    LDX PTR_CREATE_SEED_UNK ; Load.
    INX ; ++
    BNE X_STORE_LOOP? ; != 0, goto.
    PLA ; Restore index.
RTS: ; 1E:1CCC, 0x03DCCC
    RTS ; Leave.
SUB_PTR_SEED_TO_STREAM_INDEX_AND_BIT_TO_TEST: ; 1E:1CCD, 0x03DCCD
    LDA PTR_CREATE_SEED_UNK ; Load seed.
    CLC ; Prep add.
    ADC #$C0 ; += 0xC0
    ROR A ; >> 1, /2. Carry result into.
    LSR A ; >> 2, /4.
    LSR A
    TAY ; To Y indedx.
    LDA PTR_CREATE_SEED_UNK ; Load seed again.
    AND #$07 ; Keep lower, bit to test.
    TAX ; To X index.
    LDA LUT_INDEX_TO_BITS_0x80-0x01,X ; Load bit test from LUT.
    RTS ; Leave.
LIB_SETUP_PTR_AND_R6_UNK: ; 1E:1CDF, 0x03DCDF
    CLC ; Prep add.
    LDA R_**:$0028 ; Load ??
    ADC #$B8 ; +=, base val.
    BCC NO_OVERFLOW ; No carry, goto.
LIB_SETUP_PTR_UNK_SEED_LOAD_ALT: ; 1E:1CE6, 0x03DCE6
    LDA PTR_CREATE_SEED_UNK ; Load alt val ??
NO_OVERFLOW: ; 1E:1CE8, 0x03DCE8
    ASL A ; << 1, *2.
    ROL LOCAL_VARS_ARR?+1 ; Rotate into.
    ASL A ; 2x
    ROL LOCAL_VARS_ARR?+1
    ASL A ; 3x
    ROL LOCAL_VARS_ARR?+1
    CLC ; Prep add.
    ADC #$00 ; Do nothing, ew.
    STA LOCAL_VARS_ARR?[8] ; Store addr L.
    LDA LOCAL_VARS_ARR?+1 ; Load ??
    AND #$07 ; Keep 0000.0111
    ADC #$98 ; Base, 0x98, to 9F.
    STA LOCAL_VARS_ARR?+1 ; Set PTR H,
    JMP ENGINE_R6_TO_BANK_0x00_THING_1 ; Do.
MANY_STREAMS_UNK: ; 1E:1D01, 0x03DD01
    JSR SETUP_PTR_6780_UNK ; Setup ptr.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable writes.
LOOP_NONZERO: ; 1E:1D07, 0x03DD07
    LDY #$00 ; Stream reset.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load.
    ASL A ; << 1, *2.
    BEQ DONE_FORWARD ; ==, goto.
    JSR MAP?_RTN_A ; Do ??
    BCS RET_CS ; CS, goto.
    LDY #$00 ; Stream reset.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from.
    ORA #$80 ; Set.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store back.
    BMI DONE_FORWARD ; Always taken, goto.
RET_CS: ; 1E:1D1D, 0x03DD1D
    LDY #$00 ; Stream reset.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from.
    AND #$3F ; Keep lower.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store back.
    JSR SWITCH_SCRIPT_ROUTINES ; Switch with.
    JSR STREAMS_UNK_LOGICAL? ; Do.
DONE_FORWARD: ; 1E:1D2B, 0x03DD2B
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Forward.
    INC SAVE_ID_FOCUS ; ++
    BNE LOOP_NONZERO ; != 0, goto.
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Load ??
    BNE EXIT_NO_WRITES ; != 0, goto.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ORA SOUND_VAL_SONG_CURRENT_ID ; Set ??
    LDX SCRIPT_PAIR_PTR_B_SEED?+1 ; X from.
    STA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Store ??
    STX CURRENT_SAVE_MANIPULATION_PAGE+5
    LDA SCRIPT_PAIR_PTR?[2] ; Load.
    AND #$C0 ; Keep upper.
    ORA WRAM_SCRIPT_COMBINE_IDFK ; Set with WRAM.
    LDX SCRIPT_PAIR_PTR?+1 ; X from.
    STA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Store ??
    STX CURRENT_SAVE_MANIPULATION_PAGE+7
EXIT_NO_WRITES: ; 1E:1D54, 0x03DD54
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; No writes, abuse RTS.
SETUP_PTR_6780_UNK: ; 1E:1D57, 0x03DD57
    LDA #$80 ; Seed PTR $6780
    LDX #$67
    STA ENGINE_MAP_OBJ_RESERVATIONS/??[2]
    STX ENGINE_MAP_OBJ_RESERVATIONS/??+1
    LDX #$FC
    STX SAVE_ID_FOCUS ; Set ??
    RTS ; Leave.
ENGINE_FPTR_COL/ROW_MOD/FORWARD?: ; 1E:1D64, 0x03DD64
    CLC ; Prep add.
    LDA ENGINE_MAP_OBJ_RESERVATIONS/??[2] ; Load.
    ADC #$20 ; Add 0x20.
    STA ENGINE_MAP_OBJ_RESERVATIONS/??[2] ; Store result.
    LDA ENGINE_MAP_OBJ_RESERVATIONS/??+1 ; Carry add.
    ADC #$00
    STA ENGINE_MAP_OBJ_RESERVATIONS/??+1
    RTS ; Leave.
LOOP_HELPER_A_LOT: ; 1E:1D72, 0x03DD72
    JSR BANK_R6/INIT_PTR/SET_UNK ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM.
VAL_NONZERO: ; 1E:1D78, 0x03DD78
    JSR BANKED_ADDR_TO_PTR_UNK ; Do ??
    JSR SUB_UNK_A_TODO_BETTER ; Do ??
    JSR R6_BANKED_PTR_FORWARD_CONSUMED ; Do
    DEC SAVE_ID_FOCUS ; --
    BNE VAL_NONZERO ; != 0, goto.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Leave, no writes.
SUB_UNK_A_TODO_BETTER: ; 1E:1D88, 0x03DD88
    LDY #$01 ; Stream index.
    LDA SCRIPT_R6_ROUTINE_SELECT ; Load.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to FPRT.
    LDA SLOT/DATA_OFFSET_USE? ; Load.
    BNE VAL_NONZERO ; != 0, goto.
EXIT_CLEAR?: ; 1E:1D92, 0x03DD92
    LDY #$00 ; Stream index.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store val.
    RTS ; Leave.
VAL_NONZERO: ; 1E:1D97, 0x03DD97
    LDY #$00 ; Stream index.
    LDA [ENGINE_FPTR_32[2]],Y ; Load from file.
    AND #$3F ; Keep lower bits.
    BEQ EXIT_CLEAR? ; == 0, goto.
    JSR STREAM_UNK ; Do ??
    LDY #$02 ; TODO this bullshit.
    LDA [ENGINE_FPTR_32[2]],Y ; Move file to file.
    AND #$3F ; Lower only.
    LDY #$15
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; 20.
    LDY #$04
    LDA [ENGINE_FPTR_32[2]],Y ; Move.
    LDY #$16
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$05
    LDA [ENGINE_FPTR_32[2]],Y ; move.
    LDY #$17
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$00
    LDA [ENGINE_FPTR_32[2]],Y ; Move top.
    AND #$C0 ; Keep top only.
    LDY #$04
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    STA SCRIPT_LOADED_SHIFTED_UNK[2]
    LDY #$01
    LDA [ENGINE_FPTR_32[2]],Y ; Move.
    LDY #$05
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    STA SCRIPT_USE_UNK_A ; And to var.
    LDY #$02
    LDA [ENGINE_FPTR_32[2]],Y ; Move.
    AND #$C0
    LDY #$06
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    STA SCRIPT_USE_UNK_B_PTR_L ; And to var.
    LDY #$03
    LDA [ENGINE_FPTR_32[2]],Y ; Move.
    LDY #$07
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    STA SCRIPT_USE_UNK_C_PTR_H ; And to var.
    LDY #$02
    LDA ENGINE_FPTR_32[2] ; Move same index.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA ENGINE_FPTR_32+1 ; Load ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store to file.
    JSR SETUP_DEEP_STREAM_UNK ; Do setup.
    LDY #$11 ; Stream index.
    LDA STREAM_DEEP_INDEX ; Move ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA STREAM_DEEP_C ; Move ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA STREAM_DEEP_D? ; Move ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$18 ; Seed stream index.
    LDX #$08 ; Seed loops count.
    LDA #$00 ; Seed clear.
CLEAR_STREAM_LOOP: ; 1E:1E0C, 0x03DE0C
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Clear.
    INY ; Stream++
    DEX ; Loops--
    BNE CLEAR_STREAM_LOOP ; != 0, goto.
    RTS ; Leave.
STREAM_UNK: ; 1E:1E13, 0x03DE13
    LDY #$00 ; Stream index.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store val to.
    ASL A ; << 2, *4.
    ASL A
    TAX ; To X.
    LDY #$08 ; Stream index.
    LDA ROUTINE_ATTR_A,X ; Move ??
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$14 ; Stream index.
    LDA ROUTINE_ATTR_B,X
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    RTS ; Leave.
BANK_R6/INIT_PTR/SET_UNK: ; 1E:1E29, 0x03DE29
    LDA SCRIPT_R6_ROUTINE_SELECT ; Load ??
    JSR BANK_HANDLER_R6_AND_BASE ; Bank R6.
    ASL A ; Val based.
    TAX ; To index.
    LDA $8000,X ; Move ptr from bank.
    STA R6_BANKED_ADDR_MOVED[2]
    LDA $8001,X
    STA R6_BANKED_ADDR_MOVED+1
    LDA #$02
    STA SLOT/DATA_OFFSET_USE? ; Set ??
INIT_PTR_WRAM_6800/COUNT_UNK: ; 1E:1E3E, 0x03DE3E
    LDA #$00
    LDX #$68
    STA ENGINE_MAP_OBJ_RESERVATIONS/??[2] ; Set $6800 ??
    STX ENGINE_MAP_OBJ_RESERVATIONS/??+1
    LDX #$28
    STX SAVE_ID_FOCUS ; Set count?
    RTS ; Leave.
BANKED_ADDR_TO_PTR_UNK: ; 1E:1E4B, 0x03DE4B
    LDY #$01 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    BEQ STREAM_ZERO ; == 0, leave.
    STA ENGINE_FPTR_32+1 ; Store ??
    DEY ; Stream--
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    STA ENGINE_FPTR_32[2] ; Store ??
    RTS ; Leave.
STREAM_ZERO: ; 1E:1E59, 0x03DE59
    STA SLOT/DATA_OFFSET_USE? ; Clear.
    RTS ; Leave.
R6_BANKED_PTR_FORWARD_CONSUMED: ; 1E:1E5C, 0x03DE5C
    CLC ; Prep add.
    LDA R6_BANKED_ADDR_MOVED[2] ; Load from file.
    ADC SLOT/DATA_OFFSET_USE? ; Add with.
    STA R6_BANKED_ADDR_MOVED[2] ; Store back.
    LDA R6_BANKED_ADDR_MOVED+1 ; Carry add.
    ADC #$00
    STA R6_BANKED_ADDR_MOVED+1
    JMP ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Goto.
BANK_HANDLER_R6_AND_BASE: ; 1E:1E6C, 0x03DE6C
    CMP #$2B ; If _ #$2B
    BCC LT_0x2B ; <, goto.
    LDX #$12 ; Seed bank to use.
    SBC #$2B ; Rebase 0.
    BCS A_REBASED ; Always taken.
LT_0x2B: ; 1E:1E76, 0x03DE76
    CMP #$1A ; If _ #$1A
    BCC LT_0x1A ; <, goto.
    LDX #$11 ; Seed bank to use.
    SBC #$1A ; Rebase 0.
    BCS A_REBASED
LT_0x1A: ; 1E:1E80, 0x03DE80
    LDX #$10 ; Seed bank.
A_REBASED: ; 1E:1E82, 0x03DE82
    PHA ; Save index into bank routines.
    TXA ; Bank val to A.
    LDX #$06 ; Seed R6 mod.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6 to bank.
    PLA ; Pull index for routine in the bank, starting at 0x00, is based on 0x00 into bank here.
    RTS ; Leave.
ENGINE_R6_TO_BANK_0x00_THING_1: ; 1E:1E8B, 0x03DE8B
    LDX #$06 ; Bank R6.
    LDA #$00 ; Bank val.
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_R6_TO_BANK_0x00_THING_2: ; 1E:1E92, 0x03DE92
    LDX #$06 ; Do same as above lol. Mistake/idk.
    LDA #$00
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_MAP_DISPLAY_OR_SCRIPT_RUN?: ; 1E:1E99, 0x03DE99
    JSR BANK_R6/INIT_PTR/SET_UNK ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable writes.
LOOP_NONZERO: ; 1E:1E9F, 0x03DE9F
    JSR BANKED_ADDR_TO_PTR_UNK ; Do.
    LDY #$01 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from fptr.
    CMP SCRIPT_R6_ROUTINE_SELECT ; If _ routine.
    BEQ ROUTINE_MATCH ; ==, goto.
    LDY #$00
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load base. Size?
    ASL A ; << 1, *2. Word size.
    BEQ VAL_SHIFTED_0x00 ; == 0, goto.
    JSR MAP?_RTN_A ; Do.
    BCS STREAM_KEEP_LOWER ; Ret CS, goto.
VAL_SHIFTED_0x00: ; 1E:1EB6, 0x03DEB6
    JSR SUB_UNK_A_TODO_BETTER ; Do ??
ROUTINE_MATCH: ; 1E:1EB9, 0x03DEB9
    LDY #$00 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from file.
    ASL A ; << 1, *2.
    BEQ STREAM_NEG_SET ; == 0, goto.
    JSR MAP?_RTN_A ; Do ??
    BCS STREAM_KEEP_LOWER ; Ret CS, goto.
    LDY #$00 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load.
    ORA #$80 ; Set top bit.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Goto.
    BMI STREAM_NEG_SET ; Always taken.
STREAM_KEEP_LOWER: ; 1E:1ECF, 0x03DECF
    LDY #$00 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Keep lower only in file.
    AND #$3F
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
STREAM_NEG_SET: ; 1E:1ED7, 0x03DED7
    JSR R6_BANKED_PTR_FORWARD_CONSUMED ; Forward.
    DEC SAVE_ID_FOCUS ; --
    BNE LOOP_NONZERO ; != 0, loop.
    JSR INIT_PTR_WRAM_6800/COUNT_UNK ; Reinit.
VAL_NONZERO_LOOP: ; 1E:1EE1, 0x03DEE1
    LDY #$00 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    BEQ STREAM_EQ_0x00 ; == 0, goto.
    BMI STREAM_EQ_0x00 ; Negative, goto.
    JSR SWITCH_SCRIPT_ROUTINES ; Switch with stream, object there data use now?
    JSR STREAMS_UNK_LOGICAL? ; Do ??
STREAM_EQ_0x00: ; 1E:1EEF, 0x03DEEF
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do ??
    DEC SAVE_ID_FOCUS ; --
    BNE VAL_NONZERO_LOOP
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
STREAMS_UNK_LOGICAL?: ; 1E:1EF9, 0x03DEF9
    LDY #$11 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    STA LOCAL_VARS_ARR?+1 ; Store to.
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; 2x
    STA LOCAL_VARS_ARR?+2
    INY
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; 3x
    STA LOCAL_VARS_ARR?+3
    LDY #$00 ; Reset stream.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    BPL STREAM_POSITIVE ; Positive, goto.
    JMP STREAM_NEG ; Goto otherwise.
STREAM_POSITIVE: ; 1E:1F12, 0x03DF12
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B_SEED?[2] ; Load ??
    ADC #$60 ; Add with.
    STA BCD/MODULO/DIGITS_USE_A ; Store to.
    LDA SCRIPT_PAIR_PTR_B_SEED?+1 ; Load ??
    ADC #$00 ; Carry add.
    STA BCD/MODULO/DIGITS_USE_B ; Store to.
    SEC ; Prep sub.
    LDY #$04 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    SBC BCD/MODULO/DIGITS_USE_A ; Sub with.
    STA BCD/MODULO/DIGITS_USE_A ; Store result.
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from stream.
    SBC BCD/MODULO/DIGITS_USE_B ; Sub with carry.
    STA BCD/MODULO/DIGITS_USE_B ; Store result.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    ADC #$A4 ; += 0xA4
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store to.
    LDA SCRIPT_PAIR_PTR?+1 ; Load ??
    ADC #$00 ; Carry add.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store.
    SEC ; Prep sub.
    LDY #$06 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from file.
    SBC SAVE_GAME_MOD_PAGE_PTR[2] ; Mod val.
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store.
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load stream.
    SBC SAVE_GAME_MOD_PAGE_PTR+1 ; Mod val.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store result.
    LDY #$08 ; Stream index.
    LDA BCD/MODULO/DIGITS_USE_B ; Load.
    AND #$04 ; Keep bit.
    ASL A ; << 5, *32.
    ASL A
    ASL A
    ASL A
    ASL A ; 0000.0100 -> 1000.0000
    ORA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Set at ptr.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA SAVE_GAME_MOD_PAGE_PTR+1 ; Load.
    AND #$04 ; Keep bit.
    ASL A ; Save as above.
    ASL A
    ASL A
    ASL A
    ASL A
    ORA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Set at ptr.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY ; Stream++
    LDA BCD/MODULO/DIGITS_USE_A ; Load val.
    LSR BCD/MODULO/DIGITS_USE_B ; Shift down.
    ROR A ; Into A.
    LSR BCD/MODULO/DIGITS_USE_B ; 2x
    ROR A
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store at ptr.
    INY ; Stream++
    LDA SAVE_GAME_MOD_PAGE_PTR[2] ; Load val.
    LSR SAVE_GAME_MOD_PAGE_PTR+1 ; Shift down.
    ROR A ; Into A.
    LSR SAVE_GAME_MOD_PAGE_PTR+1 ; 2x
    ROR A
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Store at ptr.
    LDA ROUTINE_SWITCH_UNK ; Load ??
    BMI VAL_NEGATIVE ; Negative, goto.
    LDY #$04 ; Stream index.
    LDA STREAM_WRITE_ARR_UNK[4] ; Move arr to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY
    LDA STREAM_WRITE_ARR_UNK+1 ; 2x
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$06 ; Stream index load. INY better mistake.
    LDA STREAM_WRITE_ARR_UNK+2
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY
    LDA STREAM_WRITE_ARR_UNK+3
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY #$11 ; Stream mod.
    LDA STREAM_DEEP_INDEX ; Move to stream.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY
    LDA STREAM_DEEP_C ; 2x
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    INY
    LDA STREAM_DEEP_D? ; 3x
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y
    LDY STREAM_DEEP_INDEX ; Load val.
    LDA SAVE_ID_FOCUS ; Load ??
    STA [STREAM_DEEP_C],Y
STREAM_NEG: ; 1E:1FAF, 0x03DFAF
    LDY LOCAL_VARS_ARR?+1 ; Load ??
    LDA SAVE_ID_FOCUS ; Load ??
    EOR [LOCAL_VARS_ARR?+2],Y ; Invert at stream.
    BEQ INVERT_EQ_0x00 ; == 0, goto.
    RTS ; Leave if nonzero.
VAL_NEGATIVE: ; 1E:1FB8, 0x03DFB8
    LDY LOCAL_VARS_ARR?+1 ; Load ??
    LDA SAVE_ID_FOCUS ; Load ?? for stream.
INVERT_EQ_0x00: ; 1E:1FBC, 0x03DFBC
    STA [LOCAL_VARS_ARR?+2],Y ; Store to stream.
    RTS ; Leave.
LIB_STREAM_SETUP_UNK: ; 1E:1FBF, 0x03DFBF
    LDY #$11 ; Stream index.
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Move ??
    STA STREAM_DEEP_INDEX
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Move ??
    STA STREAM_DEEP_C
    INY ; Stream++
    LDA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Move ??
    STA STREAM_DEEP_D?
    LDA #$00 ; Val ??
    LDY STREAM_DEEP_INDEX ; Load stream index.
    STA [STREAM_DEEP_C],Y ; Clear ptr.
    LDY #$00 ; Stream reset.
    STA [ENGINE_MAP_OBJ_RESERVATIONS/??[2]],Y ; Load from.
    RTS ; Leave.
STREAMS_UNK_SPRITE_READ?: ; 1E:1FDA, 0x03DFDA
    LDA CURRENT_SAVE_MANIPULATION_PAGE+543 ; Load ??
    LSR A ; >> 1, /2.
    LDA #$80 ; Seed ??
    LDX #$67
    LDY #$2C ; Val ??
    BCC CARRY_CLEAR_VALS
    LDA #$00 ; Alt vals, CS.
    LDX #$68
    LDY #$28 ; Val??
CARRY_CLEAR_VALS: ; 1E:1FEC, 0x03DFEC
    STA ENGINE_MAP_OBJ_RESERVATIONS/??[2] ; Store fptr.
    STX ENGINE_MAP_OBJ_RESERVATIONS/??+1
    STY SAVE_ID_FOCUS ; Store ??
    LDA #$18
    STA E3_TARGET_UNK ; Set ??
    LDA #$00
    STA OBJ?_BYTE_0x0_STATUS? ; Set ??
    LDX #$08 ; Val ??
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable writes.
