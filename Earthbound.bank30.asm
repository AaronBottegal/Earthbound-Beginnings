    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db B6
    .db 42
    .db 04
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 20
    .db 49
    .db B5
    .db AA
    .db AA
    .db 4A
    .db 24
    .db 01
    .db 51
    .db DA
    .db B6
    .db AA
    .db 6D
    .db F7
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db F6
    .db 76 ; PTR set to here.
    .db DB
    .db AB
    .db 55
    .db A5
    .db 44
    .db 10
    .db 20
    .db 00
    .db 00
    .db 04
    .db 08
    .db 90
    .db 28
    .db 51
    .db AA
    .db 5A
    .db B5
    .db 6D
    .db 7B
    .db F7
    .db EE
    .db DD
    .db B7
    .db 77
    .db 5B
    .db 5B
    .db B5
    .db 52
    .db 49
    .db 12
    .db 12
    .db 09
    .db 12
    .db 22
    .db 49
    .db 48
    .db A5
    .db 2A
    .db 55
    .db 65
    .db B5
    .db B5
    .db AD
    .db B6
    .db 6D
    .db DB
    .db B6
    .db 6D
    .db DB
    .db B6
    .db B5
    .db AD
    .db D6
    .db AA
    .db 2A
    .db 55
    .db 4A
    .db A5
    .db 24
    .db 49
    .db 2A
    .db 09
    .db 95
    .db A2
    .db 54
    .db 49
    .db 53
    .db B5
    .db 44
    .db 6A
    .db D5
    .db 6A
    .db AD
    .db D6
    .db 44
    .db 00
    .db AB
    .db 6A
    .db D5
    .db 44
    .db 44
    .db AD
    .db 44
    .db 44
    .db 44
    .db 54
    .db 44
    .db 95
    .db 44
    .db 52
    .db 00
    .db 00
    .db FF
    .db B7
    .db 20
    .db 0B
    .db 00
    .db 00
    .db 00
    .db 00
    .db C0
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db C0
    .db 0B
    .db 00
    .db 00
    .db 80
    .db FD
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db 17
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db F0
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db 7E
    .db 51
    .db ED
    .db 44
    .db 81
    .db 10
    .db 01
    .db 82
    .db 18
    .db 2B
    .db 42
    .db 53
    .db 81
    .db 6F
    .db D8
    .db DB
    .db EB
    .db E7
    .db BF
    .db EB
    .db 1F
    .db FB
    .db 95
    .db 24
    .db 48
    .db 00
    .db 02
    .db 00
    .db E0
    .db C5
    .db C0
    .db BF
    .db F8
    .db FF
    .db FF
    .db BA
    .db 0E
    .db 7E
    .db C4
    .db 50
    .db 68
    .db 2A
    .db 56
    .db 02
    .db 6F
    .db 77
    .db 4E
    .db F8
    .db 45
    .db 95
    .db 20
    .db 56
    .db 50
    .db 63
    .db 3F
    .db F4
    .db FF
    .db F0
    .db 9D
    .db F8
    .db 21
    .db B2
    .db 20
    .db 8E
    .db 0D
    .db 18
    .db CF
    .db 82
    .db AF
    .db 8A
    .db E3
    .db 3F
    .db 78
    .db FD
    .db 18
    .db CE
    .db 02
    .db 87
    .db 58
    .db E0
    .db C4
    .db 47
    .db E9
    .db DF
    .db F1
    .db 53
    .db 3B
    .db 8A
    .db 97
    .db 38
    .db 08
    .db A9
    .db 03
    .db DE
    .db E2
    .db F8
    .db 0F
    .db 9E
    .db EC
    .db 89
    .db B2
    .db 07
    .db 38
    .db E2
    .db 63
    .db F1
    .db E3
    .db C3
    .db 7B
    .db 42
    .db AF
    .db 28
    .db 8E
    .db 2A
    .db 8E
    .db 42
    .db 83
    .db 5A
    .db 1D
    .db FA
    .db B1
    .db EB
    .db AB
    .db D6
    .db 62
    .db DA
    .db A1
    .db E2
    .db D0
    .db 34
    .db 9C
    .db 85
    .db 8E
    .db AE
    .db C4
    .db 7A
    .db 72
    .db 1D
    .db A6
    .db 55
    .db 1C
    .db B9
    .db 52
    .db 3D
    .db 8B
    .db 9E
    .db 9D
    .db 4E
    .db 96
    .db 2A
    .db 0B
    .db E2
    .db A8
    .db A4
    .db 95
    .db 2D
    .db BB
    .db 72
    .db AD
    .db F4
    .db 91
    .db 5A
    .db 8B
    .db 52
    .db 25
    .db 4E
    .db 9C
    .db 5A
    .db 79
    .db 6A
    .db D7
    .db A4
    .db 8E
    .db 9C
    .db 74
    .db B0
    .db A2
    .db B4
    .db 89
    .db 67
    .db 35
    .db 6D
    .db 2B
    .db 37
    .db B6
    .db 45
    .db A5
    .db A9
    .db C5
    .db A4
    .db 42
    .db 34
    .db 26
    .db 54
    .db 44
    .db 44
    .db 04
    .db 44
    .db 00
    .db 4A
    .db 44
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db ED
    .db BA
    .db 98
    .db 76
    .db 78
    .db 97
    .db AB
    .db CD
    .db A7
    .db 47
    .db 76
    .db 48
    .db 45
    .db 66
    .db 77
    .db 89
    .db FC
    .db 97
    .db 64
    .db FC
    .db 97
    .db 65
    .db FC
    .db 86
    .db 01
    .db 23
    .db 45
    .db 67
    .db 89
    .db AB
    .db CD
    .db EF
    .db FE
    .db A9
    .db ED
    .db FD
    .db 79
    .db BD
    .db FE
    .db D9
    .db 45
    .db 78
    .db 99
    .db AA
    .db BB
    .db CC
    .db DD
    .db EF
    .db 7A
    .db DE
    .db FF
    .db EF
    .db FD
    .db DF
    .db FE
    .db EF
    .db EF
    .db FD
    .db EF
    .db FE
    .db DF
    .db FF
    .db EE
    .db EE
    .db FF
    .db EF
    .db FF
    .db FF
    .db FF
    .db EF
    .db EF
    .db FF
    .db FF
    .db EF
    .db FF
    .db FF
    .db FF
    .db EF
    .db EF
    .db FF
    .db BF
    .db FF
    .db EE
    .db EE
    .db ED
    .db ED
    .db DD
    .db BB
    .db BB
    .db AA
    .db AA
    .db 99
    .db 98
    .db 87
    .db 76
    .db 65
    .db 54
    .db 44
    .db 33
    .db 22
    .db 22
    .db 22
    .db 22
    .db 22
    .db 22
    .db 22
    .db 11
    .db 11
    .db 11
    .db 11
    .db 11
    .db 11
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    .db FF
    LDA #$0F
    STA **:$0100 ; Set ??
    LDA #$03 ; Set config for R3.
    ORA ENGINE_MAPPER_CONFIG_STATUS_NO_BANK ; Set with other bits.
    STA MMC3_BANK_CFG ; Store R3 config.
    LDX #$09 ; Seed bank config, R1?
    LDY #$02 ; Loop delay.
DELAY_LOOP_Y_A: ; 1E:0210, 0x03C210
    DEY ; --
    BNE DELAY_LOOP_Y_A ; != 0, loop.
    BIT **:$0000 ; Test ??, for delay only?
    JMP DELAY_Y_0x4 ; Goto.
LIB_WRITE_LATCH: ; 1E:0218, 0x03C218
    STA MMC3_IRQ_LATCH ; A to latch.
    LDA #$02 ; Load R2.
    ORA ENGINE_MAPPER_CONFIG_STATUS_NO_BANK ; Set mapper config.
    TAX ; To X.
DELAY_Y_0x4: ; 1E:0220, 0x03C220
    LDY #$04 ; Seed delay.
DELAY_LOOP_Y_B: ; 1E:0222, 0x03C222
    DEY ; Y--
    BNE DELAY_LOOP_Y_B ; != 0, loop delay.
    RTS ; Leave.
LIB_RETURN_HANDLER_UNK: ; 1E:0226, 0x03C226
    LDA #$0F ; Val ??
    STA **:$0100 ; Set ??
    RTS ; Leave.
DICTIONARY_ALT_VALS: ; 1E:022C, 0x03C22C
    .db 00 ; 0x00
    .db 01
    .db 02
    .db 03
    .db 08
    .db 09
    .db 96
    .db 97
    .db 98 ; 0x08
    .db 99
    .db 9A
    .db 9B
    .db 9C
    .db 9D
    .db 9E
    .db 9F
    .db A0 ; 0x10
    .db A1
    .db A2
    .db A3
    .db A4
    .db 2A
    .db 2B
    .db 2C
    .db 2D
    .db 2E
    .db AA
    .db AB
    .db AC
    .db AD
    .db AE
    .db 93
    .db 04 ; 0x20
    .db 05
    .db 06
    .db 07
    .db 0E
    .db 0F
    .db D6
    .db D7
    .db D8
    .db D9
    .db DA
    .db DB
    .db DC
    .db DD
    .db DE
    .db DF
    .db E0 ; 0x30
    .db E1
    .db E2
    .db E3
    .db E4
    .db 6A
    .db 6B
    .db 6C
    .db 6D
    .db 6E
    .db EA
    .db EB
    .db EC
    .db ED
    .db EE
    .db D3
PACKETS_IDK: ; 1E:026C, 0x03C26C
    LDA #$D9 ; Set FPTR, ??:11D9
    LDX #$91
    STA FPTR_PACKET_CREATION[2]
    STX FPTR_PACKET_CREATION+1
LATCH_NO_FLAG_RTN: ; 1E:0274, 0x03C274
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Do ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA #$19
    LDX #$B2
    LDY #$A2
    JSR ENGINE_SCRIPT_LAUNCH_R7_A_PTR_XY ; Script launch 19:02B2
    LDA #$00
    STA NMI_LATCH_FLAG ; Clear ??
    LDA #$FF
    STA **:$07F7 ; Set ??
    LDA #$0F
    STA APU_STATUS ; Enable APU channels.
    JSR ENGINE_NMI_0x01_SET/WAIT ; Wait.
    LDX #$00 ; IRQ index.
SLOT_LT_0x1A?: ; 1E:0296, 0x03C296
    LDA #$25 ; Load PTR L.
    STA IRQ_SCRIPT_B,X ; Store it.
    INX ; Index++
    LDA #$C2 ; Load PTR H.
    STA IRQ_SCRIPT_B,X ; Store it.
    INX ; Index++
    CPX #$1A ; If _ #$1A
    BNE SLOT_LT_0x1A? ; !=, loop.
    LDA #$00
    STA IRQ_SCRIPT_B,X ; Clear PTR L. For end signal?
    INX ; Index++
    STA IRQ_SCRIPT_B,X ; Clear PTR H.
    LDA #$0F
    STA NMI_LATCH_FLAG ; Set latch.
LATCH_FLAG_RTN: ; 1E:02B3, 0x03C2B3
    JSR LIB_PRG_HELPER_R6_TO_0x00 ; Do.
SWITCH_NONZERO: ; 1E:02B6, 0x03C2B6
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDX #$00
    STX NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Create.
    STY NMI_PPU_CMD_PACKETS_INDEX ; Y to.
    INC PACKET_YPOS_COORD? ; ++
    LDY #$00 ; Stream reset.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load from file.
    PHA ; To stack.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; 2x
    PHA
    INY
    TYA ; Stream to A.
    JSR FORWARD_PACKET_CREATION_FP_BY_A ; Forward ptr.
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$00 ; If _ #$00
    BNE VAL_NONZERO ; != 0, goto.
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Do.
    JSR SCRIPT_UPDATES_AND_MORE_UNK ; Do.
    PLA ; Pull A.
    TAX ; To X.
    PLA ; Pull A.
    CMP IRQ_SCRIPT_B,X ; If _ arr
    BCC VAL_LT_ARR ; << goto.
    STA IRQ_SCRIPT_B,X ; >=, store.
VAL_LT_ARR: ; 1E:02E9, 0x03C2E9
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$00 ; If _ #$00
    BNE SWITCH_NONZERO ; != 0, goto.
    RTS ; Leave.
VAL_NONZERO: ; 1E:02F0, 0x03C2F0
    INC PACKET_YPOS_COORD? ; ++
    JSR SETUP_CREATION_DEC ; Do.
    JSR SCRIPT_UPDATES_AND_MORE_UNK ; Do.
    PLA ; Pull A.
    TAX ; To index.
    PLA ; Pull A.
    CMP IRQ_SCRIPT_B,X ; If _ arr
    BCC VAL_LT ; <, goto.
    STA IRQ_SCRIPT_B,X ; >=, store.
VAL_LT: ; 1E:0303, 0x03C303
    JMP LATCH_FLAG_RTN ; Do ??
SCRIPT_UPDATES_AND_MORE_UNK: ; 1E:0306, 0x03C306
    STY NMI_PPU_CMD_PACKETS_INDEX ; Store index.
    JSR LIB_UGH_MORE ; Do ??
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Clear for EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    LDA #$19
    LDX #$1D
    LDY #$A3
    JSR ENGINE_SCRIPT_LAUNCH_R7_A_PTR_XY ; Script launch 19:031D
    JMP WAIT_NMI/IRQ_CLEAR ; Do, abuse RTS.
LIB_PRG_HELPER_R6_TO_0x00: ; 1E:0322, 0x03C322
    LDA #$00 ; Bank.
    LDX #$06 ; R6.
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set it, abuse RTS.
    .db 20
    .db 01
    .db 17
    .db 21
    .db 4B
    .db 92
    .db 01
    .db 25
    .db 16
    .db 21
    .db 10
    .db 67
    .db 00
    .db 25
    .db 18
    .db FB
    .db 22
    .db FC
    .db 1C
    .db FD
    .db 00
    .db 20
    .db 01
    .db 15
    .db 21
    .db 4B
    .db 92
    .db 01
    .db 25
    .db 14
    .db 21
    .db 10
    .db 67
    .db 01
    .db 25
    .db 16
    .db 21
    .db 2E
    .db 67
    .db 00
    .db 25
    .db 18
    .db FB
    .db 22
    .db FC
    .db 1C
    .db FD
    .db 00
    .db 20
    .db 01
    .db 13
    .db 21
    .db 4B
    .db 92
    .db 01
    .db 25
    .db 12
    .db 21
    .db 10
    .db 67
    .db 01
    .db 25
    .db 14
    .db 21
    .db 2E
    .db 67
    .db 01
    .db 25
    .db 16
    .db 21
    .db 4C
    .db 67
    .db 00
    .db 25
    .db 18
    .db FB
    .db 22
    .db FC
    .db 1C
    .db FD
    .db 00
ROM_DATA_UNK: ; 1E:037A, 0x03C37A
    .db 24 ; 0x0, Data[3]
    .db A0
    .db 23
    .db 38 ; Addr mod L.
    .db 00 ; H.
    .db 00 ; 0x1
    .db 07
    .db 23
    .db 10
    .db 00
    .db 01 ; 0x2
    .db 03
    .db 23
    .db 14
    .db 00
    .db 02 ; 0x3
    .db 04
    .db 23
    .db 16
    .db 00
    .db 02 ; 0x4
    .db 04
    .db 23
    .db 11
    .db 00
    .db 03 ; 0x5
    .db 08
    .db A0
    .db 25
    .db 00
DATA_TABLE_SMOL: ; 1E:0398, 0x03C398
    .db 01
    .db 04
    .db A0
    .db A0
    .db 21
    .db A0
    .db A1
    .db 00
    LDA #$6A
    LDX #$92
FPTR_SEED_UNK_LATCH_CHECK: ; 1E:03A4, 0x03C3A4
    STA FPTR_PACKET_CREATION[2] ; Store PTR.
    STX FPTR_PACKET_CREATION+1
    LDA NMI_LATCH_FLAG ; Load.
    BEQ LATCH_FLAG ; == 0, goto.
    JMP LATCH_FLAG_RTN ; Do ??
LATCH_FLAG: ; 1E:03AF, 0x03C3AF
    JMP LATCH_NO_FLAG_RTN ; Goto.
PTR_SEEDED_UNK_A: ; 1E:03B2, 0x03C3B2
    LDA #$9B
    LDX #$92
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_B: ; 1E:03B9, 0x03C3B9
    LDA #$CF
    LDX #$92
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_C: ; 1E:03C0, 0x03C3C0
    LDA #$00
    LDX #$93
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEDED_UNK_D: ; 1E:03C7, 0x03C3C7
    LDA #$17
    LDX #$93
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_E: ; 1E:03CE, 0x03C3CE
    LDA #$5F
    LDX #$93
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_F_WRAM: ; 1E:03D5, 0x03C3D5
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK
PTR_SEEDED_UNK_G_WRAM: ; 1E:03D8, 0x03C3D8
    LDA #$48
    LDX #$92
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_H: ; 1E:03DF, 0x03C3DF
    LDA #$6A
    LDX #$93
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_I: ; 1E:03E6, 0x03C3E6
    LDA #$8D
    LDX #$93
    JMP FPTR_SEED_UNK_LATCH_CHECK
PTR_SEEDED_UNK_J: ; 1E:03ED, 0x03C3ED
    LDA #$1E
    LDX #$95
    JMP FPTR_SEED_UNK_LATCH_CHECK
LIB_OBJECTS_AND_SETTLE_AND_FLAGS_UNK: ; 1E:03F4, 0x03C3F4
    PHP ; Save status.
    JSR ENGINE_SETTLE_UPDATES_TODO ; Settle.
    JSR ENGINE_0x300_OBJECTS_UNK? ; Do ??
    LDA #$01
    STA NMI_FLAG_E5_TODO ; Set ??
    LDA #$00
    STA **:$07F7 ; Clear ??
    PLP ; Pull status.
    RTS ; Leave.
TODO_ROUTINE_NO_MASK_ENTRY: ; 1E:0406, 0x03C406
    LDA #$FF ; Mask, none.
TODO_ROUTINE_MASK_A: ; 1E:0408, 0x03C408
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Store passed.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; WRAM writeable.
    LDA #$00 ; Seed clear ??
LOOP_STACK_POSITIVE: ; 1E:040F, 0x03C40F
    PHA ; Save it.
    TAX ; Val to index.
    LDA STREAM_INDEXES_ARR_UNK[24],X ; Load at index.
    BEQ INDEXED_LOAD_EQ_0x00 ; == 0, goto.
    LDA STREAM_PTRS_ARR_UNK[48],X ; Move from arr to fptr for packeting.
    STA FPTR_PACKET_CREATION[2]
    LDA STREAM_PTRS_ARR_UNK+1,X
    STA FPTR_PACKET_CREATION+1
    LDY #$01 ; Stream index.
    LDA STREAM_INDEXES_ARR_UNK+1,X ; Load from arr.
    AND ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; And with ??
    STA [FPTR_PACKET_CREATION[2]],Y ; Store to file stream 0x1
    LDY #$14 ; Restream higher.
STREAM_LT_0x18: ; 1E:042B, 0x03C42B
    LDA STREAM_INDEXES_ARR_UNK+3,X ; Load from.
    STA [FPTR_PACKET_CREATION[2]],Y ; Store to file stream 0x14
    INX ; Index++
    INY ; Stream++
    CPY #$18 ; If stream _ #$18
    BCC STREAM_LT_0x18 ; < loop.
INDEXED_LOAD_EQ_0x00: ; 1E:0436, 0x03C436
    PLA ; Pull A.
    CLC ; Prep add.
    ADC #$20 ; += 0x20
    BPL LOOP_STACK_POSITIVE ; Positive, goto.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable WRAM.
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Do, enables it again, lol.
    LDA MAPPER_BANK_VALS+6 ; Load R6.
    PHA ; Save to stack.
    JSR LIB_PRG_HELPER_R6_TO_0x00 ; Do.
    LDA #$48
    LDX #$92 ; Set 00:1248
    STA FPTR_PACKET_CREATION[2] ; Store.
    STX FPTR_PACKET_CREATION+1
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Do.
    BNE RET_NONZERO ; != 0, goto.
VAL_NONZERO: ; 1E:0455, 0x03C455
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_DEC? ; Do again.
RET_NONZERO: ; 1E:0458, 0x03C458
    LDA #$02
    JSR FORWARD_PACKET_CREATION_FP_BY_A ; += 0x2
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$00 ; If _ #$00
    BNE VAL_NONZERO ; !=, loop.
    INC PACKET_YPOS_COORD? ; ++
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Do update.
    PLA ; Pull R6 saved.
    LDX #$06 ; R6 set.
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set it again, abuse RTS.
LIB_UGH_MORE: ; 1E:046E, 0x03C46E
    LDA DATA_APPEND_COUNT?
    LSR A
    ADC #$00
    TAX
    LDA PACKET_YPOS_COORD?
    AND #$1E
    ASL A
    ASL A
    ASL A
    STA PACKET_CONSUMED/INDEX?
    LDA PACKET_HPOS_COORD?
    ADC #$01
    LSR A
    ORA PACKET_CONSUMED/INDEX?
    STA PACKET_CONSUMED/INDEX?
    TAY
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDA #$FF
    STA **:$6600,Y
    INY
    DEX
    BNE 1E:048C
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED
    LDX NMI_PPU_CMD_PACKETS_BUF+2
    LDY NMI_PPU_CMD_PACKETS_BUF+3
    TYA
    CLC
    AND #$03
    ADC #$03
    ADC DATA_APPEND_COUNT?
    LSR A
    LSR A
    STA ENGINE_PTR_PACKET_MANAGER[2]
    TYA
    AND #$80
    STA PACKET_PPU_ADDR_HL+1
    TXA
    LSR A
    ROR PACKET_PPU_ADDR_HL+1
    LSR A
    ROR PACKET_PPU_ADDR_HL+1
    TYA
    AND #$1C
    ORA PACKET_PPU_ADDR_HL+1
    LSR A
    LSR A
    ORA #$C0
    STA PACKET_PPU_ADDR_HL+1
    ORA #$F8
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC
    TXA
    ORA #$03
    STA PACKET_PPU_ADDR_HL[2]
    TYA
    AND #$42
    LSR A
    LSR A
    ADC #$00
    EOR #$FF
    ADC #$01
    CLC
    ADC PACKET_CONSUMED/INDEX?
    TAY
    LDX NMI_PPU_CMD_PACKETS_INDEX
    LDA #$07
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA ENGINE_PTR_PACKET_MANAGER[2]
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA PACKET_PPU_ADDR_HL[2]
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA PACKET_PPU_ADDR_HL+1
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA **:$6600,Y
    AND #$03
    STA PACKET_CONSUMED/INDEX?
    INY
    LDA **:$6600,Y
    AND #$0C
    ORA PACKET_CONSUMED/INDEX?
    STA PACKET_CONSUMED/INDEX?
    TYA
    CLC
    ADC #$0F
    TAY
    LDA **:$6600,Y
    AND #$30
    ORA PACKET_CONSUMED/INDEX?
    STA PACKET_CONSUMED/INDEX?
    INY
    LDA **:$6600,Y
    AND #$C0
    ORA PACKET_CONSUMED/INDEX?
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    TYA
    SEC
    SBC #$0F
    TAY
    DEC ENGINE_PTR_PACKET_MANAGER[2]
    BNE 1E:0528
    STX NMI_PPU_CMD_PACKETS_INDEX
    RTS
    INC DISP_UPDATE_COUNT_SMART_INVERTED/MISC
    BEQ 1E:0531
    INC PACKET_PPU_ADDR_HL+1
    JMP 1E:04E5
    LDA #$04
    EOR PACKET_PPU_ADDR_HL[2]
    STA PACKET_PPU_ADDR_HL[2]
    LDA #$F8
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC
    AND PACKET_PPU_ADDR_HL+1
    STA PACKET_PPU_ADDR_HL+1
    JMP 1E:04E5
ENGINE_WRAM_ARR_MOD_LOOPS_UNK: ; 1E:0542, 0x03C542
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM writes.
    LDX #$10 ; Seed ??
    LDY #$00 ; Seed Y index.
    STY **:$6707 ; Set WRAM ??
LOOP_LARGEST: ; 1E:054C, 0x03C54C
    JSR STREAM_PAGE_Y_INDEXED_CC_0x01-0x05 ; Load val.
    BCS DATA_CS ; Not 0x01-0x05, goto.
    INC **:$6707 ; ++
    JSR CREATE_PTR_UNK ; Create ptr.
    TYA ; Y to A.
    PHA ; Save it to the stack.
    LDY #$00 ; Seed index start.
SLOT_INDEX_NE_0x14: ; 1E:055B, 0x03C55B
    JSR DATA_MOVE_AND_MOD_WITH_PTR_UNK ; Move and mod.
    CPY #$14 ; If _ #$14, first half of table done.
    BNE SLOT_INDEX_NE_0x14 ; !=, goto.
    TYA ; Index into table save.
    PHA
    LDY #$01 ; Seed index.
    LDA [ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]],Y ; Load from index.
    LDY #$0E ; Seed alt table index.
Y_INDEX_POSITIVE: ; 1E:056A, 0x03C56A
    ASL A ; << 1, *2.
    BCC DATA_CARRY_CLEAR_Y_SUB_LOOP ; CC, goto.
    PLA ; Pull table index saved.
    TYA ; Table index from Y seed.
    PHA
    LDY #$00 ; Reset index.
SMALL_TABLE_LOOP: ; 1E:0572, 0x03C572
    LDA DATA_TABLE_SMOL,Y ; Load index.
    STA **:$6700,X ; Store to arr.
    INX ; Indexes++
    INY
    CPY #$05 ; If _ #$05
    BNE SMALL_TABLE_LOOP ; !=, goto.
    PLA ; Pull table index.
    TAY ; Back to Y.
    LDA ROM_DATA_UNK,Y ; Move ??
    STA **:$6700,X
    INX ; Arr++
    LDA ROM_DATA_UNK_PAIR,Y ; Move pair.
    STA **:$6700,X
    INX ; Arr++
    LDY #$1B ; Seed ??
    BNE LOOP_MOVE_TABLE_TO_0x1E_UNK
DATA_CARRY_CLEAR_Y_SUB_LOOP: ; 1E:0592, 0x03C592
    DEY ; Index -= 2
    DEY
    BPL Y_INDEX_POSITIVE ; Positive, goto.
    PLA ; Pull index into table.
    TAY ; To Y.
    JSR DATA_MOVE_AND_MOD_WITH_PTR_UNK ; Do ??
LOOP_MOVE_TABLE_TO_0x1E_UNK: ; 1E:059B, 0x03C59B
    LDA ROM_DATA_UNK,Y ; Move from table.
    STA **:$6700,X
    INX ; Indexes++
    INY
    CPY #$1E ; If _ #$1E
    BNE LOOP_MOVE_TABLE_TO_0x1E_UNK ; != 0, goto.
    PLA ; Pull count ??
    TAY ; To Y.
    LDA **:$6707 ; Load ??
    CMP #$03 ; If _ #$03
    BCS VAL_GTE_0x3 ; >=, goto.
DATA_CS: ; 1E:05B0, 0x03C5B0
    INY ; Count++
    CPY #$04 ; If _ #$04
    BCC LOOP_LARGEST ; <, goto.
VAL_GTE_0x3: ; 1E:05B5, 0x03C5B5
    LDA #$00
    STA **:$6704 ; Clear ??
    STA **:$6705
    STA **:$6706
    SEC ; Prep sub.
    LDA #$03 ; Sub val.
    SBC **:$6707 ; 3 - var
    TAX ; To X.
    LDY #$00 ; Reset index.
VAL_LT_0x4: ; 1E:05C9, 0x03C5C9
    JSR STREAM_PAGE_Y_INDEXED_CC_0x01-0x05 ; Do.
    BCS DATA_RET_OTHER
    STA **:$6704,X ; Store to arr.
    INX ; Index++
    CPX #$03 ; If _ #$03
    BCS DATA_GTE_0x3 ; >=, goto.
DATA_RET_OTHER: ; 1E:05D6, 0x03C5D6
    INY ; Index++
    CPY #$04 ; If _ #$04
    BCC VAL_LT_0x4 ; <, goto.
DATA_GTE_0x3: ; 1E:05DB, 0x03C5DB
    LDA **:$6707 ; Load ??
    ASL A ; << 1, *2.
    TAX ; To X index.
    LDA #$04
    STA **:$6700 ; Set ??
    STA **:$670A ; Set ??
    CPX #$04 ; If _ #$04
    BCS X_GTE_0x4 ; >=, goto.
    LDA #$00 ; Seed 0x00
X_GTE_0x4: ; 1E:05EE, 0x03C5EE
    STA **:$670D ; Set 0x4/0x0
    LDA ROM_LIB_UNK,X
    STA **:$6701
    LDA ROM_LIB_PAIR,X
    STA **:$6702
    LDA **:$6713 ; Move ??
    STA **:$670B
    LDA **:$6714 ; Move ??
    STA **:$670C
    LDA #$9D ; Move ??
    STA **:$670E
    LDA #$C3 ; Move ??
    STA **:$670F
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Exit, no more WRAM writes.
ROM_LIB_UNK: ; 1E:0616, 0x03C616
    .db 3D
ROM_LIB_PAIR: ; 1E:0617, 0x03C617
    .db C3
    .db 29
    .db C3
    .db 3E
    .db C3
    .db 59
    .db C3
ROM_DATA_UNK: ; 1E:061E, 0x03C61E
    .db 29
ROM_DATA_UNK_PAIR: ; 1E:061F, 0x03C61F
    .db 86
    .db 22
    .db 86
    .db 1B
    .db 86
    .db 14
    .db 86
    .db 0D
    .db 86
    .db 06
    .db 86
    .db FF
    .db 85
    .db F8
    .db 85
STREAM_PAGE_Y_INDEXED_CC_0x01-0x05: ; 1E:062E, 0x03C62E
    .db 38 ; Seed ret for 0x00.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,Y ; Load data indexed.
    BEQ RTS ; == 0, return CS.
    CMP #$06 ; If < 6, ret CC. CS otherwise.
RTS: ; 1E:0636, 0x03C636
    RTS ; Leave.
DATA_MOVE_AND_MOD_WITH_PTR_UNK: ; 1E:0637, 0x03C637
    LDA ROM_DATA_UNK,Y ; Move from Y to X indexes.
    STA **:$6700,X
    INX ; Indexes++
    INY
    LDA ROM_DATA_UNK,Y ; 2x
    STA **:$6700,X
    INX ; ++
    INY
    LDA ROM_DATA_UNK,Y ; 3x
    STA **:$6700,X
    INX ; ++
    INY
    CLC ; Prep add.
    LDA ROM_DATA_UNK,Y ; Load from arr.
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Add with ptr L.
    STA **:$6700,X ; Store to arr.
    INX ; ++
    INY
    LDA ROM_DATA_UNK,Y ; Load from arr.
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Add with ptr H.
    STA **:$6700,X ; Store to arr.
    INX ; ++
    INY
    RTS
CREATE_PTR_UNK: ; 1E:0665, 0x03C665
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Store arg. AAAA.AABB
    LDA #$00 ; Clear for shifts low.
    LSR ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Shift bit off.
    ROR A ; Into A.
    LSR ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; 2x
    ROR A
    ADC #$00 ; Carry to bit 0, fancy. But never anything here.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Store to, addr L.
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Load passed val 00AA.AAAA
    ADC #$74 ; Add with, PTR offset base. Range of 0x74-B3.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Store addr H.
    RTS
UPDATE_BUF_FROM_FILE_HELPER_UNK: ; 1E:067A, 0x03C67A
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Create file.
    BNE RETURN_NONZERO ; != 0, goto. TODO: Taken chance.
VAL_RET_NONZERO: ; 1E:067F, 0x03C67F
    JSR ENGINE_CREATE_UPDATE_BUF_INIT_DEC? ; Do.
RETURN_NONZERO: ; 1E:0682, 0x03C682
    CMP #$00 ; If _ #$00
    BNE VAL_RET_NONZERO ; != 0, goto.
    INC PACKET_YPOS_COORD? ; ++
    JMP ENGINE_CREATE_UPDATE_BUF_INIT_INC? ; Run, abuse RTS.
ENGINE_A_TO_UPDATE_PACKET: ; 1E:068B, 0x03C68B
    PHA ; Save A.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR PACKET_CALC_COORDS_TO_VADDR ; Calc screen pos.
    LDA #$05
    STA NMI_PPU_CMD_PACKETS_BUF[64] ; Set type, data upload +1 mode.
    LDA #$01 ; 1 byte.
    STA NMI_PPU_CMD_PACKETS_BUF+1
    LDA PACKET_PPU_ADDR_HL[2] ; Addr.
    STA NMI_PPU_CMD_PACKETS_BUF+2
    LDA PACKET_PPU_ADDR_HL+1
    STA NMI_PPU_CMD_PACKETS_BUF+3
    PLA ; Value from stack as tile.
    STA NMI_PPU_CMD_PACKETS_BUF+4 ; Store to.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+5 ; End of file.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    RTS ; Leave.
ENGINE_PACKET_FINALIZATION_HELPER: ; 1E:06B6, 0x03C6B6
    LDA R_**:$0070 ; Load ??
    CLC ; Prep sub with extra.
    SBC DATA_APPEND_COUNT? ; Sub with.
    BCC PACKET_HAS_NO_SIZE ; Underflow, goto. Nice off by one shenanigans.
    TAY ; A to Y, loop count.
POST_APPEND_0xA0_TO_BUF: ; 1E:06BE, 0x03C6BE
    LDA #$A0 ; Seed data.
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append to buf.
    DEY ; Count--
    BPL POST_APPEND_0xA0_TO_BUF ; Positive, loop more.
    LDY NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Load size of packet finally.
    BEQ PACKET_HAS_NO_SIZE ; == 0, goto.
    TXA ; Use the X index for the new index, put it in Y. TODO: Store+RTS Directly. +1 Byte, faster.
    TAY
PACKET_HAS_NO_SIZE: ; 1E:06CF, 0x03C6CF
    STY NMI_PPU_CMD_PACKETS_INDEX ; Store Y index.
    RTS ; Leave.
ENGINE_CREATE_UPDATE_BUF_INIT_INC?: ; 1E:06D2, 0x03C6D2
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDX #$00
    STX NMI_PPU_CMD_PACKETS_INDEX ; Reset update index.
    BEQ ALT_ENTRY ; Always taken here.
ENGINE_CREATE_UPDATE_BUF_INIT_DEC?: ; 1E:06DB, 0x03C6DB
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDX #$00
    STX NMI_PPU_CMD_PACKETS_INDEX ; Reset too.
    JSR SETUP_CREATION_DEC ; TODO: What do.
    JSR ENGINE_PACKET_FINALIZATION_HELPER ; Finalize this one.
ALT_ENTRY: ; 1E:06E8, 0x03C6E8
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Create packet with fptr.
    JSR ENGINE_PACKET_FINALIZATION_HELPER ; Finalize the packet, appending maybe.
    LDA #$00 ; Clear val.
    STA NMI_PPU_CMD_PACKETS_BUF[64],Y ; EOF the packet.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag ??
ADDS_IDFK: ; 1E:06F9, 0x03C6F9
    JSR ENGINE_UNK_CARRY_ADDS_??? ; Add because ??
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load.
    CMP #$01 ; If _ #$01
    BNE RTS ; !=, goto.
    INC PACKET_YPOS_COORD? ; += 2
    INC PACKET_YPOS_COORD? ; To next screen maybe?
RTS: ; 1E:0706, 0x03C706
    RTS ; Leave.
RTN_SETTLE_UPDATE_TODO: ; 1E:0707, 0x03C707
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA #$33
    STA NMI_PPU_CMD_PACKETS_INDEX ; Set index.
    PHA ; Save.
    JSR ENGINE_PACKET_CREATE_FROM_FILE ; Create packet.
    JSR ENGINE_PACKET_FINALIZATION_HELPER ; Finalize.
    STY DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Index to.
    PLA ; Pull A.
    TAX ; To X.
    LDA #$05
    STA NMI_PPU_CMD_PACKETS_BUF[64] ; Type.
    LDA #$01
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Count.
ROUTINE_LOOP: ; 1E:0723, 0x03C723
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],Y ; Clear indexed.
    CPX DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; If X _ val
    BCS ADDS_IDFK ; >=, CS, goto. EXIT<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    LDA #$08
    STA NMI_PPU_CMD_PACKETS_BUF[64],Y ; Type, bulk upload.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,X ; Load X.
    STA DATA_APPEND_COUNT? ; Store to.
    STA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Store to.
    LDA #$A0 ; Clear tile.
    STA NMI_PPU_CMD_PACKETS_BUF+4,Y ; Set.
    CLC ; Prep add.
    LDA NMI_PPU_CMD_PACKETS_BUF+3,X ; Load X.
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Store to.
    ADC #$20 ; To next row.
    STA NMI_PPU_CMD_PACKETS_BUF+3,Y ; Store result.
    LDA NMI_PPU_CMD_PACKETS_BUF+2,X ; Load X.
    STA NMI_PPU_CMD_PACKETS_BUF+2 ; Carry add.
    ADC #$00
    STA NMI_PPU_CMD_PACKETS_BUF+2,Y
    TXA ; X to A.
    CLC ; Prep add.
    ADC #$04 ; += 0x4
    TAX ; Back to X.
    TYA ; Y to A.
    CLC ; Prep add.
    ADC #$05 ; += 0x5
    TAY ; To Y.
LOOP_COUNT: ; 1E:075F, 0x03C75F
    LDA NMI_PPU_CMD_PACKETS_BUF[64],X ; Load from X.
    STA NMI_PPU_CMD_PACKETS_BUF+4 ; Store to. TODO: Byte?
    CMP #$A0 ; If _ #$A0
    BEQ PACKET_END ; ==, goto.
    LDA SCRIPT_UNK_TESTED ; Load.
    BMI PACKET_END ; Negative, goto.
    EOR #$01 ; Invert.
    STA SCRIPT_UNK_TESTED ; Store to.
    LSR A ; >> 1, /2.
    BCC PACKET_END ; CC, goto.
    LDA #$0E
    STA **:$07F1 ; Set ??
PACKET_END: ; 1E:077B, 0x03C77B
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+5
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    BIT SCRIPT_UNK_TESTED ; Test.
    BVC BIT_0x40_CLEAR ; 0x40 set.
    TXA ; X to A.
    PHA ; Save X.
    LDA NMI_PPU_CMD_PACKETS_BUF+4 ; Load.
    LDX #$28 ; Delay.
    CMP #$AE ; If _ #$AE
    BEQ DELAY_X_COUNT ; ==, goto.
    CMP #$AC ; If _ #$AC
    BEQ DELAY_X_COUNT ; ==, goto.
    LDX #$03 ; Alt delay.
DELAY_X_COUNT: ; 1E:079F, 0x03C79F
    JSR ENGINE_DELAY_X_FRAMES ; Delay count.
    PLA ; Pull A.
    TAX ; Back to X.
BIT_0x40_CLEAR: ; 1E:07A4, 0x03C7A4
    INC NMI_PPU_CMD_PACKETS_BUF+3 ; ++
    INX ; X++
    DEC DATA_APPEND_COUNT? ; --
    BNE LOOP_COUNT ; != 0, GOTO.
    JMP ROUTINE_LOOP ; Loop.
L_1E:07AF: ; 1E:07AF, 0x03C7AF
    CMP #$01
    BNE 1E:07C0
    PHA
    LDX #$A4
    LDA NMI_PPU_CMD_PACKETS_BUF+50,X
    STA **:$045B,X
    DEX
    BNE 1E:07B6
    PLA
    RTS
L_1E:07C1: ; 1E:07C1, 0x03C7C1
    LDA #$33
    CLC
    ADC #$29
    DEX
    BNE 1E:07C3
    STX PACKET_PRE_SEED_0xA0_COUNT
    TAX
    PHA
    JSR 1E:07D4
    STA PACKET_PRE_SEED_0xA0_COUNT
    PLA
    TAX
    JSR ENGINE_SETTLE_ALL_UPDATES?
    STX NMI_PPU_CMD_PACKETS_INDEX
    LDA NMI_PPU_CMD_PACKETS_BUF[64],X
    BEQ 1E:07FD
    EOR #$05
    BNE 1E:07F3
    ORA PACKET_PRE_SEED_0xA0_COUNT
    BNE 1E:07E9
    JSR 1E:080E
    TXA
    CLC
    ADC #$04
    ADC NMI_PPU_CMD_PACKETS_BUF+1,X
    TAX
    BCC 1E:07D9
    JSR 1E:080E
    TXA
    CLC
    ADC #$05
    TAX
    BCC 1E:07D9
    STA PACKET_PRE_SEED_0xA0_COUNT
    SEC
    LDA NMI_PPU_CMD_PACKETS_INDEX
    SBC #$29
    TAX
    LDA #$80
    STA NMI_FLAG_E5_TODO
    CPX #$5C
    BCS 1E:07D4
    RTS
    SEC
    LDA NMI_PPU_CMD_PACKETS_BUF+3,X
    SBC #$20
    STA NMI_PPU_CMD_PACKETS_BUF+3,X
    LDA NMI_PPU_CMD_PACKETS_BUF+2,X
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC
    SBC #$00
    STA NMI_PPU_CMD_PACKETS_BUF+2,X
    EOR DISP_UPDATE_COUNT_SMART_INVERTED/MISC
    AND #$04
    BEQ 1E:083C
    SEC
    LDA NMI_PPU_CMD_PACKETS_BUF+3,X
    SBC #$40
    STA NMI_PPU_CMD_PACKETS_BUF+3,X
    LDA NMI_PPU_CMD_PACKETS_BUF+2,X
    SBC #$04
    AND #$0F
    ORA #$20
    STA NMI_PPU_CMD_PACKETS_BUF+2,X
    RTS
ENGINE_PACKET_CREATE_FROM_FILE: ; 1E:083D, 0x03C83D
    JSR PACKET_CALC_COORDS_TO_VADDR
    LDA ENGINE_PACKINATOR_ARG_SEED_0xA0_PRE_COUNT ; Move count?
    STA PACKET_PRE_SEED_0xA0_COUNT ; Copy to us.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load index for packet.
    LDY #$00
    STY DATA_APPEND_COUNT? ; No appends.
    TYA ; Clear A.
    PHA ; Argument 0x00
    JSR PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN ; Header.
PACKET_CREATION_LOO_SMOL: ; 1E:084F, 0x03C84F
    DEC PACKET_PRE_SEED_0xA0_COUNT ; Preseed count.
    BPL SEED_0xA0_TO_PACKET ; Positive, seed instead.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load from stream.
    JSR ENGINE_DATA_DICT_MOD_A_UNK ; Do mod on data.
    BCS DATA_TO_PACKET ; Ret CS, use data as-is. Otherwise, A is a function re-launch.
    LDY #$4F
    STY ENGINE_PTR_PACKET_MANAGER[2] ; Seed 14:084F above as return?
    LDY #$C8
    STY ENGINE_PTR_PACKET_MANAGER+1
    JMP LAUNCH_PACKET_UPDATE_SCRIPTS ; Launch rtn from var pulled.
SEED_0xA0_TO_PACKET: ; 1E:0865, 0x03C865
    LDA #$A0 ; Seed 0xA0 instead.
DATA_TO_PACKET: ; 1E:0867, 0x03C867
    JSR APPEND_DATA_TO_UPDATE_BUF ; Store/do ??
    JMP PACKET_CREATION_LOO_SMOL ; More data.
SETUP_CREATION_DEC: ; 1E:086D, 0x03C86D
    DEC PACKET_YPOS_COORD? ; --
    JSR PACKET_CALC_COORDS_TO_VADDR ; Calc pos.
    LDA ENGINE_PACKINATOR_ARG_SEED_0xA0_PRE_COUNT ; Move to local.
    STA PACKET_PRE_SEED_0xA0_COUNT ; Set count to seed.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDY #$00
    STY DATA_APPEND_COUNT? ; Clear count.
    TYA ; Clear A.
    PHA ; Save 0x00 to stack.
    JSR PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN ; Header it.
CREATION_LOOP_DOWN?: ; 1E:0881, 0x03C881
    DEC PACKET_PRE_SEED_0xA0_COUNT ; --
    BPL SEED_PACKET_0xA0 ; Positive, goto.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Otherwise load from file.
    JSR ENGINE_DATA_DICT_MOD_B_UNK ; Do mod.
    BCS DATA_USE ; Ret CS, append to buffer. Not command.
    ORA #$80 ; Set down/sub/dec flag?
    LDY #$81
    STY ENGINE_PTR_PACKET_MANAGER[2] ; Set 1E:0881 as handler.
    LDY #$C8
    STY ENGINE_PTR_PACKET_MANAGER+1
    JMP LAUNCH_PACKET_UPDATE_SCRIPTS ; Launch script with data instead right now.
SEED_PACKET_0xA0: ; 1E:0899, 0x03C899
    LDA #$A0 ; Append 0xA0.
DATA_USE: ; 1E:089B, 0x03C89B
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append A to buf.
    JMP CREATION_LOOP_DOWN? ; Loop.
LAUNCH_PACKET_UPDATE_SCRIPTS: ; 1E:08A1, 0x03C8A1
    STA ENGINE_SCRIPT_SWITCH_VAL? ; Val to.
    ASL A ; << 1, *2. Word index.
    TAY ; To index.
    LDA TABLE_PTR_L,Y ; Addr to stack.
    PHA
    LDA TABLE_PTR_H,Y
    PHA
    RTS ; RTS Into routine.
TABLE_PTR_H: ; 1E:08AE, 0x03C8AE
    LOW(1E:08E1) ; Arr thingy.
TABLE_PTR_L: ; 1E:08AF, 0x03C8AF
    HIGH(1E:08E1)
    LOW(1E:08E1)
    HIGH(1E:08E1)
    LOW(1E:08E1)
    HIGH(1E:08E1)
    LOW(1E:08E1)
    HIGH(1E:08E1)
    LOW(1E:0908)
    HIGH(1E:0908)
    LOW(1E:08D3)
    HIGH(1E:08D3)
    LOW(1E:092E)
    HIGH(1E:092E)
    LOW(1E:094F)
    HIGH(1E:094F)
    LOW(1E:08C1)
    HIGH(1E:08C1)
    LOW(1E:09D1)
    HIGH(1E:09D1)
SCRIPT_RTN_F: ; 1E:08C2, 0x03C8C2
    LDY PACKET_CONSUMED/INDEX? ; Stream reload.
SCRIPT_RTN_F_INDEX_SEEDED: ; 1E:08C4, 0x03C8C4
    LDA [FPTR_PACKET_CREATION[2]],Y ; Replacement pointer from stream.
    PHA ; Saved to stack for var efficiency.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load ptr H.
    STA FPTR_PACKET_CREATION+1 ; Replace ptr, L.
    PLA
    STA FPTR_PACKET_CREATION[2] ; H.
    LDY #$00 ; Reset index.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Rehandle.
SCRIPT_RTN_C: ; 1E:08D4, 0x03C8D4
    LDY PACKET_CONSUMED/INDEX? ; Load.
    BEQ SCRIPT_RTN_A ; Stream == 0x00, do A.
    LDA FPTR_PACKET_CREATION[2] ; Save FPTR to stack.
    PHA
    LDA FPTR_PACKET_CREATION+1
    PHA
    TYA ; Index to A.
    PHA ; Save it.
    BNE SCRIPT_RTN_F_INDEX_SEEDED
SCRIPT_RTN_A: ; 1E:08E2, 0x03C8E2
    PLA ; Pull val.
    BEQ STACK_CONFIG_0x00 ; == 0, goto.
    TAY ; Stack val to Y.
    INY ; Y += 2. TODO why.
    INY
    PLA ; Pull behind stack.
    STA FPTR_PACKET_CREATION+1 ; Set packet creator with.
    PLA
    STA FPTR_PACKET_CREATION[2]
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Goto handler.
STACK_CONFIG_0x00: ; 1E:08F1, 0x03C8F1
    LDY NMI_PPU_CMD_PACKETS_INDEX ; Load index.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Load past index.
    BEQ PAST_INDEX_0x00 ; == 0, goto.
    TXA ; X to Y index.
    TAY
PAST_INDEX_0x00: ; 1E:08FA, 0x03C8FA
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load switch.
    BPL VAL_POSITIVE ; Positive, goto.
    INC PACKET_YPOS_COORD? ; ++
    RTS ; Leave.
VAL_POSITIVE: ; 1E:0901, 0x03C901
    LDA PACKET_CONSUMED/INDEX? ; Load ??
    JSR FORWARD_PACKET_CREATION_FP_BY_A ; Do ??
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load switch rtn.
    RTS ; Leave.
SCRIPT_RTN_B: ; 1E:0909, 0x03C909
    LDY PACKET_CONSUMED/INDEX? ; Load stream.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load.
    STA PACKET_HPOS_COORD? ; Store to.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load.
    STA PACKET_YPOS_COORD? ; Store to.
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Stream save.
    BCC CC_SKIP_DEC ; TODO: Always taken?
    DEC PACKET_YPOS_COORD? ; -- on CS. TODO: CS condition.
CC_SKIP_DEC: ; 1E:091B, 0x03C91B
    LDY NMI_PPU_CMD_PACKETS_INDEX ; Index from.
    LDA NMI_PPU_CMD_PACKETS_BUF+1,Y ; Load past.
    BNE PAST_NONZERO ; != 0, goto.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Load. TODO: Why.
PAST_NONZERO: ; 1E:0924, 0x03C924
    JSR PACKET_CALC_COORDS_TO_VADDR ; Calc pos.
    JSR PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN ; Header it.
    LDY PACKET_CONSUMED/INDEX? ; Reload.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Go back to handler.
SCRIPT_RTN_D: ; 1E:092F, 0x03C92F
    LDY PACKET_CONSUMED/INDEX? ; Load index.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load from file.
    BCC SCRIPT_CC ; CC, goto.
    LDA #$A0 ; Seed. To append.
SCRIPT_CC: ; 1E:0937, 0x03C937
    STA ENGINE_SCRIPT_SWITCH_VAL? ; Store, to append with.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load.
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Save stream.
    TAY ; Val to Y index.
LOOP_DO: ; 1E:0940, 0x03C940
    DEY ; Y--
    BMI RELAUNCH_HANDLER ; Negative, done.
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load from.
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append to packet.
    JMP LOOP_DO ; Loop on Y.
RELAUNCH_HANDLER: ; 1E:094B, 0x03C94B
    LDY PACKET_CONSUMED/INDEX? ; Reload.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; And relaunch.
SCRIPT_RTN_E: ; 1E:0950, 0x03C950
    LDY PACKET_CONSUMED/INDEX? ; Stream index.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Stream move ptr to alt file.
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store val.
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; 2x.
    STA SAVE_GAME_MOD_PAGE_PTR+1
    INY
    LDA [FPTR_PACKET_CREATION[2]],Y ; 3x. Move index?
    STA ALT_STUFF_INDEX?
    INY
    LDA [FPTR_PACKET_CREATION[2]],Y ; 4x. Flags?
    STA ALT_COUNT_UNK
    INY
    TYA ; Stream to A.
    PHA ; Save.
    LDY ALT_STUFF_INDEX? ; Load ??
    BEQ ALT_0x00 ; == 0, goto.
    LDA #$00
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Clear ??
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+2
    DEY ; Y--
VAL_POSITIVE: ; 1E:0975, 0x03C975
    LDA [SAVE_GAME_MOD_PAGE_PTR[2]],Y ; Load from file.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2],Y ; Store to 0x0060.
    DEY ; Y--
    BPL VAL_POSITIVE ; Positive, goto.
    TXA ; X to A.
    PHA ; Save X.
    JSR ENGINE_24BIT_TO_TEXT ; Do.
    PLA ; Pull.
    TAX ; Val to X.
    LDA ALT_COUNT_UNK ; Load ??
    BNE SUB_AND_ADD ; != 0, goto.
    SEC ; Prep sub.
    LDA #$08 ; Adding with sub.
    SBC ENGINE_TO_DECIMAL_INDEX_POSITION ; Sub with.
    STA ALT_COUNT_UNK ; Store to.
    LDA ENGINE_TO_DECIMAL_INDEX_POSITION ; Load ??
    BPL JUST_ADD ; Positive, goto.
SUB_AND_ADD: ; 1E:0993, 0x03C993
    SEC ; Prep sub.
    LDA #$08 ; Sub diff.
    SBC ALT_COUNT_UNK ; Sub with.
JUST_ADD: ; 1E:0998, 0x03C998
    CLC ; Prep add.
    ADC #$68 ; Add file size alloted?
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store PTR L.
    LDA #$00 ; Seed 0x00
    ADC #$00 ; Carry add. 0x00/0x01.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store to.
ALT_0x00: ; 1E:09A3, 0x03C9A3
    LDY #$00 ; Stream index.
ALT_FILE_CONSUMPTION: ; 1E:09A5, 0x03C9A5
    LDA ENGINE_SCRIPT_SWITCH_VAL? ; Load ??
    BMI NEGATIVE ; Negative, goto.
    LDA [SAVE_GAME_MOD_PAGE_PTR[2]],Y ; Load from file.
    JSR ENGINE_DATA_DICT_MOD_A_UNK ; Mod value.
    BCS DATA_APPEND ; CS, append.
    BCC FLAG_DEC_RELAUNCH ; Always taken, other.
NEGATIVE: ; 1E:09B2, 0x03C9B2
    LDA [SAVE_GAME_MOD_PAGE_PTR[2]],Y ; Load from stream.
    JSR ENGINE_DATA_DICT_MOD_B_UNK ; Do mod.
    BCS DATA_APPEND ; CS, append.
    BCC FLAG_DEC_RELAUNCH ; Not modded, goto Always taken.
APPEND_0xA0: ; 1E:09BB, 0x03C9BB
    LDA #$A0 ; Val ??
    JSR APPEND_DATA_TO_UPDATE_BUF ; Do.
FLAG_DEC_RELAUNCH: ; 1E:09C0, 0x03C9C0
    DEC ALT_COUNT_UNK ; --
    BPL APPEND_0xA0 ; Positive, goto.
    BMI EXIT_RELAUNCH_STACK_TO_Y ; Always taken.
DATA_APPEND: ; 1E:09C6, 0x03C9C6
    JSR APPEND_DATA_TO_UPDATE_BUF ; Append to buffer.
    DEC ALT_COUNT_UNK ; --
    BNE ALT_FILE_CONSUMPTION ; Nonzero, goto.
EXIT_RELAUNCH_STACK_TO_Y: ; 1E:09CD, 0x03C9CD
    PLA ; Pull from stack.
    TAY ; As Y index.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Relaunch.
SCRIPT_RTN_G_RELAUNCH: ; 1E:09D2, 0x03C9D2
    LDY PACKET_CONSUMED/INDEX? ; Just relaunch. This could have been made the end of the other rtn.
    JMP [ENGINE_PTR_PACKET_MANAGER[2]] ; Relaunch.
PACKET_CALC_COORDS_TO_VADDR: ; 1E:09D7, 0x03C9D7
    LDA ENGINE_PPU_CTRL_COPY ; Load.
    LSR A ; >> 2, /4.
    LSR A ; Get vert bit to carry.
    LDA ENGINE_SCROLL_Y ; Load ??
    ROR A ; Vert bit to 0x80.
    CLC ; Prep add.
    ADC #$08 ; Add 0x08, to next tile?
    STA PACKET_PPU_ADDR_HL+1 ; Store addr L.
    LDA PACKET_YPOS_COORD? ; Load ??
    ADC #$01 ; +1
    ASL A ; << 2, *4.
    ASL A
    CLC ; Prep add.
    ADC PACKET_PPU_ADDR_HL+1 ; Add with, addr L.
    BVS SIGNED_OVERFLOW ; Signed overflow, goto.
    SEC ; Prep sub.
    SBC #$08 ; Sub ??
SIGNED_OVERFLOW: ; 1E:09F1, 0x03C9F1
    ASL A ; << 1, *2. Carry important.
    AND #$F8 ; Keep 1111.1000, mod 8. TODO: Why.
    STA PACKET_PPU_ADDR_HL+1 ; Store to, addr L.
    LDA #$02 ; Load 0000.0010
    ROL A ; 0000.010C
    ASL A ; 0000.10C0
    ASL PACKET_PPU_ADDR_HL+1 ; Rotate out of lower.
    ROL A ; 0001.0C0L
    ASL PACKET_PPU_ADDR_HL+1 ; << 2,
    ROL A ; 0010.C0LL
    STA PACKET_PPU_ADDR_HL[2] ; Store addr H created.
    LDA ENGINE_PPU_CTRL_COPY ; Load.
    LSR A ; Get horiz screen bit.
    LDA ENGINE_SCROLL_X ; Load.
    ROR A ; Rotate H bit into.
    LSR A ; >> 2, /4. /8 total.
    LSR A
    CLC ; Prep add.
    ADC PACKET_HPOS_COORD? ; Add with.
    TAY ; Save to Y.
    AND #$20 ; Keep 0010.0000, nametable base.
    LSR A ; >> 3, /7. 0x04/0x00 value.
    LSR A
    LSR A
    ADC PACKET_PPU_ADDR_HL[2] ; Add with namteable H.
    STA PACKET_PPU_ADDR_HL[2] ; Store addr H.
    TYA ; Val back to A.
    AND #$1F ; Keep 0001.1111, tile.
    ADC PACKET_PPU_ADDR_HL+1 ; Add with lower.
    STA PACKET_PPU_ADDR_HL+1 ; Store to lower.
    RTS ; Leave.
APPEND_DATA_TO_UPDATE_BUF: ; 1E:0A1F, 0x03CA1F
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store to arr.
    INX ; Index++
    TXA ; Index save.
    LDX NMI_PPU_CMD_PACKETS_INDEX ; Index beginning.
    INC NMI_PPU_CMD_PACKETS_BUF+1,X ; Inc size of this packet.
    TAX ; Index into buf back to X.
    INC DATA_APPEND_COUNT? ; ++ ??
    INC DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Inc to test zero, zero means to next screen.
    BEQ PACKET_SPILL_SCREEN ; == 0, goto. Screen spilled, to other at 0x00 index for line.
    RTS ; Leave, done.
PACKET_SPILL_SCREEN: ; 1E:0A31, 0x03CA31
    LDA PACKET_PPU_ADDR_HL+1 ; Load addr L.
    AND #$E0 ; Isolate row only.
    STA PACKET_PPU_ADDR_HL+1 ; Store back to keep row, index 0x00.
    LDA PACKET_PPU_ADDR_HL[2] ; Load.
    EOR #$04 ; Invert 0000.01000, different screen address.
    STA PACKET_PPU_ADDR_HL[2] ; Store back.
PACKET_HEADER_HELPER_TO_EDGE_OF_SCREEN: ; 1E:0A3D, 0x03CA3D
    STX NMI_PPU_CMD_PACKETS_INDEX ; Save index up to now.
    LDA #$05 ; Type, unique +1.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store to buf.
    INX ; Index++
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Clear count.
    INX ; Index++
    LDA PACKET_PPU_ADDR_HL[2] ; Move address for the screen to the packet.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA PACKET_PPU_ADDR_HL+1 ; Load addr L.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX ; Index++
    ORA #$E0 ; Set index offset bits in addr L for inc check zero.
    STA DISP_UPDATE_COUNT_SMART_INVERTED/MISC ; Store val to inc.
    RTS ; Leave.
ENGINE_DATA_DICT_MOD_A_UNK: ; 1E:0A5C, 0x03CA5C
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Save.
    CMP #$40 ; If _ #$40
    BCS EXIT_CS ; >=, goto.
    TAY ; Stream to Y.
    LDA DICTIONARY_ALT_VALS,Y ; Load data.
    LDY PACKET_CONSUMED/INDEX? ; Restore stream.
    CMP #$80 ; If alt _ #$80
    BCS EXIT_CS ; >=, leave.
    CMP #$20 ; If alt _ #$20
    BCS EXIT_CS_SET_1000 ; >=, goto.
    CMP #$0A ; If alt _ #$0A
    BCS EXIT_CS_SET_1101 ; >=, goto.
    RTS ; Raw alt, ret CC.
EXIT_CS_SET_1101: ; 1E:0A76, 0x03CA76
    ORA #$D0 ; ??
    RTS
EXIT_CS_SET_1000: ; 1E:0A79, 0x03CA79
    ORA #$80 ; Direct to stream?
EXIT_CS: ; 1E:0A7B, 0x03CA7B
    RTS
ENGINE_DATA_DICT_MOD_B_UNK: ; 1E:0A7C, 0x03CA7C
    INY ; Stream++
    STY PACKET_CONSUMED/INDEX? ; Save stream as Y might be used. Why not do this later. :(
    CMP #$40 ; If _ #$40
    BCS EXIT_A:0xA0_CS ; >=, goto.
    TAY ; Val to Y index.
    LDA DICTIONARY_ALT_VALS,Y ; Load alt.
    LDY PACKET_CONSUMED/INDEX? ; Restore stream index.
    CMP #$80 ; If _ #$80
    BCS EXIT_A:0xFE_CS ; >=, goto.
    CMP #$20 ; If _ #$20
    BCS EXIT_A:0xFF_CS ; >=, goto.
    CMP #$0A ; If _ #$0A
    BCS EXIT_A|0xD0_CS ; >=, goto.
    RTS ; Ret CC, as-is. Val < 0xA.
EXIT_A|0xD0_CS: ; 1E:0A96, 0x03CA96
    ORA #$D0 ; Set 1101.0000.
    RTS ; Leave, CS.
EXIT_A:0xFF_CS: ; 1E:0A99, 0x03CA99
    LDA #$FF ; Ret val.
    RTS ; CS.
EXIT_A:0xFE_CS: ; 1E:0A9C, 0x03CA9C
    LDA #$FE ; Ret val.
    RTS ; CS.
EXIT_A:0xA0_CS: ; 1E:0A9F, 0x03CA9F
    LDA #$A0
    RTS
LIB_READING_PPU_ROM_$0110_HELPER: ; 1E:0AA2, 0x03CAA2
    LDA ARG_IDFK ; Load ??
    BPL VAL_POSITIVE ; Positive, goto.
    STA FPTR_PACKET_CREATION+1 ; Set ?? if negative.
    RTS ; Leave.
VAL_POSITIVE: ; 1E:0AA9, 0x03CAA9
    CMP #$7F ; If _ #$7F
    BCS SETTLE_PORTION ; >=, goto.
    TAX ; Val save in X. Delta.
    LDA FPTR_PACKET_CREATION[2] ; Load.
    ASL FPTR_PACKET_CREATION[2] ; << 1.
    ROL ARG_IDFK ; Into var.
    ADC FPTR_PACKET_CREATION[2] ; Delta added to.
    STA FPTR_PACKET_CREATION[2] ; Store result.
    TXA ; Delta to A.
    ADC ARG_IDFK ; Add with.
    ADC #$80 ; Add with.
    STA FPTR_PACKET_CREATION+1 ; Store to.
    LDA #$7F
    STA ARG_IDFK ; Set ??
    LDA MAPPER_BANK_VALS+6 ; Load R6.
    PHA ; Save it.
    LDA #$18 ; New R6.
    LDX #$06 ; Seed R6.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6.
    LDY #$00 ; Stream reset.
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load from stream.
    STA WORLD_POS?_CARRY_ADDS_UNK[3] ; Store to ??
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load from stream.
    STA WORLD_POS?_CARRY_ADDS_UNK+1 ; Store to ??
    INY ; Stream++
    LDA [FPTR_PACKET_CREATION[2]],Y ; Load from stream.
    STA WORLD_POS?_CARRY_ADDS_UNK+2 ; Store to ??
    PLA ; Pull R6 saved.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6 again.
SETTLE_PORTION: ; 1E:0AE1, 0x03CAE1
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA #$0A ; Packet type, PPU read.
    STA NMI_PPU_CMD_PACKETS_BUF[64]
    LDA WORLD_POS?_CARRY_ADDS_UNK+2 ; Load ??
    LSR A ; >> 1, /2.
    LDA WORLD_POS?_CARRY_ADDS_UNK+1 ; Load ??
    ROR A ; Rotate into.
    SEC ; Prep CS.
    ROR A ; Into A.
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Store to, bank R4.
    LDA WORLD_POS?_CARRY_ADDS_UNK+1 ; Load ??
    AND #$03 ; Keep lower.
    ORA #$08 ; Set 0x8 ??
    STA NMI_PPU_CMD_PACKETS_BUF+2 ; Store to, addr H.
    LDA WORLD_POS?_CARRY_ADDS_UNK[3] ; Load ??
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Store to, addr L.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+4 ; EOF.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index to trigger.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    LDA #$10
    STA FPTR_PACKET_CREATION[2] ; Set fptr 0x0110 for data read in.
    LDA #$01
    STA FPTR_PACKET_CREATION+1
    JMP ENGINE_SETTLE_ALL_UPDATES? ; Settle, abuse RTS.
ENGINE_UNK_CARRY_ADDS_???: ; 1E:0B1A, 0x03CB1A
    LDA FPTR_PACKET_CREATION+1 ; Load PTR H.
    BPL PTR_POSITIVE ; Positive, goto.
    STA ARG_IDFK ; Store to otherwise ??
    RTS ; Leave.
PTR_POSITIVE: ; 1E:0B21, 0x03CB21
    SEC ; Prep sub.
    LDA FPTR_PACKET_CREATION[2] ; Load PTR L.
    SBC #$10 ; -= 0x10
    CLC ; Prep add.
    ADC WORLD_POS?_CARRY_ADDS_UNK[3] ; Add with.
    STA WORLD_POS?_CARRY_ADDS_UNK[3] ; Store to.
    LDA #$00 ; Carry seed.
    ADC WORLD_POS?_CARRY_ADDS_UNK+1 ; Carry add.
    STA WORLD_POS?_CARRY_ADDS_UNK+1 ; Store val.
    LDA #$00 ; Carry seed again.
    ADC WORLD_POS?_CARRY_ADDS_UNK+2 ; Carry add.
    STA WORLD_POS?_CARRY_ADDS_UNK+2 ; Store val.
    RTS ; Leave.
FORWARD_PACKET_CREATION_FP_BY_A: ; 1E:0B38, 0x03CB38
    CLC ; Prep add.
    ADC FPTR_PACKET_CREATION[2] ; Add with.
    STA FPTR_PACKET_CREATION[2] ; Store to.
    LDA #$00
    ADC FPTR_PACKET_CREATION+1 ; Carry adding.
    STA FPTR_PACKET_CREATION+1 ; Store to.
    RTS ; Leave.
SYSTEM_SETUP_COMPLETED: ; 1E:0B44, 0x03CB44
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; No writes.
    LDA #$C0
    STA SCRIPT_UNK_TESTED ; Set ??
    JSR ENGINE_HELPER_R6_0x14 ; Set R6.
    JSR EARTHBOUND_GAME_SELECTION/INIT ; Game select/startup menus. RETURNS WHEN COMPLETED.
    LDA #$00
    STA SCRIPT_UNK_TESTED ; Clear ??
MAIN_LOOP_FIRST_LAUNCHER_LOOP: ; 1E:0B57, 0x03CB57
    JSR ENGINE_HELPER_R7_0x13
    JSR ROUTINE_LAUNCHER_0xE ; Launch ??
MAIN_LOOP_REENTRY_LARGEST: ; 1E:0B5D, 0x03CB5D
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK ; Do lots.
    JSR HOLY_HELL_ALOT ; Also lots.
    LDA #$00
    STA CLEAR_AFTER_HELL_ALOT_LOL ; Clear ??
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load.
    AND #$0F ; Keep bottom.
    EOR #$84 ; Invet to set.
    STA **:$000D ; Store to.
MAIN_LOOP_REENTRY_SECOND_LARGEST: ; 1E:0B70, 0x03CB70
    JSR SETTLE_SPRITES_OFFSCREEN/CLEAR_RAM ; Settle, no sprites.
    JSR ENGINE_SETTLE_UPDATES_TODO ; Settle, scroll, ??
MAIN_LOOP_REENTRY_THIRD_LARGEST: ; 1E:0B76, 0x03CB76
    JSR ENGINE_MAP_DISPLAY? ; Do.
    JSR SCRIPT_SCROLL_INVERT_RTN? ; Do.
    LDA ENGINE_FLAG_25_SKIP_UNK
    BNE VAL_NONZERO ; != 0, skip.
    LDA CTRL_BUTTONS_PREVIOUS[2] ; Load prev.
    AND #$70 ; Test B, select, start.
    BEQ NONE_PRESSED ; None pressed, cleared.
    JSR CTRL_BUTTONS_TO_ACTION_VAL_START
    AND #$08 ; Test loaded.
    BEQ NONE_PRESSED ; == 0, goto.
    LDA #$01 ; Set ??
NONE_PRESSED: ; 1E:0B8F, 0x03CB8F
    STA ACTION_BUTTONS_RESULT ; Set ??
VAL_NONZERO: ; 1E:0B91, 0x03CB91
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA FIRST_LAUNCHER_HOLD_FLAG?
    BNE MAIN_LOOP_FIRST_LAUNCHER_LOOP ; != 0, goto.
    JSR MANY_STREAMS_UNK ; Do ??
    JSR STREAMS_UNK_SPRITE_READ?
    JSR BUTTONS_UPDATE_AND_MORE_OH_MY ; TODO <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    LDA MAIN_FLAG_UNK ; Load ??
    BEQ MAIN_FLAG_21_CLEAR ; == 0, goto.
    JSR ENGINE_HELPER_R7_0x13 ; Set 13 with if nonzero.
    JSR STREAMY_LIBY_UNK ; Banks and launches a bit and a few more small things.
    BCC STATES_COMBINED_ANY_SET_HANDLER ; Ret CC, goto.
MAIN_FLAG_21_CLEAR: ; 1E:0BAD, 0x03CBAD
    JSR ENGINE_HELPER_R7_0x13 ; Do.
    LDA #$00 ; Clear val.
    LDY CONTROL_ACCUMULATED?[2] ; Load buttons.
    STA CONTROL_ACCUMULATED?[2] ; Clear accumulated.
    LDA SCRIPT_FLAG_0x22 ; Load ??
    ORA FLAG_UNK_23 ; Set with others.
    ORA MAIN_FLAG_UNK
    ORA FIRST_LAUNCHER_HOLD_FLAG?
    BNE STATES_COMBINED_ANY_SET_HANDLER ; != 0, goto.
    TYA ; Buttons to A.
    AND #$F0 ; Test A/B/SEL/START
    BMI A_PRESSED_HANDLER ; A pressed, goto special.
    BNE NO_A_YES_B/SEL/START ; Others set, goto.
    JSR MAIN_RTN_MENU?_UNK ; Do.
    JMP NOT_PRESSED_RTN ; Goto.
NO_A_YES_B/SEL/START: ; 1E:0BCD, 0x03CBCD
    JSR CTRL_BUTTONS_TO_ACTION_VAL_START ; Do.
    AND #$A0 ; Keep 1010.0000
    BEQ NOT_PRESSED_RTN ; Not set, goto.
    BMI VAL_NEGATIVE ; _ALT
    JSR ENGINE_MAIN_RTN_MANY_FADES ; Do ??
    JMP NOT_PRESSED_RTN ; Goto.
VAL_NEGATIVE: ; 1E:0BDC, 0x03CBDC
    JSR LOOPY_IDFK ; Do ??
    JMP NOT_PRESSED_RTN ; Goto.
A_PRESSED_HANDLER: ; 1E:0BE2, 0x03CBE2
    JSR ENGINE_UNK_OBJECTS_REELATED? ; Do ??
NOT_PRESSED_RTN: ; 1E:0BE5, 0x03CBE5
    JSR ENGINE_HELPER_R6_0x14 ; Set R6.
    JSR ROUTINE_CHECK_MANY_COMBINED_UNK ; Do ??
STATES_COMBINED_ANY_SET_HANDLER: ; 1E:0BEB, 0x03CBEB
    LDA FLAG_UNK_48 ; Load ??
    BEQ HELPER_GOTO_MAIN_TERTIARY ; == 0, goto.
    CMP #$A2 ; If _ #$A2
    BEQ MAIN_ALT_UNK ; ==, goto.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDA VAL_CMP_UNK ; Load ??
    PHA ; Save it.
    JSR LIB_UNK ; Do ??
    PLA ; Pull A.
    BCS HELPER_GOTO_MAIN_PRIMARY ; CS, goto.
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH? ; Update it.
    LDA MAIN_FLAG_UNK ; Load ??
    BEQ HELPER_GOTO_MAIN_SECONDARY ; == 0, goto.
    JSR ENGINE_HELPER_R7_0x13 ; Set R7.
    JSR LIB_STREAM_COMMANDS_PROCESS_UNK ; Do, very scripty.
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Seed val.
    BNE HELPER_GOTO_MAIN_PRIMARY ; Nonzero, goto.
HELPER_GOTO_MAIN_SECONDARY: ; 1E:0C11, 0x03CC11
    JMP MAIN_LOOP_REENTRY_SECOND_LARGEST ; Do ??
HELPER_GOTO_MAIN_PRIMARY: ; 1E:0C14, 0x03CC14
    JMP MAIN_LOOP_REENTRY_LARGEST ; Do ??
HELPER_GOTO_MAIN_TERTIARY: ; 1E:0C17, 0x03CC17
    JMP MAIN_LOOP_REENTRY_THIRD_LARGEST ; Do ??
MAIN_ALT_UNK: ; 1E:0C1A, 0x03CC1A
    JSR ENGINE_HELPER_R6_0x14 ; Set R6.
    JSR SCRIPTY_TODO ; Do ??
    JSR LIB_UNK ; Do ??
    BCS HELPER_GOTO_MAIN_PRIMARY ; Ret CS.
    JSR ENGINE_HELPER_R6_0x14 ; R6 Bank.
    JMP GAME_ENDING_SEQUENCE ; Do game end, this is it.
BUTTONS_UPDATE_AND_MORE_OH_MY: ; 1E:0C2B, 0x03CC2B
    LDA ACTION_BUTTONS_RESULT ; Load.
    CMP #$07 ; If _ #$07, ??
    BCS ACTION_RESULT_GTE_0x7 ; >=, goto.
    LDA #$10
    STA NMI_FLAG_E5_TODO ; Set flag ??
    JSR SCRIPT_PTR_MOD_AND_??_THEN_CHAIN_?? ; Do ??
    JSR UNK_GFX_AND_?? ; Do ??
WAIT_E5_FLAG: ; 1E:0C3B, 0x03CC3B
    LDA NMI_FLAG_E5_TODO
    BNE WAIT_E5_FLAG ; != 0, loop on.
LOOP_GTE_0x9: ; 1E:0C3F, 0x03CC3F
    LDA NMI_FLAG_E0_TODO ; Load.
    CMP #$09 ; If _ #$09
    BCS LOOP_GTE_0x9 ; >=, goto.
    SEC ; Prep carry 1.
    ROR NMI_FLAG_OBJECT_PROCESSING? ; Rotate in, set 0x80.
    JSR OBJECTS_MOVE_PTRS? ; Do ??
    ASL NMI_FLAG_OBJECT_PROCESSING? ; Shift flag.
    JSR FLAG_HOLD_WAIT_AND_UPDATES_UNK ;  TODO <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    BNE ALT_RTN ; Always taken.
ACTION_RESULT_GTE_0x7: ; 1E:0C5D, 0x03CC5D
    JSR SCRIPT_PTR_MOD_AND_??_THEN_CHAIN_?? ; Do ??
    JSR UNK_GFX_AND_?? ; Do ??
    JSR FLAG_HOLD_WAIT_AND_UPDATES_UNK ; Do ??
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$10
    STA NMI_FLAG_E5_TODO ; Set flag ??
    LDA ACTION_BUTTONS_RESULT ; Load.
    CMP #$0F ; If _ #$0F
    BCS ALT_RTN ; >=, goto.
VAL_NONZERO: ; 1E:0C77, 0x03CC77
    LDA NMI_FLAG_E5_TODO ; Load.
    BNE VAL_NONZERO ; != 0, wait.
    SEC ; Seed lock.
    ROR NMI_FLAG_OBJECT_PROCESSING? ; Set lock bit.
    JSR OBJECTS_MOVE_PTRS? ; Goto.
    ASL NMI_FLAG_OBJECT_PROCESSING? ; Unlock.
ALT_RTN: ; 1E:0C83, 0x03CC83
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    LSR A ; >> 1, /2.
    BCC SHIFT_CC ; CC, goto.
    JSR WAIT_UPDATE ; Do ??
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
SHIFT_CC: ; 1E:0C96, 0x03CC96
    BIT SCRIPT_UNK_DATA_SELECT_?? ; Test ??
    BMI RTS ; If negative, leave.
    INC **:$00D5 ; Inc ??
RTS: ; 1E:0C9C, 0x03CC9C
    RTS
CTRL_BUTTONS_TO_ACTION_VAL_START: ; 1E:0C9D, 0x03CC9D
    LSR A ; Nibble down.
    LSR A
    LSR A
    LSR A
    TAX ; To X index.
    LDY CTRL_BUTTONS_ACTION_INDEX,X ; Load from table, index into save slot data.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+60,Y ; Val from save area.
    RTS ; Leave.
CTRL_BUTTONS_ACTION_INDEX: ; 1E:0CA9, 0x03CCA9
    .db 00 ; None pressed.
    .db 01 ; Start pressed.
    .db 02 ; Select pressed.
    .db 01 ; Start+select, do start.
    .db 00 ; Nothing.
    .db 00
    .db 00
    .db 00
    LDA #$FF
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH?
    JSR 1E:1A16
    LDA #$02
    STA **:$07F0
    LDA #$01
    ORA ENGINE_PPU_MASK_COPY
    STA ENGINE_PPU_MASK_COPY
    LDX #$08
    JSR SCRIPT_INVERT_X_SCROLL_SETTLE
    DEX
    BNE 1E:0CC6
    LDA #$1E
    AND ENGINE_PPU_MASK_COPY
    STA ENGINE_PPU_MASK_COPY
    JSR WAIT_ANY_BUTTONS_PRESSED_RET_PRESSED
    JMP 1E:0D79
    LDA VAL_CMP_UNK
    PHA
    LDA #$FF
    STA **:$000F
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH?
    JSR LIB_OBJECTS_AND_SETTLE_AND_FLAGS_UNK
    LDA #$01
    STA **:$07F4
    JSR 1E:0D9D
    LDX #$05
    JSR 1E:0D8B
    LDA SCRIPT_UNK_DATA_SELECT_??
    BMI 1E:0CB1
    LDA CTRL_BUTTONS_PREVIOUS[2]
    AND #$0F
    TAX
    LDA 1F:0BDD,X
    BMI 1E:0D0C
    ORA #$40
    TAX
    EOR SCRIPT_FLAG_0x22
    CMP #$04
    BEQ 1E:0D0C
    STX SCRIPT_FLAG_0x22
    LDX ENGINE_FLAG_25_SKIP_UNK
    INX
    CPX #$2D
    BCC 1E:0CF0
    JSR ENGINE_SETTLE_ALL_UPDATES?
    LDA #$20
    TAX
    ASL **:$0304,X
    ASL **:$0305,X
    SEC
    SBC #$08
    BNE 1E:0D18
    LDA #$0A
    PHA
    JSR BUTTONS_UPDATE_AND_MORE_OH_MY
    JSR ENGINE_SETTLE_ALL_UPDATES?
    PLA
    SEC
    SBC #$01
    BNE 1E:0D26
    LDA #$01
    STA **:$07F3
    LDA #$22
    JSR ENGINE_ALL_COLOR_TO_A
    JSR ENGINE_HELPER_R7_0x13
    JSR ENGINE_WRAM_STATE_WRITEABLE
    JSR $BBD4
    JSR L_1E:19FA
    PLA
    LDA CURRENT_SAVE_MANIPULATION_PAGE+4
    TAX
    AND #$3F
    PHA
    TXA
    AND #$C0
    STA CURRENT_SAVE_MANIPULATION_PAGE+4
    JSR 1E:18C9
    LDX #$14
    JSR ENGINE_DELAY_X_FRAMES
    JSR ENGINE_WRAM_ARR_MOD_LOOPS_UNK
    JSR HOLY_HELL_ALOT
    JSR SETTLE_SPRITES_OFFSCREEN/CLEAR_RAM
    JSR ENGINE_SETTLE_UPDATES_TODO
    JSR 1E:0D9D
    LDX #$2C
    JSR 1E:0D8B
    LDX ENGINE_FLAG_25_SKIP_UNK
    DEX
    DEX
    BPL 1E:0D70
    LDX #$00
    STX SCRIPT_FLAG_0x22
    STX CONTROL_ACCUMULATED?[2]
    STX **:$000F
    JSR L_1E:0DAF
    PLA
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH?
    JMP MAIN_LOOP_REENTRY_THIRD_LARGEST
    JSR L_1E:0DAF
    JSR ENGINE_MAP_DISPLAY?
    JSR ENGINE_SETTLE_ALL_UPDATES?
    JSR MANY_STREAMS_UNK
    JSR STREAMS_UNK_SPRITE_READ?
    JMP BUTTONS_UPDATE_AND_MORE_OH_MY
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6
    AND #$0F
    STA R_**:$6799
    ORA #$40
    STA SCRIPT_FLAG_0x22
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
L_1E:0DAF: ; 1E:0DAF, 0x03CDAF
    STX ENGINE_FLAG_25_SKIP_UNK
    LDA DATA_TABLE_UNK,X
    STA ACTION_BUTTONS_RESULT
    RTS
DATA_TABLE_UNK: ; 1E:0DB7, 0x03CDB7
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 01
    .db 01
    .db 01
    .db 01
    .db 01
    .db 02
    .db 02
    .db 02
    .db 02
    .db 03
    .db 03
    .db 03
    .db 03
    .db 03
    .db 03
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 05
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 07
    .db 0F
    .db 0F
    .db 0F
    .db 0F
    .db 0F
ENGINE_COMPARES/MISMATCH_RTN_UNK: ; 1E:0DE4, 0x03CDE4
    PHA ; Save passed.
    LDA VAL_CMP_UNK ; Load.
    TAX ; To index.
    PLA ; Pull passed.
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH? ; Do ??
    LDA #$00
    STA CONTROL_ACCUMULATED?[2] ; Clear accumulated.
VAL_NONZERO: ; 1E:0DF1, 0x03CDF1
    BIT CONTROL_ACCUMULATED?[2] ; Test buttons.
    BVS BUTTON_B_PRESSED ; If set, goto.
    LDA VAL_CMP_UNK ; LOad.
    BNE VAL_NONZERO ; If nonzero, loop wait.
BUTTON_B_PRESSED: ; 1E:0DFA, 0x03CDFA
    LDA #$00
    STA CONTROL_ACCUMULATED?[2] ; Clear buttons.
    TXA ; Val CMP original to A.
    JMP STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH? ; Goto.
FILE_SELECTION_SCREEN_SETUP?: ; 1E:0E02, 0x03CE02
    LDY #$5E ; Seed GFX Bank for data.
    LDA #$00
    LDX #$6C ; Seed 0x6C00?
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Set fptr 0x6C00
    STX ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    JSR ENGINE_SETTLE_ALL_UPDATES?
    TYA ; Val to A.
    LDX #$01 ; R1
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX Bank.
    LDA #$09 ; Packet PPU read.
    LDX #$40 ; Count.
    STA NMI_PPU_CMD_PACKETS_BUF[64] ; Packet making.
    STX NMI_PPU_CMD_PACKETS_BUF+1
    LDA #$00 ; Set addr 0x1800
    LDX #$18
    STX NMI_PPU_CMD_PACKETS_BUF+2 ; Addr H, 0x18
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Addr L, 0x00.
    LDA #$00
    STA **:$0444 ; Clear ??
    LDX #$20 ; Loops, 0x40 size per loop, 0x800 total.
LOOP_0x800: ; 1E:0E30, 0x03CE30
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM with writing.
    LDY #$00 ; Index.
LOOP_TO_TARGET: ; 1E:0E40, 0x03CE40
    LDA NMI_PPU_CMD_PACKETS_BUF+4,Y ; Load from buf.
    STA [ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]],Y ; Store to fp. 0x6C00 - 0x73FF.
    INY ; Index++
    CPY #$40 ; If _ #$40
    BCC LOOP_TO_TARGET ; <, goto.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; No WRAM writes now.
    CLC ; Prep add.
    TYA ; A = 0x40
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Add consumed to ptr.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    LDA #$00
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Carry add.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    CLC ; Prep add.
    TYA ; Consumed to A.
    ADC NMI_PPU_CMD_PACKETS_BUF+3 ; Add 0x40 to screen addr, moving 2 lines.
    STA NMI_PPU_CMD_PACKETS_BUF+3
    LDA #$00
    ADC NMI_PPU_CMD_PACKETS_BUF+2 ; Carry add.
    STA NMI_PPU_CMD_PACKETS_BUF+2
    DEX ; Index--
    BNE LOOP_0x800 ; != 0, loop.
    RTS ; Leave.
PPU_READ_INTO_$0110_HELPER_LOOP_UNK: ; 1E:0E6D, 0x03CE6D
    LDA #$00
    LDX #$00
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    STX ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Set $0000
    LDA #$00
    LDX #$20
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    STX SAVE_GAME_MOD_PAGE_PTR+1 ; Set to $2000.
    LDA #$10
    STA ARR_BITS_TO_UNK[8] ; Set loop count, 0x10.
LOOPS_NONZERO: ; 1E:0E81, 0x03CE81
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Seed PPU Addr H.
    LDX ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Seed L.
    LDY #$09 ; Seed type, read to RAM.
    JSR ENGINE_LARGE_UNIQUE_PPU_PACKET_HELPER ; Do.
    LDA SAVE_GAME_MOD_PAGE_PTR[2] ; Seed PPU Addr H.
    LDX SAVE_GAME_MOD_PAGE_PTR+1 ; Seed L.
    LDY #$05 ; Seed type, unique upload.
    JSR ENGINE_LARGE_UNIQUE_PPU_PACKET_HELPER ; Do.
    CLC ; Prep add.
    LDA #$40 ; Adding val.
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Add with.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Store result.
    LDA #$00
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Carry add.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Store result.
    CLC ; Prep add.
    LDA #$40 ; Adding val.
    ADC SAVE_GAME_MOD_PAGE_PTR[2] ; Add with.
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store result.
    LDA #$00 ; Carry seed.
    ADC SAVE_GAME_MOD_PAGE_PTR+1 ; Add with.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store result.
    DEC ARR_BITS_TO_UNK[8] ; Loops--
    BNE LOOPS_NONZERO ; != 0, goto.
    RTS ; Leave.
ENGINE_LARGE_UNIQUE_PPU_PACKET_HELPER: ; 1E:0EB2, 0x03CEB2
    PHA ; Save passed.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    PLA ; Restore.
    STA NMI_PPU_CMD_PACKETS_BUF+3 ; Val to, Addr L.
    STX NMI_PPU_CMD_PACKETS_BUF+2 ; X to, Addr H.
    STY NMI_PPU_CMD_PACKETS_BUF[64] ; Y to, type.
    LDA #$40
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Set GFX bank pair.
    LDA #$00
    STA **:$0444 ; Clear the end of the packet.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_INDEX ; Clear index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    RTS ; Leave.
ENGINE_HELPER_R7_0x13: ; 1E:0ED3, 0x03CED3
    LDA #$13
    LDX #$07
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_HELPER_R7_0x17: ; 1E:0EDA, 0x03CEDA
    LDA #$17
    LDX #$07
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_HELPER_R6_0x14: ; 1E:0EE1, 0x03CEE1
    LDA #$14 ; R6 = 0x14
    LDX #$06
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A ; Do, return.
ENGINE_SET_GFX_BANKS_FPTR_AX: ; 1E:0EE8, 0x03CEE8
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Set PTR.
    STX ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    LDX #$05 ; Seed bank GFX bank.
    LDY #$05 ; Seed stream index start.
STREAM_INDEX_POSITIVE: ; 1E:0EF0, 0x03CEF0
    LDA [ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]],Y ; Load from index.
    BEQ STREAM_0x00 ; == 0, goto.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set bank 0x05 -> 0x00
STREAM_0x00: ; 1E:0EF7, 0x03CEF7
    DEX ; R# bank.
    DEY ; Stream index val used.
    BPL STREAM_INDEX_POSITIVE ; Positive, loop more.
    RTS ; Leave.
HOLY_HELL_ALOT: ; 1E:0EFC, 0x03CEFC
    JSR HUGE_ASS_STREAMS_THINGY_IDFK ; Do ??
    LDA #$14
    LDX #$06 ; R6 = 0x14
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set.
    LDA #$00
    STA SCRIPT_B800_PTR_UNK+1 ; Clear addr H.
    LDA **:$0014 ; Load ??
    ASL A ; << 3, *8.
    ASL A
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; Rotate bit into.
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; 2x
    ADC #$00 ; Carry add.
    STA SCRIPT_B800_PTR_UNK[2] ; Store to, addr L.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load.
    ADC #$90 ; += 0x90
    STA SCRIPT_B800_PTR_UNK+1 ; Store, addr H.
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    LDY #$0F ; Stream index.
INDEX_POSITIVE: ; 1E:0F23, 0x03CF23
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    BPL STREAM_POSITIVE ; Positive, goto.
    JSR ENGINE_HELPER_LOAD_7400_INDEX_A&3F ; Load it if negative.
STREAM_POSITIVE: ; 1E:0F2A, 0x03CF2A
    STA SCRIPT_PALETTE_UPLOADED?[32],Y ; Store val to palette.
    DEY ; Index--
    BPL INDEX_POSITIVE ; Positive, loop.
    LDY #$0F ; Reset index.
INDEX_POSITIVE: ; 1E:0F32, 0x03CF32
    LDA PALETTE_SPRITE_UNK,Y ; Load from arr.
    STA SCRIPT_PALETTE_UPLOADED?+16,Y ; Store to sprite palette.
    DEY ; Index--
    BPL INDEX_POSITIVE ; Positive, goto.
    LDX SCRIPT_PALETTE_UPLOADED?+12 ; Load ??
    LDY SCRIPT_PALETTE_UPLOADED?+14
    STX **:$0017 ; Save to.
    STY **:$0016
    LDX #$0F ; Seed ??
    LDY #$30
    STX SCRIPT_PALETTE_UPLOADED?+12
    STY SCRIPT_PALETTE_UPLOADED?+14
    JSR SCRIPT_SET_GFX ; Do ??
    LDA SCRIPT_PAIR_PTR?[2] ; Load.
    AND #$C0 ; Keep upper.
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store it.
    LDA SCRIPT_PAIR_PTR?+1 ; Move other.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1
    LDA #$40 ; Set ??
    STA **:$00AE
    LDA #$00 ; Clear ??
    STA **:$00AF
    LDA #$10 ; Set ??
    STA **:$009B
LOOP_JMP: ; 1E:0F68, 0x03CF68
    SEC ; Prep sub.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load ??
    AND #$C0 ; Keep 1100.0000
    SBC #$40 ; -= 0x40
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store to.
    LDA SCRIPT_PAIR_PTR_B?+1 ; Load ??
    SBC #$00 ; Carry sub.
    STA **:$00AB ; Store to.
    LDA #$13
    STA SCRIPT_COUNT_UNK ; Set ??
    JSR DEEP_STREAMER_IDFK ; Do ??
    DEC **:$009B ; --
    BEQ COUNT_EQ_ZERO ; == 0, goto.
    CLC ; Prep add.
    LDA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Load.
    ADC #$40 ; += 0x40
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store result.
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Load.
    ADC #$00 ; Carry add.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store result.
    JMP LOOP_JMP ; Loop.
COUNT_EQ_ZERO: ; 1E:0F92, 0x03CF92
    JSR CREATE_VAL/INDEX_UNK ; Do.
    LDY #$00 ; Clear ??
    STY **:$001D
    JMP LOOP_HELPER_A_LOT ; Exit.
PALETTE_SPRITE_UNK: ; 1E:0F9C, 0x03CF9C
    .db 0F
    .db 0F
    .db 00
    .db 30
    .db 0F
    .db 0F
    .db 16
    .db 37
    .db 0F
    .db 0F
    .db 24
    .db 37
    .db 0F
    .db 0F
    .db 12
    .db 37
ENGINE_SETTLE_UPDATES_TODO: ; 1E:0FAC, 0x03CFAC
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    CLC ; No reason?
    LDA **:$001C ; Load.
    ORA #$08 ; Set ??
    TAX ; To X index.
    LDY **:$001D ; Y from.
    LDA ENGINE_PPU_CTRL_COPY ; Load copy.
    AND #$FC ; Nametable clear.
    ORA **:$001E ; Set nametable with.
    STA ENGINE_PPU_CTRL_COPY ; Store back.
    STX ENGINE_SCROLL_X ; X and Y as.
    STY ENGINE_SCROLL_Y
    STY **:$0099 ; Y to, also.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ADC #$80 ; += 0x80
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store.
    LDA SCRIPT_PAIR_PTR?+1 ; Load ??
    ADC #$03 ; += 0x3
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store ptr H.
    LDA #$0F
    STA **:$009B ; Set ??
LOOP_RTN: ; 1E:0FD8, 0x03CFD8
    CLC ; Prep add.
    LDA **:$0099 ; Load.
    ADC #$F0 ; += 0xF0
    BCS ADD_OVERFLOW ; Overflow, goto.
    ADC #$F0 ; Add to sub?
ADD_OVERFLOW: ; 1E:0FE1, 0x03CFE1
    STA **:$0099 ; Store to.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load.
    AND #$C0 ; Keep upper.
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store to.
    LDA SCRIPT_PAIR_PTR_B?+1 ; Move ??
    STA **:$00AB
    LDX **:$009B ; Load index.
    LDA ROM_DATA_UNK,X ; Load ??
    EOR **:$0099 ; Invert with.
    AND #$10 ; Keep ??
    BNE VABIT_SET ; If set, use as-is.
    LDA ROM_DATA_UNK,X ; Load otherwise.
VABIT_SET: ; 1E:0FFB, 0x03CFFB
    STA DEEP_STREAM_MOD_UNK ; Store ??
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR PACKET_CREATOR_HELPER_ALOT ; Do.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; End of packet.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Reset index.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    DEC **:$009B ; --
    BEQ TIMER_EQ_0x00 ; == 0, goto.
    LDA **:$009B ; Load left.
    ASL A ; << 1, *2.
    TAX ; To X index.
    JSR WAIT_NMI/IRQ_CLEAR ; Wait.
    LDA #$25
    STA SCRIPT_PALETTE_TARGET/ALT?+30,X ; Set ??
    SEC ; Prep sub.
    LDA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Load ??
    SBC #$40 ; -= 0x40
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store result.
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Carry subtract.
    SBC #$00
    STA SCRIPT_LOADED_SHIFTED_|VAL+1
    JMP LOOP_RTN ; Goto.
TIMER_EQ_0x00: ; 1E:102E, 0x03D02E
    JSR ENGINE_SETTLE_ALL_UPDATES? ; Settle.
    JSR SCRIPT_SET_GFX ; Set GFX.
    LDA #$04
    STA NMI_PPU_CMD_PACKETS_BUF[64] ; Set type, palette.
    LDA #$00
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; EOF.
    STA NMI_PPU_CMD_PACKETS_INDEX ; Index reset.
    LDA #$80
    STA NMI_FLAG_E5_TODO ; Set flag.
    LDA #$88
    STA SCRIPT_UNK_DATA_SELECT_?? ; Set ??
    LDA #$00
    STA NMI_LATCH_FLAG ; Latch ??
    STA CONTROL_ACCUMULATED?[2] ; Clear controller buttons.
ROM_DATA_UNK: ; 1E:104E, 0x03D04E
    RTS ; Leave. TODO: Table off by one buf or not?
    .db F0
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 10
    .db 20
SCRIPT_PTR_MOD_AND_??_THEN_CHAIN_??: ; 1E:105E, 0x03D05E
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI RTS ; Negative, goto.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    TAX ; To X index.
    CLC ; Prep add.
    LDA LUT_MOD_0x0[4],X ; Load data.
    ADC SCRIPT_PAIR_PTR_B?[2] ; Add with.
    STA SCRIPT_PAIR_PTR_B?[2] ; Store to.
    LDA LUT_MOD_0x0+1,X ; Load other.
    ADC SCRIPT_PAIR_PTR_B?+1 ; Add with.
    STA SCRIPT_PAIR_PTR_B?+1 ; Store to.
    CLC ; Do this pair, too.
    LDA LUT_MOD_0x0+2,X
    ADC SCRIPT_PAIR_PTR?[2]
    STA SCRIPT_PAIR_PTR?[2]
    LDA LUT_MOD_0x0+3,X
    ADC SCRIPT_PAIR_PTR?+1
    STA SCRIPT_PAIR_PTR?+1
    CLC ; Prep add.
    LDA LUT_MOD_0x0+2,X ; Add data.
    BEQ CREATE_VAL/INDEX_UNK ; == 0, goto.
    BMI VAL_NEGATIVE ; Negative, goto.
    LDA **:$001D ; Load ??
    ADC #$20 ; += 0x20
    BCC STORE_UPPER ; No overflow, goto.
    BCS STORE_ASIS ; Overflow, goto.
VAL_NEGATIVE: ; 1E:1094, 0x03D094
    LDA **:$001D ; Load.
    ADC #$F0 ; Add sub ??
    BCS STORE_ASIS ; >=, goto.
STORE_UPPER: ; 1E:109A, 0x03D09A
    ADC #$F0 ; Keep upper only.
STORE_ASIS: ; 1E:109C, 0x03D09C
    STA **:$001D ; Store ??
CREATE_VAL/INDEX_UNK: ; 1E:109E, 0x03D09E
    LDA SCRIPT_PAIR_PTR_B?+1 ; Load ??
    AND #$07 ; Keep lower.
    STA **:$001E ; Store to.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load ??
    AND #$C0 ; Keep upper bits.
    LSR **:$001E ; Shift bits off.
    ROR A ; Into A.
    LSR **:$001E ; 2x
    ROR A
    STA **:$001C ; Store A crafter.
RTS: ; 1E:10B0, 0x03D0B0
    RTS ; Leave.
UNK_GFX_AND_??: ; 1E:10B1, 0x03D0B1
    JSR SCRIPT_SET_GFX ; Do.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI RTS ; Negative, leave.
    JSR HELPER_DEEP_STREAMER_UNK ; Do ??
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    LSR A ; >> 1, /2.
    BCS RERUN_DEEP_STREAMER_ALT_UNK ; CS, rerun with carry.
RTS: ; 1E:10C0, 0x03D0C0
    RTS ; Leave.
RERUN_DEEP_STREAMER_ALT_UNK: ; 1E:10C1, 0x03D0C1
    ADC #$00 ; Carry added to it.
    ASL A ; << 1, *2.
HELPER_DEEP_STREAMER_UNK: ; 1E:10C4, 0x03D0C4
    AND #$06 ; Keep 0000.0110
    ASL A ; << 2, *4.
    ASL A
    TAX ; To X index.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load.
    AND #$C0 ; Keep upper.
    ADC MOD_TABLE_UNK[2],X ; Add with.
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store ??
    LDA SCRIPT_PAIR_PTR_B?+1 ; Load alt.
    ADC MOD_TABLE_UNK+1,X ; Mod with.
    STA **:$00AB ; Store to.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ADC ROM_DATA_ARR_UNK,X ; Add with.
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store ??
    LDA SCRIPT_PAIR_PTR?+1 ; Load.
    ADC SLOT_EXTRAS[4],X ; Mod.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store ??
    LDA SLOT_EXTRAS+1,X ; Move ?? ptr/?? ??
    STA **:$00AE
    LDA SLOT_EXTRAS+2,X
    STA **:$00AF
    LDA SLOT_EXTRAS+3,X ; Move ?? single?
    STA SCRIPT_COUNT_UNK
    JMP DEEP_STREAMER_IDFK ; Goto.
MOD_TABLE_UNK: ; [2], 1E:10FD, 0x03D0FD
    .db C0
    .db FF
ROM_DATA_ARR_UNK: ; 1E:10FF, 0x03D0FF
    .db 00 ; 5 byte slots. UNK.
SLOT_EXTRAS: ; [4], 1E:1100, 0x03D100
    .db 00 ; UNK.
    .db 40
    .db 00
    .db 13
    .db 00 ; Slot.
    .db 40
    .db 04
    .db 00
    .db 00
    .db 00 ; Slot.
    .db 40
    .db 10
    .db 00
    .db C0
    .db FF ; Slot.
    .db C0
    .db 03
    .db 40
    .db 00
    .db 13 ; Slot.
    .db 00
    .db C0
    .db FF
    .db 00
    .db 00 ; Slot.
    .db 00
    .db 40
    .db 10
    .db 00
DEEP_STREAMER_IDFK: ; 1E:111D, 0x03D11D
    JSR SETUP_DEEP_STREAM_UNK ; Do ??
LOOP_BEGINNING: ; 1E:1120, 0x03D120
    JSR CREATE_B800_PTR ; Create PTR.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    CMP **:$0014 ; If _ #$14
    BEQ VALS_EQ ; ==, goto.
    LDA **:$0016 ; Load ??
    JMP VAL_SEEDED ; Goto.
VALS_EQ: ; 1E:1132, 0x03D132
    LDA **:$0094 ; Load.
    LDX #$06 ; R6.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6 bank.
    CLC ; Prep add.
    LDA **:$00AB ; Load ??
    STA SCRIPT_B800_PTR_UNK[2] ; Store, addr L.
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Load ??
    AND #$1F ; Keep lower.
    ADC #$80 ; += 0x8000
    STA SCRIPT_B800_PTR_UNK+1 ; Store, addr H.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    BPL VAL_SEEDED ; Positive, goto.
    JSR ENGINE_HELPER_LOAD_7400_INDEX_A&3F ; Do.
VAL_SEEDED: ; 1E:114F, 0x03D14F
    TAX ; To X index.
    AND #$40 ; Keep bit.
    ASL A ; << 1, *2.
    STA SCRIPT_INVERT_UNK ; Store to.
    LSR A ; >> 2, /4.
    LSR A
    STA B800_PTR_L_ADD_UNK ; Store to.
    BEQ VAL_EQ_0x00 ; == 0, goto. NOTE: BIT TRICK.
    .db A5 ; LDA $13, Alt A.
    .db 13
    .db 2C ; BIT TRICK past LDA $11, Alt B.
VAL_EQ_0x00: ; 1E:115E, 0x03D15E
    LDA **:$0011 ; Load alt.
    STA SCRIPT_B800_PTR_UNK+1 ; Store A decided.
    TXA ; X to A.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; Rotate bits into.
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; 2x
    STA SCRIPT_B800_PTR_UNK[2] ; Store leftover.
    STA STREAM_DEEP_HELPER_UNK[2] ; Also to.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load.
    ADC #$80 ; += 0x80
    ADC B800_PTR_L_ADD_UNK ; += ??
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    ADC #$10 ; += 0x10
    STA STREAM_DEEP_HELPER_UNK+1 ; Store to.
    LDA SCRIPT_R6_UNK ; Load ??
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom.
    LDX #$06
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set bank.
    LDA SCRIPT_R7_UNK ; Load ??
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom bit.
    LDX #$07 ; Set R7.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R7.
REENTRY_NO_OVERFLOW: ; 1E:118F, 0x03D18F
    LDA SCRIPT_LOADED_SHIFTED_UNK[1] ; Load ??
    LSR A ; >> 2, /4.
    LSR A
    ORA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Set bits.
    LSR A ; >> 4. nibble down.
    LSR A
    LSR A
    LSR A
    TAX ; To X.
    TAY ; And Y.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM writes.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from WRAM.
    EOR SCRIPT_INVERT_UNK ; Invert bits.
    LDY STREAM_DEEP_INDEX ; Stream index.
    STA [STREAM_UNK_DEEP_A[2]],Y ; Store to stream.
    TXA ; X to Y.
    TAY
    LDA [STREAM_DEEP_HELPER_UNK[2]],Y ; Load from stream.
    AND #$C0 ; Keep upper.
    STA OR_AND_STORE_UNK ; Store to.
    LSR A ; >> 2, /4.
    LSR A
    ORA OR_AND_STORE_UNK ; Set bits.
    LSR A ; >> 2, /4.
    LSR A
    ORA OR_AND_STORE_UNK ; Set bits.
    LSR A ; >> 2, /4.
    LSR A
    ORA OR_AND_STORE_UNK ; Set bits.
    LDY STREAM_DEEP_INDEX ; Load index.
    STA [STREAM_DEEP_B],Y ; Store to stream.
    LDA #$00 ; Clear val.
    STA [STREAM_DEEP_C],Y ; Store val.
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED ; Disable WRAM.
    DEC SCRIPT_COUNT_UNK ; --
    BEQ EXIT_RTS ; ==, goto.
    LDA **:$00AE ; Load val mod.
    BEQ MOD_0x00 ; ==, goto.
    INC STREAM_DEEP_INDEX ; ++
    CLC ; Prep add.
    ADC SCRIPT_LOADED_SHIFTED_UNK[1] ; Mod.
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store result.
    BCC ADD_NO_OVERFLOW ; No overflow, goto.
    LDA #$00 ; TODO: Badcode? Does nothing?
    ADC **:$00AB
    STA **:$00AB
    AND #$03 ; Keep lower.
    BNE LOWER_NONZERO ; != 0, goto.
    LDA STREAM_DEEP_INDEX ; Load ??
    SEC ; Prep sub.
    SBC #$10 ; -= 0x10
    STA STREAM_DEEP_INDEX ; Store val.
    LDA STREAM_UNK_DEEP_A+1 ; Load.
    EOR #$01 ; Invert.
    STA STREAM_UNK_DEEP_A+1 ; Store to.
    CLC ; Prep add.
    ADC #$02 ; += 0x2
    STA **:$00A5 ; Store to.
    ADC #$02 ; += 0x2
    STA **:$00A7 ; Store to.
    JMP LOOP_BEGINNING ; Loop.
MOD_0x00: ; 1E:11F9, 0x03D1F9
    LDX **:$00AF ; X from.
    BEQ EXIT_RTS ; == 0, leave.
    CLC ; Prep add.
    LDA STREAM_DEEP_INDEX ; Load.
    ADC #$10 ; += 0x10
    STA STREAM_DEEP_INDEX ; Store result.
    CLC ; Prep add.
    TXA ; X to A.
    ADC SCRIPT_LOADED_SHIFTED_|VAL[2] ; Mod by X.
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store result.
    BCC ADD_NO_OVERFLOW ; No overflow, goto.
    LDA #$00 ; Carry add.
    ADC SCRIPT_LOADED_SHIFTED_|VAL+1 ; Add.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store result.
    JMP LOOP_BEGINNING ; Loop.
ADD_NO_OVERFLOW: ; 1E:1215, 0x03D215
    JMP REENTRY_NO_OVERFLOW ; Loop.
LOWER_NONZERO: ; 1E:1218, 0x03D218
    JMP LOOP_BEGINNING ; Could have used the other one above for smaller code, hmm. Mistakeish.
EXIT_RTS: ; 1E:121B, 0x03D21B
    RTS ; Leave.
WAIT_UPDATE: ; 1E:121C, 0x03D21C
    LDA NMI_FLAG_E5_TODO ; Wait on.
    BNE WAIT_UPDATE ; != 0, loop.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI VAL_NEGATIVE ; Val negative, goto.
    AND #$07 ; Keep lower.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    TAX ; To X index.
    LDA DATA_TABLE_UNK,X ; Load ??
    BPL DATA_POSITIVE ; Positive, goto.
VAL_NEGATIVE: ; 1E:122F, 0x03D22F
    LDX #$00 ; Seed ??
    RTS ; Leave.
FLAG_HOLD_WAIT_AND_UPDATES_UNK: ; 1E:1232, 0x03D232
    LDA NMI_FLAG_E5_TODO
    BNE FLAG_HOLD_WAIT_AND_UPDATES_UNK ; != 0, goto.
    LDA SCRIPT_UNK_DATA_SELECT_?? ; Load ??
    BMI VAL_NEGATIVE ; != 0, goto.
    AND #$07 ; Keep lower.
    ASL A ; << 3, *8.
    ASL A
    ASL A
DATA_POSITIVE: ; 1E:123F, 0x03D23F
    TAX ; To X index.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load ??
    AND #$C0 ; Keep ??
    ADC PTR_MOD_ARR[2],X ; Add with indexed.
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store ??
    LDA SCRIPT_PAIR_PTR_B?+1 ; Load.
    ADC PTR_MOD_ARR+1,X ; Add with.
    STA **:$00AB ; Store to.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ADC ROM_DATA_UNK[4],X ; Add ??
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store to.
    LDA SCRIPT_PAIR_PTR?+1 ; Load.
    ADC ROM_DATA_UNK+1,X ; Carry add.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store to.
    CLC ; Prep add.
    LDA ROM_DATA_UNK+2,X ; Load 0x10
    ADC **:$001D ; Mod val.
    BCS SKIP_SUB ; No overflow.
    ADC #$F0 ; -= 0x11
SKIP_SUB: ; 1E:126C, 0x03D26C
    STA **:$0099 ; Store ??
    LDA ROM_DATA_UNK,X ; Load ??
    BMI EXIT_ALT_CREATOR ; Negative, goto.
    EOR **:$0099 ; Invert with.
    AND #$10 ; Keep bit.
    BNE NO_LOAD_UNK ; != 0,  goto.
    LDA ROM_DATA_UNK+3,X ; Load ??
NO_LOAD_UNK: ; 1E:127C, 0x03D27C
    STA DEEP_STREAM_MOD_UNK ; Store to.
    JMP PACKET_CREATOR_HELPER_ALOT ; Do.
EXIT_ALT_CREATOR: ; 1E:1281, 0x03D281
    JMP PACKET_CREATOR_HELPER_TODO_B ; TODO. <<<<<<<<<<<<<<<<<<<<
PTR_MOD_ARR: ; [2], 1E:1284, 0x03D284
    .db 00
    .db 00
ROM_DATA_UNK: ; [4], 1E:1286, 0x03D286
    .db 00
    .db 00
    .db 10
    .db F0
ROM_DATA_UNK: ; 1E:128A, 0x03D28A
    .db 10
DATA_TABLE_UNK: ; 1E:128B, 0x03D28B
    .db 88 ; 0x8 byte slots.
    .db 00
    .db 00
    .db 00
    .db 00
    .db 10
    .db F0
    .db 10
    .db 10
    .db 00
    .db 04
    .db 00
    .db 00
    .db 10
    .db 00
    .db FF
    .db 88
    .db 00
    .db 00
    .db 80
    .db 03
    .db F0
    .db 20
    .db 00
    .db 10
    .db 00
    .db 00
    .db 80
    .db 03
    .db F0
    .db 20
    .db 00
    .db 88
    .db 00
    .db 00
    .db 80
    .db 03
    .db F0
    .db 20
    .db 00
    .db 30
    .db 00
    .db 00
    .db 00
    .db 00
    .db 10
    .db 00
    .db FF
    .db 88
    .db 00
    .db 00
    .db 00
    .db 00
    .db 10
    .db F0
    .db 10
    .db 30
PACKET_CREATOR_HELPER_ALOT: ; 1E:12C4, 0x03D2C4
    JSR SCRIPT_R6/R7+LOGICAL_UNK ; Do.
    LDA #$11 ; 0x8 * 1 + 0x1
    STA PACKET_UPDATES_COUNT/SCRATCH ; Set result.
    LDX #$00 ; Index.
COUNT_MODDED_LOOP: ; 1E:12CD, 0x03D2CD
    LDA #$05
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Type, 0x5. Unique update.
    STA NMI_PPU_CMD_PACKETS_BUF+42,X ; 2nd packet.
    INX ; Index++
    LDA PACKET_UPDATES_COUNT/SCRATCH ; Load.
    ASL A ; << 1, *2. 2 groups, 2 tiles.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    STA NMI_PPU_CMD_PACKETS_BUF+42,X
    INX ; Index++
    LDA PPU_GROUPED_ADDR_LH+1 ; Move addr H.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    STA NMI_PPU_CMD_PACKETS_BUF+42,X
    INX ; Index++
    LDA PPU_GROUPED_ADDR_LH[2] ; Move addr L.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    ORA #$20 ; Always on other.
    STA NMI_PPU_CMD_PACKETS_BUF+42,X
    INX ; Index++
BITS_SET: ; 1E:12F4, 0x03D2F4
    JSR FIGURE_IDFK_RTN ; Do.
    LDY #$00 ; Stream reset.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from file.
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store to update buf.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF+1,X ; Store to update buf.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF+42,X ; Store to update buf higher.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load ??
    AND #$3F ; Keep lower.
    EOR SCRIPT_INVERT_UNK ; Invert ??
    STA NMI_PPU_CMD_PACKETS_BUF+43,X ; Store to update buf higher.
    INX ; Update buf += 0x2
    INX
    DEC PACKET_UPDATES_COUNT/SCRATCH ; --
    BEQ LOOP_CREATE_METATILES_OVER? ; == 0, goto.
    INC STREAM_DEEP_INDEX ; ++
    LDA STREAM_DEEP_INDEX ; Load.
    BIT BITS_ARBITRARY_TEST_HELPER_BYTE ; Test with.
    BNE BITS_SET ; Bits set, goto.
    SEC ; Prep sub.
    SBC #$10 ; -= 0x10
    STA STREAM_DEEP_INDEX ; Store to.
    LDA STREAM_UNK_DEEP_A+1 ; Load.
    EOR #$01 ; Invert ??
    STA STREAM_UNK_DEEP_A+1 ; Store back.
    LDA PPU_GROUPED_ADDR_LH[2] ; Load ??
    AND #$E0 ; Keep 1110.0000
    STA PPU_GROUPED_ADDR_LH[2] ; Store to, addr L.
    LDA PPU_GROUPED_ADDR_LH+1 ; Load.
    EOR #$04 ; Invert bit.
    STA PPU_GROUPED_ADDR_LH+1 ; Store back.
    SEC ; Prep sub.
    LDA #$11 ; Mod amount, 0x8+0x1
    SBC PACKET_UPDATES_COUNT/SCRATCH ; Sub.
    ASL A ; << 1, *2.
    STA NMI_PPU_CMD_PACKETS_BUF+1 ; Store to, addr 
    STA NMI_PPU_CMD_PACKETS_BUF+43
    JMP COUNT_MODDED_LOOP
LOOP_CREATE_METATILES_OVER?: ; 1E:1355, 0x03D355
    LDA #$09
    STA PACKET_UPDATES_COUNT/SCRATCH ; Tile.
    LDX #$54 ; Index.
    LDA #$07 ; Type, many one byte updates across addrs.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store to packet.
    INX ; Update buf++
    LDA PACKET_UPDATES_COUNT/SCRATCH ; Load.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Number of one-byte updates to packet.
    INX ; Index++
LOOP_CREATE_ONE_BYTES: ; 1E:1367, 0x03D367
    JSR CREATE_ONE_BYTE_UPDATES_UNK ; Do ??
    DEC PACKET_UPDATES_COUNT/SCRATCH ; --
    BEQ EXIT_RTS ; == 0, leave.
    INC **:$008E ; ++
    CLC ; Prep add.
    LDA DEEP_BASE_UNK ; Load, addr L.
    ADC #$02 ; += 0x2
    STA DEEP_BASE_UNK ; Store back.
    BIT BITS_ARBITRARY_TEST_HELPER_BYTE ; Test bits.
    BNE LOOP_CREATE_ONE_BYTES ; != 0, loop.
    SEC ; Prep sub.
    SBC #$10 ; Sub with.
    STA DEEP_BASE_UNK ; Store back.
    LDA **:$00A5 ; Load ??
    EOR #$01 ; Invert bit.
    STA **:$00A5 ; Store back.
    SEC ; Prep sub.
    LDA **:$008E ; Load ??
    SBC #$08 ; -= 0x8
    STA **:$008E ; Store back.
    LDA **:$008F ; Load ??
    EOR #$04 ; Invert ??
    STA **:$008F ; Store result.
    JMP LOOP_CREATE_ONE_BYTES ; Loop.
EXIT_RTS: ; 1E:1397, 0x03D397
    RTS ; Leave.
PACKET_CREATOR_HELPER_TODO_B: ; 1E:1398, 0x03D398
    JSR SCRIPT_R6/R7+LOGICAL_UNK
    SEC
    LDA #$F0
    SBC **:$0099
    CLC
    ADC STREAM_DEEP_INDEX
    STA STREAM_DEEP_INDEX
    LDA #$0F
    STA PACKET_UPDATES_COUNT/SCRATCH
    LDX #$00
    LDA #$06
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX
    LDA PACKET_UPDATES_COUNT/SCRATCH
    ASL A
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX
    LDA PPU_GROUPED_ADDR_LH+1
    AND #$FC
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX
    LDA PPU_GROUPED_ADDR_LH[2]
    AND #$1E
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    ORA #$01
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INX
    LDA **:$0099
    STA PPU_GROUPED_ADDR_LH[2]
    LDA PPU_GROUPED_ADDR_LH[2]
    SEC
    SBC #$10
    STA PPU_GROUPED_ADDR_LH[2]
    BCS 1E:13E9
    LDA STREAM_DEEP_INDEX
    ADC #$10
    STA STREAM_DEEP_INDEX
    JSR FIGURE_IDFK_RTN
    LDY #$00
    LDA [SCRIPT_B800_PTR_UNK[2]],Y
    AND #$3F
    EOR SCRIPT_INVERT_UNK
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INY
    LDA [SCRIPT_B800_PTR_UNK[2]],Y
    AND #$3F
    EOR SCRIPT_INVERT_UNK
    STA NMI_PPU_CMD_PACKETS_BUF+34,X
    INY
    LDA [SCRIPT_B800_PTR_UNK[2]],Y
    AND #$3F
    EOR SCRIPT_INVERT_UNK
    STA NMI_PPU_CMD_PACKETS_BUF+1,X
    INY
    LDA [SCRIPT_B800_PTR_UNK[2]],Y
    AND #$3F
    EOR SCRIPT_INVERT_UNK
    STA NMI_PPU_CMD_PACKETS_BUF+35,X
    INX
    INX
    DEC PACKET_UPDATES_COUNT/SCRATCH
    BEQ 1E:1425
    CLC
    LDA STREAM_DEEP_INDEX
    ADC #$10
    STA STREAM_DEEP_INDEX
    JMP 1E:13DA
    LDA #$08
    STA PACKET_UPDATES_COUNT/SCRATCH
    LDX #$44
    LDA #$07
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA PACKET_UPDATES_COUNT/SCRATCH
    STA NMI_PPU_CMD_PACKETS_BUF[64],X
    INX
    LDA **:$0099
    AND #$10
    BEQ 1E:1455
    SEC
    LDA DEEP_BASE_UNK
    PHA
    SBC #$10
    STA DEEP_BASE_UNK
    LDA #$20
    STA DEEP_STREAM_MOD_UNK
    JSR CREATE_ONE_BYTE_UPDATES_UNK
    PLA
    STA DEEP_BASE_UNK
    LDA #$10
    STA DEEP_STREAM_MOD_UNK
    BNE 1E:145C
    LDA #$10
    STA DEEP_STREAM_MOD_UNK
    JSR CREATE_ONE_BYTE_UPDATES_UNK
    DEC PACKET_UPDATES_COUNT/SCRATCH
    BEQ 1E:147E
    CLC
    LDA DEEP_BASE_UNK
    ADC #$20
    STA DEEP_BASE_UNK
    CLC
    LDA **:$008E
    ADC #$08
    STA **:$008E
    BCC 1E:1459
    SBC #$40
    STA **:$008E
    SEC
    LDA DEEP_BASE_UNK
    SBC #$10
    STA DEEP_BASE_UNK
    JMP 1E:1459
    RTS
BITS_ARBITRARY_TEST_HELPER_BYTE: ; 1E:147F, 0x03D47F
    .db 0F
CREATE_ONE_BYTE_UPDATES_UNK: ; 1E:1480, 0x03D480
    LDA **:$008F ; Load ??
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store, addr H.
    INX ; Index++
    LDA **:$008E ; Load ??
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store as addr L.
    INX ; Index++
    LDY DEEP_BASE_UNK ; Load stream index.
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$03 ; Keep lower.
    STA OR_AND_STORE_UNK ; Store to.
    INY ; Stream++
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$0C ; Keep lower.
    ORA OR_AND_STORE_UNK ; Set with other.
    STA OR_AND_STORE_UNK ; Store to.
    CLC ; Prep add.
    LDA DEEP_BASE_UNK ; Load ??
    ADC DEEP_STREAM_MOD_UNK ; Add with ??
    TAY ; To Y index.
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$30 ; Keep 0011.0000
    ORA OR_AND_STORE_UNK ; Or with.
    STA OR_AND_STORE_UNK ; Store to.
    INY ; Stream++
    LDA [STREAM_DEEP_B],Y ; Load from stream.
    AND #$C0 ; Keep upper.
    ORA OR_AND_STORE_UNK ; Set with others.
    STA NMI_PPU_CMD_PACKETS_BUF[64],X ; Store to buf, update data/tile.
    INX ; Index++
    RTS ; Leave.
SCRIPT_R6/R7+LOGICAL_UNK: ; 1E:14B7, 0x03D4B7
    LDA SCRIPT_R6_UNK ; Load.
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom.
    LDX #$06 ; Set as R6.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Bank.
    LDA SCRIPT_R7_UNK ; Load.
    LSR A ; >> 1, /2.
    ORA #$01 ; Set bottom.
    LDX #$07 ; Set as R7.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Bank it.
    JSR SETUP_DEEP_STREAM_UNK ; Do ??
    LDA **:$00AB ; Load.
    AND #$07 ; Keep bottom.
    STA **:$009A ; Store to.
    LDA SCRIPT_LOADED_SHIFTED_UNK[1] ; Load.
    LSR **:$009A ; Shift ??
    ROR A ; Into A.
    LSR **:$009A ; 2x
    ROR A
    STA **:$0098 ; Store built to.
    LDA **:$0099 ; Load ??
    EOR STREAM_DEEP_INDEX ; Invert.
    AND #$10 ; Keep.
    BNE BIT_0x10_SET ; != 0, set, goto.
    LDA STREAM_DEEP_INDEX ; Load ??
    AND #$EE ; Keep 1110.1110
    JMP 0xEE_ANDED_SEEDED ; Goto.
BIT_0x10_SET: ; 1E:14ED, 0x03D4ED
    SEC ; Prep sub.
    LDA STREAM_DEEP_INDEX ; Load ??
    SBC #$10 ; Sub upper.
    ORA #$10 ; Set it.
    AND #$FE ; Keep 1111.1110
0xEE_ANDED_SEEDED: ; 1E:14F6, 0x03D4F6
    BIT DEEP_STREAM_MOD_UNK ; Test ??
    BPL TEST_POSITIVE ; Positive, goto.
    LDX #$20
    STX DEEP_STREAM_MOD_UNK ; Set 0x20
    SEC ; Prep sub.
    SBC #$10 ; Sub ??
TEST_POSITIVE: ; 1E:1501, 0x03D501
    STA DEEP_BASE_UNK ; Store ??
    LDA **:$0099 ; Load.
    AND #$F0 ; Keep upper.
    STA PPU_GROUPED_ADDR_LH[2] ; Store to.
    LDA **:$009A ; Load.
    ASL PPU_GROUPED_ADDR_LH[2] ; Shift ??
    ROL A ; Into A.
    ASL PPU_GROUPED_ADDR_LH[2] ; 2x
    ROL A
    ORA #$20 ; Set ??
    STA PPU_GROUPED_ADDR_LH+1 ; Store to.
    ORA #$03 ; Set ??
    STA **:$008F ; Store to.
    LDA **:$0098 ; Load ??
    AND #$F0 ; Keep upper.
    LSR A ; >> 3, /8.
    LSR A
    LSR A
    ORA PPU_GROUPED_ADDR_LH[2] ; Set ??
    STA PPU_GROUPED_ADDR_LH[2] ; Store back to.
    LSR A ; >> 2, /4.
    LSR A
    AND #$07 ; Keep lower.
    STA **:$008E ; Store to.
    LDA **:$0099 ; Load ??
    LSR A ; >> 2, /4.
    LSR A
    AND #$38 ; Keep 0011.1000
    ORA #$C0 ; Set ??
    ORA **:$008E ; Set ??
    STA **:$008E ; Store result.
    RTS ; Leave.
FIGURE_IDFK_RTN: ; 1E:1537, 0x03D537
    LDY STREAM_DEEP_INDEX ; Load from stream.
    LDA [STREAM_UNK_DEEP_A[2]],Y ; Load ??
    AND #$80 ; Keep upper.
    LSR A ; >> 1, /2.
    STA SCRIPT_INVERT_UNK ; Store to.
    LSR A ; >> 1, /2.
    STA B800_PTR_L_ADD_UNK ; Store 0x40/0x00.
    BEQ VAL_UNSET ; == 0, goto.
    LDA **:$0013 ; Val alt.
    .db 2C ; NOTE: Bit trick around alt load.
VAL_UNSET: ; 1E:1548, 0x03D548
    LDA **:$0011 ; Load ??
    STA SCRIPT_B800_PTR_UNK+1 ; Store to, addr H.
    LDA [STREAM_UNK_DEEP_A[2]],Y ; Load ??
    ASL A ; << 2, *4.
    ASL A
    ROL SCRIPT_B800_PTR_UNK+1 ; Rotate into, addr H.
    STA SCRIPT_B800_PTR_UNK[2] ; Store val to, addr L.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load ??
    ADC #$90 ; += 0x90
    ADC B800_PTR_L_ADD_UNK ; Add ??
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    RTS
SETUP_DEEP_STREAM_UNK: ; 1E:155D, 0x03D55D
    LDA **:$00AB ; Load.
    AND #$07 ; Keep 0000.0111
    STA STREAM_UNK_DEEP_A+1 ; Store to.
    LDA SCRIPT_LOADED_SHIFTED_UNK[1] ; Load.
    LSR STREAM_UNK_DEEP_A+1 ; >> 1
    ROR A ; Rotate into A.
    LSR STREAM_UNK_DEEP_A+1 ; >> 1
    ROR A ; Rotate into A.
    LSR A ; >> 2, /4.
    LSR A
    ORA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Set other bits.
    STA STREAM_DEEP_INDEX ; Store result.
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Load val.
    LSR A ; Shift off bit.
    ROR STREAM_DEEP_INDEX ; Rotate into.
    LSR A ; 2x
    ROR STREAM_DEEP_INDEX
    LDA #$00
    STA STREAM_UNK_DEEP_A[2] ; Clear ??
    STA STREAM_DEEP_B
    STA STREAM_DEEP_C
    LDA STREAM_UNK_DEEP_A+1 ; Load ??
    CLC ; Prep add.
    ADC #$60 ; += 0x60
    STA STREAM_UNK_DEEP_A+1 ; Store back.
    ADC #$02 ; += 0x2.
    STA **:$00A5 ; Store to.
    ADC #$02 ; += 0x2.
    STA **:$00A7 ; Store to.
    RTS ; Leave.
R7/B800_SET/INIT_UNK: ; 1E:1591, 0x03D591
    JSR CREATE_B800_PTR ; Do ??
    LDY #$00
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from ptr.
    AND #$3F
    STA **:$0014 ; Set ??
    RTS ; Leave.
CREATE_B800_PTR: ; 1E:159D, 0x03D59D
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Load.
    LSR A ; Shift nibble.
    LSR A
    LSR A
    LSR A
    AND #$0E ; Keep 0000.1110
    STA **:$0094 ; Store to.
    ORA #$01 ; Set bit.
    LDX #$07 ; Set R7.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Bank R7 in.
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Load.
    LSR A ; >> 2, /4.
    LSR A
    AND #$07 ; Keep lower.
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    LDA **:$00AB ; Load.
    AND #$FC ; Keep 1111.1100
    CLC ; Prep add.
    STA SCRIPT_B800_PTR_UNK[2] ; Store to.
    LDA SCRIPT_B800_PTR_UNK+1 ; Load.
    ADC #$B8 ; Add 0xB8
    STA SCRIPT_B800_PTR_UNK+1 ; Store to.
    RTS ; Leave.
SCRIPT_SET_GFX: ; 1E:15C4, 0x03D5C4
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B?+1 ; Load.
    ADC #$02 ; += 0x2
    STA **:$00AB ; Store to.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load.
    ADC #$C0 ; Add with.
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store to.
    LDA SCRIPT_PAIR_PTR?+1 ; Load.
    ADC #$01 ; Add with.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store to.
    JSR CREATE_B800_PTR ; Make PTR.
    LDY #$00 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from PTR.
    AND #$3F ; Keep lower.
    CMP **:$0014 ; If _ #$14
    BEQ SET_MULTIPLE? ; ==, goto.
    LDA **:$0017 ; Load.
    LDX #$03 ; Gfx bank R3.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX.
    STA SCRIPT_R7_UNK ; Store val to.
    AND #$03 ; Keep lower.
    STA **:$0013 ; Store to.
    RTS ; Leave.
SET_MULTIPLE?: ; 1E:15F3, 0x03D5F3
    LDA FLAG_UNK_23 ; Load.
    BEQ VAL_ZERO ; == 0, goto.
    BPL VAL_POSITIVE ; Positive, goto.
    AND #$7F ; Keep lower.
    STA FLAG_UNK_23 ; Store val to.
    BPL GFX_BANK_R2_SET ; Positive, goto. Always taken.
VAL_ZERO: ; 1E:15FF, 0x03D5FF
    LDY #$01 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load ??
    AND #$3F ; Keep lower.
    STA SCRIPT_R6_ROUTINE_SELECT ; Store to.
    TAX ; To X index.
    LDA LUT_GFX_BANKS_R1,X ; Load index.
    BEQ GFX_BANK_R2_SET ; == 0, skip R1 set.
VAL_POSITIVE: ; 1E:160D, 0x03D60D
    LDX #$01 ; R1 seed.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX bank.
GFX_BANK_R2_SET: ; 1E:1612, 0x03D612
    LDY #$02 ; Stream index.
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    LDX #$02 ; R2 seed.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX.
    STA SCRIPT_R6_UNK ; Store val to.
    AND #$03 ; Keep lower.
    STA **:$0011 ; Store to.
    INY ; Stream++
    LDA [SCRIPT_B800_PTR_UNK[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    LDX #$03 ; R3 mod here.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set GFX.
    STA SCRIPT_R7_UNK ; Store to.
    AND #$03 ; Keep lower.
    STA **:$0013 ; Store to.
    RTS ; Leave.
LUT_GFX_BANKS_R1: ; 1E:1634, 0x03D634
    .db 00 ; 0x00 = No mod ??
    .db 68
    .db 62
    .db 62
    .db 62
    .db 62
    .db 64
    .db 62
    .db 74
    .db 64
    .db 6A
    .db 62
    .db 66
    .db 6C
    .db 62
    .db 00
    .db 00
    .db 00
    .db 00
    .db 00
    .db 66
    .db 00
    .db 6A
    .db 66
    .db 62
    .db 68
    .db 64
    .db 68
    .db 6E
    .db 66
    .db 66
    .db 66
    .db 62
    .db 62
    .db 62
    .db 66
    .db 64
    .db 6E
    .db 62
    .db 64
    .db 66
    .db 74
    .db 6C
    .db 66
    .db 00
    .db 00
    .db 68
    .db 6C
    .db 72
    .db 00
    .db 66
    .db 00
    .db 00
    .db 00
    .db 6A
    .db 00
    .db 6C
    .db 6E
    .db 6C
    .db 6E
    .db 6C
    .db 6E
    .db 6E
    .db 00
HUGE_ASS_STREAMS_THINGY_IDFK: ; 1E:1674, 0x03D674
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Load flag.
    BPL SETUP_POSITIVE ; Positive, goto.
    AND #$0F ; Keep lower.
    STA **:$003E ; Store to.
    LDA **:$6784 ; Load ??
    AND #$C0 ; Keep 1100.0000
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store to.
    LDA **:$6785 ; Move ??
    STA **:$00AB
    LDA **:$6786 ; Load.
    AND #$C0 ; Keep 1100.0000
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store 1100.0000
    LDA **:$6787 ; Move ??
    STA SCRIPT_LOADED_SHIFTED_|VAL+1
    JMP SETUP_NEG_COMPLETED
SETUP_POSITIVE: ; 1E:1697, 0x03D697
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load.
    AND #$3F ; Keep lower.
    STA **:$003E ; Store to.
    CLC ; Prep add ?
    LDA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Load.
    AND #$C0 ; Keep 1100.0000
    STA SCRIPT_PAIR_PTR_B?[2] ; Store to.
    ADC #$00 ; Carry add. (+0?)
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store to.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+5 ; Move val.
    STA SCRIPT_PAIR_PTR_B?+1
    ADC #$02 ; += 0x2
    STA **:$00AB ; Store to.
    CLC ; Prep add.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Load.
    AND #$C0 ; Keep bits 1100.0000
    STA SCRIPT_PAIR_PTR?[2] ; Store to.
    ADC #$C0 ; += 0xC0
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store to.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+7 ; Move ??
    STA SCRIPT_PAIR_PTR?+1
    ADC #$01 ; += 0x1 + C
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store to.
    JSR R7/B800_SET/INIT_UNK ; Do ??
SETUP_NEG_COMPLETED: ; 1E:16CB, 0x03D6CB
    JSR SETUP_DEEP_STREAM_UNK ; Do ??
    JSR SETUP_PTR_6780_UNK ; Setup ??
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable with writes.
    LDA FLAG_UNK_23 ; Load ??
    BNE NONZERO_ALT ; != 0, do alt.
    LDX #$00 ; Load index.
X_LOOP_TO_TARGET: ; 1E:16DA, 0x03D6DA
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load indexes.
    BEQ SKIP_UNK ; == 0, goto.
    JSR MOVE_TO_STREAM_UNK_WITH_MOD ; Move a bit.
    LDY #$19 ; Seed stream index.
    LDA #$88 ; Val ??
    STA [ENGINE_FPTR_30[2]],Y ; Store to ptr.
    LDA #$0C ; Seed ??
    CPX #$00 ; If _ #$00
    BNE SKIP_UNK ; X != 0, goto.
    LDY #$1C ; Stream index set.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
SKIP_UNK: ; 1E:16F2, 0x03D6F2
    LDY #$00 ; Reset stream.
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream.
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Load flag.
    AND #$C0 ; Keep 1100.0000
    BEQ TOP_0x00_ALT ; == 0, goto.
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do mod.
    INX ; X++
    CPX #$04 ; If _ #$04
    BCC X_LOOP_TO_TARGET ; <, goto.
ALT_REENTRY: ; 1E:1704, 0x03D704
    LDA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Load.
    AND #$3F ; Keep lower.
    BEQ VAL_EQ_0x00_CLOSE ; == 0, goto.
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH? ; Do with val.
VAL_EQ_0x00_CLOSE: ; 1E:170E, 0x03D70E
    LDA #$00
    STA FIRST_LAUNCHER_HOLD_FLAG? ; Clear flag.
    LDA SCRIPT_FLAG_0x22 ; Load.
    AND #$CF ; Keep 1100.1111
    STA SCRIPT_FLAG_0x22 ; Store back.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Goto, disable WRAM and leave.
NONZERO_ALT: ; 1E:171B, 0x03D71B
    JSR MOVE_TO_STREAM_UNK ; Do ??
    LDY #$00 ; Stream reset.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    AND #$3F ; Keep lower.
    CMP #$0D ; If _ #$0D
    BNE VAL_NONZERO ; != 0, goto.
    JSR MOD_STREAM_LUT_UNK ; Do ??
    LDY #$19 ; Stream index.
    LDA **:$003E ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    EOR #$04 ; Invert bit.
    STA **:$003E ; Store val.
    JSR MOVE_TO_STREAM_UNK ; Do.
VAL_NONZERO: ; 1E:1738, 0x03D738
    JMP ALT_REENTRY ; Goto, abuse RTS.
TOP_0x00_ALT: ; 1E:173B, 0x03D73B
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; Load.
    BEQ ALT_ZERO_B ; == 0, goto.
    JSR STREAMS_MOD_UNK ; Do ??
    BCC RET_CC_UNK ; Ret CC, goto. Always taken.
ALT_ZERO_B: ; 1E:1745, 0x03D745
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM writes.
    LDY #$00 ; Stream index.
    LDA #$00 ; Value.
    STA [ENGINE_FPTR_30[2]],Y ; Clear it.
RET_CC_UNK: ; 1E:1751, 0x03D751
    INX ; X++
    CPX #$03 ; If _ #$03
    BCC TOP_0x00_ALT ; <, goto.
    JMP ALT_REENTRY ; Reenter.
L_1E:1759: ; 1E:1759, 0x03D759
    PHA
    LDX #$00
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X
    BEQ 1E:1769
    INX
    CPX #$03
    BCC 1E:175C
    PLA
    RTS
STREAMS_MOD_UNK: ; 1E:1768, 0x03D768
    PHA ; Save A.
    TXA ; Save X.
    PHA
    JSR CREATE_PTR_HELPER_6700 ; Create.
    JSR MOD_STREAM_LUT_UNK ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM.
    PLA ; Pull A/X passed.
    TAX
    PLA
    STA CURRENT_SAVE_MANIPULATION_PAGE+9,X ; A to X index.
    JSR MOVE_TO_STREAM_UNK_WITH_MOD ; Do with init.
    LDY #$19 ; Stream index.
    LDA **:$003E ; Load ??
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream.
    LDY #$00 ; Stream index.
    LDA #$0C ; Val ??
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream.
    CLC ; Set to known state for branch after this routine call?
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Leave.
L_1E:178D: ; 1E:178D, 0x03D78D
    LDX #$00
    CMP CURRENT_SAVE_MANIPULATION_PAGE+8,X
    BEQ 1E:179A
    INX
    CPX #$04
    BCC 1E:178F
    RTS
    JSR ENGINE_WRAM_STATE_WRITEABLE
    CPX #$03
    BCS 1E:17AC
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X
    BEQ 1E:17AE
    STA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    INX
    BCC 1E:179D
    LDA #$00
    STA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    TXA
    JSR CREATE_PTR_HELPER_6700
    JSR 1E:1FBF
    JSR SETUP_PTR_6780_UNK
    LDX #$00
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    BEQ 1E:17CF
    JSR STREAM_TO_STREAM_MOD/MOVE_UNK
    LDA #$0C
    CPX #$00
    BNE 1E:17CF
    LDY #$1C
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    LDY #$00
    STA [ENGINE_FPTR_30[2]],Y
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD?
    INX
    CPX #$04
    BCC 1E:17BD
    CLC
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
MOVE_TO_STREAM_UNK_WITH_MOD: ; 1E:17DF, 0x03D7DF
    JSR STREAM_TO_STREAM_MOD/MOVE_UNK ; Do ??
MOVE_TO_STREAM_UNK: ; 1E:17E2, 0x03D7E2
    LDY #$04 ; Stream index.
    LDA SCRIPT_LOADED_SHIFTED_UNK[1] ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    INY ; Stream++
    LDA **:$00AB ; Load ??
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$06 ; Stream reset.
    LDA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    INY ; Stream++
    LDA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$11 ; Stream reset.
    LDA STREAM_DEEP_INDEX ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    INY ; Stream++
    LDA STREAM_DEEP_C ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    INY ; Stream++
    LDA **:$00A7 ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    LDA **:$003E ; Load ??
    LDY #$15 ; Stream set.
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream.
    LDY #$1D ; Stream set.
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream.
    RTS ; Leave.
STREAM_TO_STREAM_MOD/MOVE_UNK: ; 1E:1813, 0x03D813
    LDY #$02 ; Seed stream index.
    AND #$07 ; Keep lower bits.
    STA R6_BANKED_ADDR_MOVED+1 ; Store to.
    LDA #$00 ; Clear val.
    LSR R6_BANKED_ADDR_MOVED+1 ; Rotate bit off.
    ROR A ; Rotate into A.
    LSR R6_BANKED_ADDR_MOVED+1 ; Rotate bit off.
    ROR A ; Into A.
    STA R6_BANKED_ADDR_MOVED[2] ; Store val to, addr L.
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream indexed.
    INY ; Stream++
    LDA R6_BANKED_ADDR_MOVED+1 ; Load addr H.
    ADC #$74 ; += 0x74, $7400 base.
    STA R6_BANKED_ADDR_MOVED+1 ; Store to R6 ptr.
    STA [ENGINE_FPTR_30[2]],Y ; Store to stream.
    LDY #$1D ; Seed stream val.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream made.
    LDY #$14 ; Seed stream val.
    PHA ; Save loaded.
    AND #$F0 ; Keep upper.
    STA [ENGINE_FPTR_30[2]],Y ; Store to other stream ptr.
    LDY #$08 ; Seed stream index.
    PLA ; Pull original loaded.
    AND #$0F ; Keep lower.
    STA [ENGINE_FPTR_30[2]],Y ; Store to other stream ptr.
    LDY #$1E ; Reseed stream.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from.
    LDY #$16 ; Reseed stream.
    STA [ENGINE_FPTR_30[2]],Y ; Store to.
    LDY #$1F ; Reseed stream.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from.
    LDY #$17 ; Reseed.
    STA [ENGINE_FPTR_30[2]],Y ; Store to.
    CLC ; Prep ret CC and add later.
    LDY #$01 ; Reseed stream.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from.
    BPL RET_CC ; Positive, goto.
    AND #$80 ; Keep only the negative flag.
    STA [R6_BANKED_ADDR_MOVED[2]],Y ; Store 0x80.
    LDY #$16 ; Reseed stream.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from.
    ADC #$A0 ; += 0xA0
    STA [ENGINE_FPTR_30[2]],Y ; Store back.
    INY ; Stream++
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    ADC #$00 ; Carry add.
    STA [ENGINE_FPTR_30[2]],Y ; Store back.
    SEC ; Ret CS.
RET_CC: ; 1E:186B, 0x03D86B
    RTS ; Leave.
CREATE_PTR_HELPER_6700: ; 1E:186C, 0x03D86C
    STA ENGINE_FPTR_30+1 ; A to.
    LDA #$00 ; Clear bits for shift.
    LSR ENGINE_FPTR_30+1 ; Rotate bits from into A.
    ROR A
    LSR ENGINE_FPTR_30+1 ; 2x
    ROR A
    LSR ENGINE_FPTR_30+1 ; 3x
    ROR A
    ADC #$80 ; += 0x80, stride 0x40
    STA ENGINE_FPTR_30[2] ; Store to addr L, stride 0x20.
    LDA ENGINE_FPTR_30+1 ; Load what is left.
    ADC #$67 ; += 0x67, ptr H mod.
    STA ENGINE_FPTR_30+1 ; Store addr H. Stride 1 range 0x20.
    RTS ; Leave.
MOD_STREAM_LUT_UNK: ; 1E:1884, 0x03D884
    LDY #$15 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    STA **:$003E ; Store to.
    EOR #$04 ; Invert bit.
    ASL A ; << 3, *8.
    ASL A
    ASL A
    TAX ; To X index.
    LDY #$04 ; Val ??
    CLC ; Prep add.
    LDA LUT_MOD_0x0[4],X ; Load mod.
    ADC [ENGINE_FPTR_30[2]],Y ; Mod val at stream.
    STA SCRIPT_LOADED_SHIFTED_UNK[1] ; Store to.
    INY ; Stream++
    LDA LUT_MOD_0x0+1,X ; Load mod.
    ADC [ENGINE_FPTR_30[2]],Y ; Mod with carry.
    STA **:$00AB ; Store to.
    LDY #$06 ; Stream mod.
    CLC ; Prep add.
    LDA LUT_MOD_0x0+2,X ; Load mod.
    ADC [ENGINE_FPTR_30[2]],Y ; Mod val at stream.
    STA SCRIPT_LOADED_SHIFTED_|VAL[2] ; Store to.
    INY ; Stream++
    LDA LUT_MOD_0x0+3,X ; Load ??
    ADC [ENGINE_FPTR_30[2]],Y ; Mod with carry.
    STA SCRIPT_LOADED_SHIFTED_|VAL+1 ; Store to.
    JSR SETUP_DEEP_STREAM_UNK ; Setup ??
    JMP ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Do mod, leave.
    JSR CREATE_PTR_HELPER_6700
    LDY #$02
    LDA [ENGINE_FPTR_30[2]],Y
    STA R6_BANKED_ADDR_MOVED[2]
    INY
    LDA [ENGINE_FPTR_30[2]],Y
    STA R6_BANKED_ADDR_MOVED+1
    RTS
    LDA #$07
    JSR L_1E:178D
    LDA #$06
    JMP L_1E:178D
L_1E:18D3: ; 1E:18D3, 0x03D8D3
    LDA CURRENT_SAVE_MANIPULATION_PAGE+385
    BPL 1E:18DD
    LDA #$06
    JSR L_1E:178D
    LDA CURRENT_SAVE_MANIPULATION_PAGE+449
    BPL 1E:18E7
    LDA #$07
    JSR L_1E:178D
    LDX #$00
    STX SLOT/DATA_OFFSET_USE?
    JSR X_INDEX_TEST_UNK
    BCS 1E:1906
    TXA
    JSR 1E:18BA
    JSR ENGINE_WRAM_STATE_WRITEABLE
    JSR 1E:1840
    BCS 1E:18FE
    INC SLOT/DATA_OFFSET_USE?
    JSR ENGINE_WRAM_STATE_WRITE_DISABLED
    INX
    CPX #$04
    BCC 1E:18EB
    STX GAME_SLOT_CURRENT?
    LDA SLOT/DATA_OFFSET_USE?
    BEQ 1E:190E
    CLC
    RTS
    JSR 1E:18C9
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDA #$00
    STA CURRENT_SAVE_MANIPULATION_PAGE+65
    STA CURRENT_SAVE_MANIPULATION_PAGE+86
    STA CURRENT_SAVE_MANIPULATION_PAGE+87
    LDA CURRENT_SAVE_MANIPULATION_PAGE+67
    STA CURRENT_SAVE_MANIPULATION_PAGE+84
    LDA CURRENT_SAVE_MANIPULATION_PAGE+68
    STA CURRENT_SAVE_MANIPULATION_PAGE+85
    LDA CURRENT_SAVE_MANIPULATION_PAGE+16
    LSR CURRENT_SAVE_MANIPULATION_PAGE+17
    ROR A
    ADC #$00
    STA CURRENT_SAVE_MANIPULATION_PAGE+16
    LDA CURRENT_SAVE_MANIPULATION_PAGE+17
    ADC #$00
    STA CURRENT_SAVE_MANIPULATION_PAGE+17
    LDA #$01
    STA SLOT/DATA_OFFSET_USE?
    LDA #$00
    STA MAIN_FLAG_UNK
    STA FLAG_UNK_23
    LDX STREAM_REPLACE_COUNT?
    LDY 1E:196B,X
    LDX #$03
    LDA 1E:196F,Y
    STA CURRENT_SAVE_MANIPULATION_PAGE+4,X
    DEY
    DEX
    BPL 1E:1950
    LDA CURRENT_SAVE_MANIPULATION_PAGE+6
    AND #$0F
    ORA #$20
    STA FIRST_LAUNCHER_HOLD_FLAG?
    EOR #$60
    STA SCRIPT_FLAG_0x22
    SEC
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
    .db 03
    .db 03
    .db 03
    .db 07
    .db 5C
    .db DF
    .db 00
    .db 24
    .db 8B
    .db DF
    .db 40
    .db DB
L_1E:1977: ; 1E:1977, 0x03D977
    DEC GAME_SLOT_CURRENT?
    BMI 1E:1997
    BEQ 1E:1997
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8
    CMP #$01
    BEQ 1E:198C
    JSR 1E:1998
    BCS 1E:197D
    JSR 1E:1998
    LDA #$00
    JSR 1E:18BA
    LDY #$01
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    BMI 1E:1989
    RTS
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDX #$00
    STX SLOT/DATA_OFFSET_USE?
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    PHA
    LDA CURRENT_SAVE_MANIPULATION_PAGE+9,X
    STA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    PLA
    STA CURRENT_SAVE_MANIPULATION_PAGE+9,X
    LDA #$02
    JSR 1E:19DE
    LDA #$03
    JSR 1E:19DE
    LDA #$08
    PHA
    JSR 1E:19DE
    PLA
    CLC
    ADC #$01
    CMP #$11
    BCC 1E:19B9
    LDA #$16
    JSR 1E:19DE
    LDA #$17
    JSR 1E:19DE
    CLC
    LDA SLOT/DATA_OFFSET_USE?
    ADC #$20
    STA SLOT/DATA_OFFSET_USE?
    INX
    CPX GAME_SLOT_CURRENT?
    BCC 1E:199F
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
    CLC
    ADC SLOT/DATA_OFFSET_USE?
    TAY
    LDA R_**:$6780,Y
    PHA
    LDA **:$67A0,Y
    STA R_**:$6780,Y
    PLA
    STA **:$67A0,Y
    RTS
X_INDEX_TEST_UNK: ; 1E:19F1, 0x03D9F1
    SEC ; Prep sub.
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X ; Load ??
    BEQ RTS ; == 0, goto.
    CMP #$06 ; If _ #$06
RTS: ; 1E:19F9, 0x03D9F9
    RTS ; 0x01-0x05, CC. CS otherwise.
L_1E:19FA: ; 1E:19FA, 0x03D9FA
    LDX #$00
    LDA CURRENT_SAVE_MANIPULATION_PAGE+8,X
    BEQ 1E:1A10
    JSR CREATE_PTR_UNK
    LDY #$2C
    LDA **:$73D8,Y
    STA [ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]],Y
    INY
    CPY #$30
    BCC 1E:1A06
    INX
    CPX #$04
    BCC 1E:19FC
    RTS
    JSR ENGINE_SETTLE_ALL_UPDATES?
    JSR ENGINE_0x300_OBJECTS_UNK?
    LDX #$00
    JSR X_INDEX_TEST_UNK
    BCS 1E:1A3C
    TXA
    JSR 1E:18BA
    LDY #$01
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    BMI 1E:1A3C
    LDY #$10
    LDA [ENGINE_FPTR_30[2]],Y
    TAY
    LDA #$80
    STA **:$0306,Y
    LDA #$81
    STA **:$0307,Y
    INX
    CPX #$04
    BCC 1E:1A1E
    LDA #$01
    STA NMI_FLAG_E5_TODO
    JMP ENGINE_SETTLE_ALL_UPDATES?
L_1E:1A48: ; 1E:1A48, 0x03DA48
    LDA SLOT/DATA_OFFSET_USE?
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    LDA **:$0049
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    LDA **:$004A
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    LDA **:$004B
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+2
    JSR ENGINE_NUMS_UNK_MODULO?
    LDA ARR_BITS_TO_UNK[8]
    BEQ 1E:1A61
    LDA #$01
    CLC
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    STA **:$0049
    LDA #$00
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    STA **:$004A
    LDA #$00
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE+2
    STA **:$004B
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDX #$00
    JSR X_INDEX_TEST_UNK
    BCS 1E:1ADD
    STA R_**:$0028
    TXA
    LSR A
    ROR A
    ROR A
    ROR A
    STA SCRIPT_INDEX_53_UNK
    TXA
    PHA
    JSR 1E:18BA
    LDY #$01
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    BMI 1E:1ADB
    LDA STREAM_REPLACE_COUNT?
    BNE 1E:1AD8
    LDY #$11
    CLC
    LDA **:$0049
    ADC [R6_BANKED_ADDR_MOVED[2]],Y
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    INY
    LDA **:$004A
    ADC [R6_BANKED_ADDR_MOVED[2]],Y
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    INY
    LDA **:$004B
    ADC [R6_BANKED_ADDR_MOVED[2]],Y
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    BCC 1E:1AB9
    LDY #$11
    LDA #$FF
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    INY
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    INY
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    LDY #$10
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    JSR L_1E:1B40
    LDY #$11
    SEC
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    SBC SAVE_GAME_MOD_PAGE_PTR[2]
    INY
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    SBC SAVE_GAME_MOD_PAGE_PTR+1
    INY
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    SBC ALT_STUFF_INDEX?
    BCC 1E:1AD8
    JSR 1E:1B6C
    BCC 1E:1AB9
    JSR 1E:1C87
    PLA
    TAX
    INX
    CPX #$04
    BCC 1E:1A77
    JSR 1E:043F
    LDA STREAM_REPLACE_COUNT?
    BNE 1E:1B30
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDX #$12
    JSR 1E:1C11
    LDX #$15
    JSR 1E:1C11
    LDA FLAG_UNK_48
    BEQ 1E:1B30
    STA R_**:$0029
    JSR ENGINE_HELPER_R7_0x13
    JSR $BBC3
    LDA #$FF
    STA R_**:$002A
    LDA R_**:$002B
    ORA #$1F
    ASL R_**:$002A
    ASL A
    BCC 1E:1B0A
    JSR ADDS_IDFK
    AND R_**:$002A
    BNE 1E:1B30
    JSR $BB8C
    LDX #$00
    JSR X_INDEX_TEST_UNK
    BCS 1E:1B2B
    STA R_**:$0028
    TXA
    PHA
    JSR $A979
    PLA
    TAX
    BCC 1E:1B33
    INX
    CPX #$04
    BCC 1E:1B1B
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
    JSR ENGINE_HELPER_R7_0x17
    LDA #$06
    STA **:$07F1
    LDA #$8C
    JMP $A3F8
L_1E:1B40: ; 1E:1B40, 0x03DB40
    TAX
    INX
    STX SAVE_GAME_MOD_PAGE_PTR[2]
    INX
    STX ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    LDA #$00
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+2
    JSR LIB_DECIMAL?_UNK
    JSR LIB_DECIMAL?_UNK
    JSR 1E:1CDF
    LDY #$00
    LDA [ARR_BITS_TO_UNK[8]],Y
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    JSR LIB_DECIMAL?_UNK
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    STA SAVE_GAME_MOD_PAGE_PTR[2]
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE+2
    STA SAVE_GAME_MOD_PAGE_PTR+1
    LDA ENGINE_TO_DECIMAL_INDEX_POSITION
    STA ALT_STUFF_INDEX?
    RTS
    LDY #$10
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    CMP #$63
    BCC 1E:1B75
    RTS
    ADC #$01
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    JSR 1E:043F
    JSR ENGINE_WRAM_STATE_WRITEABLE
    LDA #$FF
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH?
    LDA #$1F
    JSR STORE_IF_MISMATCH_OTHERWISE_WAIT_MENU_DEPTH?
    LDA #$82
    JSR $A3F8
    JSR 1E:1CDF
    LDY #$03
    JSR ADDS_IDFK
    LSR A
    LSR A
    LSR A
    LSR A
    LSR A
    LSR A
    CLC
    ADC [ARR_BITS_TO_UNK[8]],Y
    LSR A
    STA 57_INDEX_UNK,Y
    INY
    CPY #$08
    BCC 1E:1B93
    LDY #$0B
    CLC
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    ADC **:$004D,Y
    BCC 1E:1BBC
    SBC **:$004D,Y
    EOR #$FF
    STA **:$004D,Y
    LDA #$FF
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    LDA **:$004D,Y
    BEQ 1E:1BCD
    TYA
    PHA
    CLC
    ADC #$7B
    JSR $A3F8
    PLA
    TAY
    INY
    CPY #$10
    BCC 1E:1BAA
    LDY #$07
    LDA **:$0058
    JSR 1E:1C64
    LDY #$09
    LDA **:$0059
    JSR 1E:1C64
    LDY #$0E
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    CLC
    ADC #$14
    BCC 1E:1BED
    LDA #$FF
    LDY #$03
    JSR 1E:1C3F
    LDA #$84
    JSR 1E:1C38
    LDA R_**:$0028
    CMP #$03
    BCS 1E:1C0F
    LDY #$0F
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    LSR A
    CLC
    LDY #$05
    JSR 1E:1C3F
    LDA #$85
    JSR 1E:1C38
    CLC
    RTS
    CLC
    LDA **:$004C
    ADC CURRENT_SAVE_MANIPULATION_PAGE[768],X
    STA CURRENT_SAVE_MANIPULATION_PAGE[768],X
    LDA **:$004D
    ADC CURRENT_SAVE_MANIPULATION_PAGE+1,X
    STA CURRENT_SAVE_MANIPULATION_PAGE+1,X
    LDA #$00
    ADC SAVE_SLOT_DATA_UNK_A,X
    STA SAVE_SLOT_DATA_UNK_A,X
    BCC 1E:1C37
    LDA #$FF
    STA CURRENT_SAVE_MANIPULATION_PAGE[768],X
    STA CURRENT_SAVE_MANIPULATION_PAGE+1,X
    STA SAVE_SLOT_DATA_UNK_A,X
    RTS
    LDX FPTR_5C_UNK+1
    BEQ 1E:1C70
    JMP $A3F8
    CLC
    ADC ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    LDA #$00
    ROL A
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    SEC
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2]
    SBC [R6_BANKED_ADDR_MOVED[2]],Y
    TAX
    INY
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1
    SBC [R6_BANKED_ADDR_MOVED[2]],Y
    BEQ 1E:1C5C
    LDX #$08
    BCS 1E:1C5C
    LDX #$01
    DEY
    TXA
    ASL A
    JSR 1E:1C71
    STA FPTR_5C_UNK+1
    CLC
    ADC [R6_BANKED_ADDR_MOVED[2]],Y
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    INY
    LDA #$00
    ADC [R6_BANKED_ADDR_MOVED[2]],Y
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    RTS
    CMP #$10
    BCC 1E:1C77
    LDA #$10
    TAX
    JSR ADDS_IDFK
    LSR A
    LSR A
    LSR A
    LSR A
    JSR ENGINE_NUMS_IDFK
    LSR A
    LSR A
    LSR A
    LSR A
    RTS
    LDA MAIN_FLAG_UNK
    BNE 1E:1CCC
    JSR 1E:1CDF
    LDY #$02
    LDA [ARR_BITS_TO_UNK[8]],Y
    BEQ 1E:1CCC
    PHA
    LDX #$C0
    STX R_**:$0029
    JSR 1E:1CE6
    PLA
    PHA
    TAY
    LDA [ARR_BITS_TO_UNK[8]],Y
    LDY #$10
    CMP [R6_BANKED_ADDR_MOVED[2]],Y
    BCS 1E:1CC6
    JSR SUB_TODO
    AND [R6_BANKED_ADDR_MOVED[2]],Y
    BNE 1E:1CC6
    JSR ADDS_IDFK
    AND #$C0
    BNE 1E:1CC6
    LDA [R6_BANKED_ADDR_MOVED[2]],Y
    ORA LUT_INDEX_TO_BITS_0x80-0x01,X
    STA [R6_BANKED_ADDR_MOVED[2]],Y
    LDA #$09
    STA **:$07F1
    LDA #$83
    JSR $A3F8
    LDX R_**:$0029
    INX
    BNE 1E:1C97
    PLA
    RTS
SUB_TODO: ; 1E:1CCD, 0x03DCCD
    LDA R_**:$0029
    CLC
    ADC #$C0
    ROR A
    LSR A
    LSR A
    TAY
    LDA R_**:$0029
    AND #$07
    TAX
    LDA LUT_INDEX_TO_BITS_0x80-0x01,X
    RTS
    CLC
    LDA R_**:$0028
    ADC #$B8
    BCC 1E:1CE8
    LDA R_**:$0029
    ASL A
    ROL ARR_BITS_TO_UNK+1
    ASL A
    ROL ARR_BITS_TO_UNK+1
    ASL A
    ROL ARR_BITS_TO_UNK+1
    CLC
    ADC #$00
    STA ARR_BITS_TO_UNK[8]
    LDA ARR_BITS_TO_UNK+1
    AND #$07
    ADC #$98
    STA ARR_BITS_TO_UNK+1
    JMP 1E:1E8B
MANY_STREAMS_UNK: ; 1E:1D01, 0x03DD01
    JSR SETUP_PTR_6780_UNK ; Setup ptr.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable writes.
LOOP_NONZERO: ; 1E:1D07, 0x03DD07
    LDY #$00 ; Stream reset.
    LDA [ENGINE_FPTR_30[2]],Y ; Load.
    ASL A ; << 1, *2.
    BEQ DONE_FORWARD ; ==, goto.
    JSR MAP?_RTN_A ; Do ??
    BCS RET_CS ; CS, goto.
    LDY #$00 ; Stream reset.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from.
    ORA #$80 ; Set.
    STA [ENGINE_FPTR_30[2]],Y ; Store back.
    BMI DONE_FORWARD ; Always taken, goto.
RET_CS: ; 1E:1D1D, 0x03DD1D
    LDY #$00 ; Stream reset.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from.
    AND #$3F ; Keep lower.
    STA [ENGINE_FPTR_30[2]],Y ; Store back.
    JSR SWITCH_MAP/SCREEN? ; Switch with.
    JSR STREAMS_UNK_LOGICAL? ; Do.
DONE_FORWARD: ; 1E:1D2B, 0x03DD2B
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Forward.
    INC GAME_SLOT_CURRENT? ; ++
    BNE LOOP_NONZERO ; != 0, goto.
    LDA FIRST_LAUNCHER_HOLD_FLAG? ; Load ??
    BNE EXIT_NO_WRITES ; != 0, goto.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load ??
    AND #$C0 ; Keep upper.
    ORA VAL_CMP_UNK ; Set ??
    LDX SCRIPT_PAIR_PTR_B?+1 ; X from.
    STA CURRENT_SAVE_MANIPULATION_PAGE+4 ; Store ??
    STX CURRENT_SAVE_MANIPULATION_PAGE+5
    LDA SCRIPT_PAIR_PTR?[2] ; Load.
    AND #$C0 ; Keep upper.
    ORA R_**:$6795 ; Set with WRAM.
    LDX SCRIPT_PAIR_PTR?+1 ; X from.
    STA CURRENT_SAVE_MANIPULATION_PAGE+6 ; Store ??
    STX CURRENT_SAVE_MANIPULATION_PAGE+7
EXIT_NO_WRITES: ; 1E:1D54, 0x03DD54
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; No writes, abuse RTS.
SETUP_PTR_6780_UNK: ; 1E:1D57, 0x03DD57
    LDA #$80 ; Seed PTR $6780
    LDX #$67
    STA ENGINE_FPTR_30[2]
    STX ENGINE_FPTR_30+1
    LDX #$FC
    STX GAME_SLOT_CURRENT? ; Set ??
    RTS ; Leave.
ENGINE_FPTR_COL/ROW_MOD/FORWARD?: ; 1E:1D64, 0x03DD64
    CLC ; Prep add.
    LDA ENGINE_FPTR_30[2] ; Load.
    ADC #$20 ; Add 0x32, col.
    STA ENGINE_FPTR_30[2] ; Store result.
    LDA ENGINE_FPTR_30+1 ; Carry add.
    ADC #$00
    STA ENGINE_FPTR_30+1
    RTS ; Leave.
LOOP_HELPER_A_LOT: ; 1E:1D72, 0x03DD72
    JSR BANK_R6/INIT_PTR/SET_UNK ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable WRAM.
VAL_NONZERO: ; 1E:1D78, 0x03DD78
    JSR BANKED_ADDR_TO_PTR_UNK ; Do ??
    JSR SUB_UNK_A_TODO_BETTER ; Do ??
    JSR R6_BANKED_PTR_FORWARD_CONSUMED ; Do
    DEC GAME_SLOT_CURRENT? ; --
    BNE VAL_NONZERO ; != 0, goto.
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED ; Leave, no writes.
SUB_UNK_A_TODO_BETTER: ; 1E:1D88, 0x03DD88
    LDY #$01 ; Stream index.
    LDA SCRIPT_R6_ROUTINE_SELECT ; Load.
    STA [ENGINE_FPTR_30[2]],Y ; Store to FPRT.
    LDA SLOT/DATA_OFFSET_USE? ; Load.
    BNE VAL_NONZERO ; != 0, goto.
EXIT_CLEAR?: ; 1E:1D92, 0x03DD92
    LDY #$00 ; Stream index.
    STA [ENGINE_FPTR_30[2]],Y ; Store val.
    RTS ; Leave.
VAL_NONZERO: ; 1E:1D97, 0x03DD97
    LDY #$00 ; Stream index.
    LDA [ENGINE_FPTR_32[2]],Y ; Load from file.
    AND #$3F ; Keep lower bits.
    BEQ EXIT_CLEAR? ; == 0, goto.
    JSR STREAM_UNK ; Do ??
    LDY #$02 ; TODO this bullshit.
    LDA [ENGINE_FPTR_32[2]],Y
    AND #$3F
    LDY #$15
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$04
    LDA [ENGINE_FPTR_32[2]],Y
    LDY #$16
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$05
    LDA [ENGINE_FPTR_32[2]],Y
    LDY #$17
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$00
    LDA [ENGINE_FPTR_32[2]],Y
    AND #$C0
    LDY #$04
    STA [ENGINE_FPTR_30[2]],Y
    STA SCRIPT_LOADED_SHIFTED_UNK[1]
    LDY #$01
    LDA [ENGINE_FPTR_32[2]],Y
    LDY #$05
    STA [ENGINE_FPTR_30[2]],Y
    STA **:$00AB
    LDY #$02
    LDA [ENGINE_FPTR_32[2]],Y
    AND #$C0
    LDY #$06
    STA [ENGINE_FPTR_30[2]],Y
    STA SCRIPT_LOADED_SHIFTED_|VAL[2]
    LDY #$03
    LDA [ENGINE_FPTR_32[2]],Y
    LDY #$07
    STA [ENGINE_FPTR_30[2]],Y
    STA SCRIPT_LOADED_SHIFTED_|VAL+1
    LDY #$02
    LDA ENGINE_FPTR_32[2]
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA ENGINE_FPTR_32+1
    STA [ENGINE_FPTR_30[2]],Y
    JSR SETUP_DEEP_STREAM_UNK
    LDY #$11
    LDA STREAM_DEEP_INDEX
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA STREAM_DEEP_C
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA **:$00A7
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$18
    LDX #$08
    LDA #$00
    STA [ENGINE_FPTR_30[2]],Y
    INY
    DEX
    BNE 1E:1E0C
    RTS
STREAM_UNK: ; 1E:1E13, 0x03DE13
    LDY #$00 ; Stream index.
    STA [ENGINE_FPTR_30[2]],Y ; Store val to.
    ASL A ; << 2, *4.
    ASL A
    TAX ; To X.
    LDY #$08 ; Stream index.
    LDA ROUTINE_ATTR_A,X ; Move ??
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$14 ; Stream index.
    LDA ROUTINE_ATTR_B,X
    STA [ENGINE_FPTR_30[2]],Y
    RTS ; Leave.
BANK_R6/INIT_PTR/SET_UNK: ; 1E:1E29, 0x03DE29
    LDA SCRIPT_R6_ROUTINE_SELECT ; Load ??
    JSR BANK_HANDLER_R6_AND_BASE ; Bank R6.
    ASL A ; Val based.
    TAX ; To index.
    LDA $8000,X ; Move ptr from bank.
    STA R6_BANKED_ADDR_MOVED[2]
    LDA $8001,X
    STA R6_BANKED_ADDR_MOVED+1
    LDA #$02
    STA SLOT/DATA_OFFSET_USE? ; Set ??
INIT_PTR_WRAM_6800/COUNT_UNK: ; 1E:1E3E, 0x03DE3E
    LDA #$00
    LDX #$68
    STA ENGINE_FPTR_30[2] ; Set $6800 ??
    STX ENGINE_FPTR_30+1
    LDX #$28
    STX GAME_SLOT_CURRENT? ; Set count?
    RTS ; Leave.
BANKED_ADDR_TO_PTR_UNK: ; 1E:1E4B, 0x03DE4B
    LDY #$01 ; Stream index.
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    BEQ STREAM_ZERO ; == 0, leave.
    STA ENGINE_FPTR_32+1 ; Store ??
    DEY ; Stream--
    LDA [R6_BANKED_ADDR_MOVED[2]],Y ; Load from stream.
    STA ENGINE_FPTR_32[2] ; Store ??
    RTS ; Leave.
STREAM_ZERO: ; 1E:1E59, 0x03DE59
    STA SLOT/DATA_OFFSET_USE? ; Clear.
    RTS ; Leave.
R6_BANKED_PTR_FORWARD_CONSUMED: ; 1E:1E5C, 0x03DE5C
    CLC ; Prep add.
    LDA R6_BANKED_ADDR_MOVED[2] ; Load from file.
    ADC SLOT/DATA_OFFSET_USE? ; Add with.
    STA R6_BANKED_ADDR_MOVED[2] ; Store back.
    LDA R6_BANKED_ADDR_MOVED+1 ; Carry add.
    ADC #$00
    STA R6_BANKED_ADDR_MOVED+1
    JMP ENGINE_FPTR_COL/ROW_MOD/FORWARD? ; Goto.
BANK_HANDLER_R6_AND_BASE: ; 1E:1E6C, 0x03DE6C
    CMP #$2B ; If _ #$2B
    BCC LT_0x2B ; <, goto.
    LDX #$12 ; Seed bank to use.
    SBC #$2B ; Rebase 0.
    BCS A_REBASED ; Always taken.
LT_0x2B: ; 1E:1E76, 0x03DE76
    CMP #$1A ; If _ #$1A
    BCC LT_0x1A ; <, goto.
    LDX #$11 ; Seed bank to use.
    SBC #$1A ; Rebase 0.
    BCS A_REBASED
LT_0x1A: ; 1E:1E80, 0x03DE80
    LDX #$10 ; Seed bank.
A_REBASED: ; 1E:1E82, 0x03DE82
    PHA ; Save index into bank routines.
    TXA ; Bank val to A.
    LDX #$06 ; Seed R6 mod.
    JSR ENGINE_SET_MAPPER_BANK_X_VAL_A ; Set R6 to bank.
    PLA ; Pull index for routine in the bank, starting at 0x00, is based on 0x00 into bank here.
    RTS ; Leave.
    LDX #$06
    LDA #$00
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
    LDX #$06
    LDA #$00
    JMP ENGINE_SET_MAPPER_BANK_X_VAL_A
ENGINE_MAP_DISPLAY?: ; 1E:1E99, 0x03DE99
    JSR BANK_R6/INIT_PTR/SET_UNK ; Do.
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable writes.
LOOP_NONZERO: ; 1E:1E9F, 0x03DE9F
    JSR BANKED_ADDR_TO_PTR_UNK ; Do.
    LDY #$01 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from fptr.
    CMP SCRIPT_R6_ROUTINE_SELECT ; If _ routine.
    BEQ ROUTINE_MATCH ; ==, goto.
    LDY #$00
    LDA [ENGINE_FPTR_30[2]],Y ; Load base. Size?
    ASL A ; << 1, *2. Word size.
    BEQ VAL_SHIFTED_0x00 ; == 0, goto.
    JSR MAP?_RTN_A ; Do.
    BCS STREAM_KEEP_LOWER ; Ret CS, goto.
VAL_SHIFTED_0x00: ; 1E:1EB6, 0x03DEB6
    JSR SUB_UNK_A_TODO_BETTER ; Do ??
ROUTINE_MATCH: ; 1E:1EB9, 0x03DEB9
    LDY #$00 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from file.
    ASL A ; << 1, *2.
    BEQ STREAM_NEG_SET ; == 0, goto.
    JSR MAP?_RTN_A ; Do ??
    BCS STREAM_KEEP_LOWER ; Ret CS, goto.
    LDY #$00 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load.
    ORA #$80 ; Set top bit.
    STA [ENGINE_FPTR_30[2]],Y ; Goto.
    BMI STREAM_NEG_SET ; Always taken.
STREAM_KEEP_LOWER: ; 1E:1ECF, 0x03DECF
    LDY #$00
    LDA [ENGINE_FPTR_30[2]],Y
    AND #$3F
    STA [ENGINE_FPTR_30[2]],Y
STREAM_NEG_SET: ; 1E:1ED7, 0x03DED7
    JSR R6_BANKED_PTR_FORWARD_CONSUMED ; Forward.
    DEC GAME_SLOT_CURRENT? ; --
    BNE LOOP_NONZERO ; != 0, loop.
    JSR INIT_PTR_WRAM_6800/COUNT_UNK ; Reinit.
    LDY #$00 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    BEQ STREAM_EQ_0x00 ; == 0, goto.
    BMI STREAM_EQ_0x00 ; Negative, goto.
    JSR SWITCH_MAP/SCREEN? ; Switch with stream.
    JSR STREAMS_UNK_LOGICAL? ; Do ??
STREAM_EQ_0x00: ; 1E:1EEF, 0x03DEEF
    JSR ENGINE_FPTR_COL/ROW_MOD/FORWARD?
    DEC GAME_SLOT_CURRENT?
    BNE 1E:1EE1
    JMP ENGINE_WRAM_STATE_WRITE_DISABLED
STREAMS_UNK_LOGICAL?: ; 1E:1EF9, 0x03DEF9
    LDY #$11 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    STA ARR_BITS_TO_UNK+1 ; Store to.
    INY ; Stream++
    LDA [ENGINE_FPTR_30[2]],Y ; 2x
    STA ARR_BITS_TO_UNK+2
    INY
    LDA [ENGINE_FPTR_30[2]],Y ; 3x
    STA ARR_BITS_TO_UNK+3
    LDY #$00 ; Reset stream.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    BPL STREAM_POSITIVE ; Positive, goto.
    JMP STREAM_NEG ; Goto otherwise.
STREAM_POSITIVE: ; 1E:1F12, 0x03DF12
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR_B?[2] ; Load ??
    ADC #$60 ; Add with.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Store to.
    LDA SCRIPT_PAIR_PTR_B?+1 ; Load ??
    ADC #$00 ; Carry add.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Store to.
    SEC ; Prep sub.
    LDY #$04 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    SBC ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Sub with.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Store result.
    INY ; Stream++
    LDA [ENGINE_FPTR_30[2]],Y ; Load from stream.
    SBC ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Sub with carry.
    STA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Store result.
    CLC ; Prep add.
    LDA SCRIPT_PAIR_PTR?[2] ; Load ??
    ADC #$A4 ; += 0xA4
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store to.
    LDA SCRIPT_PAIR_PTR?+1 ; Load ??
    ADC #$00 ; Carry add.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store.
    SEC ; Prep sub.
    LDY #$06 ; Stream index.
    LDA [ENGINE_FPTR_30[2]],Y ; Load from file.
    SBC SAVE_GAME_MOD_PAGE_PTR[2] ; Mod val.
    STA SAVE_GAME_MOD_PAGE_PTR[2] ; Store.
    INY ; Stream++
    LDA [ENGINE_FPTR_30[2]],Y ; Load stream.
    SBC SAVE_GAME_MOD_PAGE_PTR+1 ; Mod val.
    STA SAVE_GAME_MOD_PAGE_PTR+1 ; Store result.
    LDY #$08 ; Stream index.
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Load.
    AND #$04 ; Keep bit.
    ASL A ; << 5, *32.
    ASL A
    ASL A
    ASL A
    ASL A ; 0000.0100 -> 1000.0000
    ORA [ENGINE_FPTR_30[2]],Y ; Set at ptr.
    STA [ENGINE_FPTR_30[2]],Y
    INY ; Stream++
    LDA SAVE_GAME_MOD_PAGE_PTR+1 ; Load.
    AND #$04 ; Keep bit.
    ASL A ; Save as above.
    ASL A
    ASL A
    ASL A
    ASL A
    ORA [ENGINE_FPTR_30[2]],Y ; Set at ptr.
    STA [ENGINE_FPTR_30[2]],Y
    INY ; Stream++
    LDA ENGINE_PALETTE_FPTR/BITS/GEN_USE[2] ; Load val.
    LSR ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; Shift down.
    ROR A ; Into A.
    LSR ENGINE_PALETTE_FPTR/BITS/GEN_USE+1 ; 2x
    ROR A
    STA [ENGINE_FPTR_30[2]],Y ; Store at ptr.
    INY ; Stream++
    LDA SAVE_GAME_MOD_PAGE_PTR[2] ; Load val.
    LSR SAVE_GAME_MOD_PAGE_PTR+1 ; Shift down.
    ROR A ; Into A.
    LSR SAVE_GAME_MOD_PAGE_PTR+1 ; 2x
    ROR A
    STA [ENGINE_FPTR_30[2]],Y ; Store at ptr.
    LDA **:$003E ; Load ??
    BMI VAL_NEGATIVE ; Negative, goto.
    LDY #$04 ; Stream index.
    LDA STREAM_WRITE_ARR_UNK[4] ; Move arr to stream.
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA STREAM_WRITE_ARR_UNK+1 ; 2x
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$06 ; Stream index load. INY better mistake.
    LDA STREAM_WRITE_ARR_UNK+2
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA STREAM_WRITE_ARR_UNK+3
    STA [ENGINE_FPTR_30[2]],Y
    LDY #$11 ; Stream mod.
    LDA STREAM_DEEP_INDEX ; Move to stream.
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA STREAM_DEEP_C ; 2x
    STA [ENGINE_FPTR_30[2]],Y
    INY
    LDA **:$00A7 ; 3x
    STA [ENGINE_FPTR_30[2]],Y
    LDY STREAM_DEEP_INDEX ; Load val.
    LDA GAME_SLOT_CURRENT? ; Load ??
    STA [STREAM_DEEP_C],Y
STREAM_NEG: ; 1E:1FAF, 0x03DFAF
    LDY ARR_BITS_TO_UNK+1 ; Load ??
    LDA GAME_SLOT_CURRENT? ; Load ??
    EOR [ARR_BITS_TO_UNK+2],Y ; Invert at stream.
    BEQ INVERT_EQ_0x00 ; == 0, goto.
    RTS ; Leave if nonzero.
VAL_NEGATIVE: ; 1E:1FB8, 0x03DFB8
    LDY ARR_BITS_TO_UNK+1 ; Load ??
    LDA GAME_SLOT_CURRENT? ; Load ?? for stream.
INVERT_EQ_0x00: ; 1E:1FBC, 0x03DFBC
    STA [ARR_BITS_TO_UNK+2],Y ; Store to stream.
    RTS ; Leave.
    LDY #$11
    LDA [ENGINE_FPTR_30[2]],Y
    STA STREAM_DEEP_INDEX
    INY
    LDA [ENGINE_FPTR_30[2]],Y
    STA STREAM_DEEP_C
    INY
    LDA [ENGINE_FPTR_30[2]],Y
    STA **:$00A7
    LDA #$00
    LDY STREAM_DEEP_INDEX
    STA [STREAM_DEEP_C],Y
    LDY #$00
    STA [ENGINE_FPTR_30[2]],Y
    RTS
STREAMS_UNK_SPRITE_READ?: ; 1E:1FDA, 0x03DFDA
    LDA CURRENT_SAVE_MANIPULATION_PAGE+543 ; Load ??
    LSR A ; >> 1, /2.
    LDA #$80 ; Seed ??
    LDX #$67
    LDY #$2C ; Val ??
    BCC CARRY_CLEAR_VALS
    LDA #$00 ; Alt vals, CS.
    LDX #$68
    LDY #$28 ; Val??
CARRY_CLEAR_VALS: ; 1E:1FEC, 0x03DFEC
    STA ENGINE_FPTR_30[2] ; Store fptr.
    STX ENGINE_FPTR_30+1
    STY GAME_SLOT_CURRENT? ; Store ??
    LDA #$18
    STA **:$00E3 ; Set ??
    LDA #$00
    STA **:$0300 ; Set ??
    LDX #$08 ; Val ??
    JSR ENGINE_WRAM_STATE_WRITEABLE ; Enable writes.
